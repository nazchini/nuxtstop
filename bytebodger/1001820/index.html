<!doctype html>
<html data-n-head-ssr lang="en" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Should Frontend Devs Care About Performance??</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content="Using Nuxt.js fetch() hook to build dev.to with a new look"><meta data-n-head="ssr" name="format-detection" content="telephone=no"><base href="/nuxtstop/"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:400,500,600&display=swap"><link rel="preload" href="/nuxtstop/_nuxt/f6e87fb.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/6474719.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/9b75090.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/18df600.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/dc9ce94.js" as="script"><style data-vue-ssr-id="c650fd98:0 af4684f0:0 a9c71758:0 dcafa518:0 4b9cec49:0 b093d766:0 9d98bcb4:0 6b6a11ea:0 0248ed80:0 ea8e4264:0">html{box-sizing:border-box;font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}*,:after,:before{box-sizing:inherit}html{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,:after,:before{border:0 solid #e0e0e0}blockquote,body,dd,dl,figure,h1,h2,h3,h4,h5,h6,p,pre{margin:0}button{background:0 0;padding:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset,ol,ul{margin:0;padding:0}ol,ul{list-style:none}hr{border-width:1px}img{border-style:solid}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:inherit;opacity:.5}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:inherit;opacity:.5}input::placeholder,textarea::placeholder{color:inherit;opacity:.5}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit;font-family:sans-serif}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit;font-family:inherit;font-size:100%}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;overflow:auto;word-break:break-word;white-space:normal}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}html{height:100%;font-size:18px;-ms-overflow-style:scrollbar;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none}@media(min-width:640px){html{font-size:20px}}body{height:100%;min-width:320px;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:400;line-height:1.5;color:#000;background-color:#eff4f7;-webkit-text-rendering:optimizeLegibility;text-rendering:optimizeLegibility;font-synthesis:none;font-kerning:normal;font-feature-settings:"normal","kern";-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-overflow-scrolling:touch;overflow-x:hidden;overflow-y:scroll}h1,h2,h3,h4,h5,h6{color:#000;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:600;font-feature-settings:"normal";line-height:1.2}pre{background:#29292e;border-radius:2px;overflow:auto;padding:1rem;color:#eff1f9;line-height:1.42em;font-size:13px}@media screen and (min-width:380px){pre{font-size:15px}}pre code{background:#29292e;color:#eff0f9;white-space:pre}div.highlight pre.highlight code{font-size:inherit;padding:0}div.inner-comment div.body div.highlight pre.highlight{background:#29292e}div.inner-comment div.body div.highlight pre.highlight code{font-size:inherit;white-space:inherit;background:inherit;color:inherit}.highlight .hll{background-color:#49483e}.highlight{background:#29292e;color:#f8f8f2}.highlight .c{color:grey}.highlight .err{text-shadow:0 0 7px #f9690e}.highlight .k{color:#f39c12}.highlight .l{color:plum}.highlight .n{color:#f8f8f2}.highlight .o{color:#f9690e}.highlight .p{color:#f8f8f2}.highlight .c1,.highlight .ch,.highlight .cm,.highlight .cp,.highlight .cpf,.highlight .cs{color:grey}.highlight .gd{color:#f9690e}.highlight .ge{font-style:italic}.highlight .gi{color:#7ed07e}.highlight .gs{font-weight:700}.highlight .gu{color:grey}.highlight .kc,.highlight .kd{color:#f39c12}.highlight .kn{color:#f9690e}.highlight .kp,.highlight .kr,.highlight .kt{color:#f39c12}.highlight .ld{color:#f2ca27}.highlight .m{color:plum}.highlight .s{color:#f2ca27}.highlight .na{color:#7ed07e}.highlight .nb{color:#f8f8f2}.highlight .nc{color:#7ed07e}.highlight .no{color:#f39c12}.highlight .nd{color:#7ed07e}.highlight .ni{color:#f8f8f2}.highlight .ne,.highlight .nf{color:#7ed07e}.highlight .nl,.highlight .nn{color:#f8f8f2}.highlight .nx{color:#7ed07e}.highlight .py{color:#f8f8f2}.highlight .nt{color:#f9690e}.highlight .nv{color:#f8f8f2}.highlight .ow{color:#f9690e}.highlight .w{color:#f8f8f2}.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo{color:plum}.highlight .dl,.highlight .s2,.highlight .sa,.highlight .sb,.highlight .sc,.highlight .sd{color:#f2ca27}.highlight .se{color:plum}.highlight .s1,.highlight .sh,.highlight .si,.highlight .sr,.highlight .ss,.highlight .sx{color:#f2ca27}.highlight .bp{color:#f8f8f2}.highlight .fm{color:#7ed07e}.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#f8f8f2}.highlight .il{color:plum}.vue-content-placeholders-heading__img,.vue-content-placeholders-heading__subtitle,.vue-content-placeholders-heading__title,.vue-content-placeholders-img,.vue-content-placeholders-text__line{background:#bfcdec!important}.vue-content-placeholders-is-animated .vue-content-placeholders-heading__img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__subtitle:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__title:before,.vue-content-placeholders-is-animated .vue-content-placeholders-img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-text__line:before{background:linear-gradient(90deg,transparent 0,#d3ddf9 15%,transparent 30%)!important}header[data-v-27046cca]{max-width:1280px;margin:auto;padding:1rem;height:6rem;border-bottom:1px solid rgba(0,0,0,.2)}header .logo-wrapper[data-v-27046cca],header[data-v-27046cca]{display:flex;align-items:center;justify-content:space-between}header .logo-wrapper[data-v-27046cca]{margin:0 .5rem}header .logo-wrapper svg[data-v-27046cca]{width:3rem;height:100%}header .logo-wrapper .name-wrapper[data-v-27046cca]{margin-left:.6em}header .logo-wrapper .name-wrapper .subtitle[data-v-27046cca]{font-size:1rem}header .logo-wrapper .name-wrapper .app-name[data-v-27046cca]{font-weight:700;font-size:2.25rem;line-height:1.25}header nav[data-v-27046cca]{letter-spacing:-.025rem;font-weight:600;text-transform:uppercase}header nav ul[data-v-27046cca]{display:flex}header nav ul li[data-v-27046cca]{margin:0 .5rem}header nav ul li a[data-v-27046cca]{box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;padding:.25rem 1rem;border-radius:.5rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}header nav ul li a[data-v-27046cca]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header nav ul li a.nuxt-link-exact-active[data-v-27046cca]{cursor:default}header nav ul li a.nuxt-link-exact-active[data-v-27046cca],header nav ul li a[data-v-27046cca]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}.page-wrapper[data-v-10d06ee8]{max-width:1280px;margin:auto;padding:1rem}.article-content-wrapper[data-v-10d06ee8]{display:flex;flex-direction:column;align-items:center;margin:auto auto 2rem}@media(min-width:1024px){.article-content-wrapper[data-v-10d06ee8]{align-items:normal;flex-direction:row}}.article-content-wrapper .article-block[data-v-10d06ee8]{width:100%;max-width:880px}@media(min-width:1024px){.article-content-wrapper .article-block[data-v-10d06ee8]{margin-right:1rem;width:66.66666%;margin-bottom:2rem}}.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{max-width:880px;width:100%;position:relative}@media(min-width:1024px){.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{display:block;width:33.33333%}}.article-content-wrapper .aside-username-wrapper .aside-username-block[data-v-10d06ee8]{position:-webkit-sticky;position:sticky;top:1rem}@media(min-width:1280px){.comments-block[data-v-10d06ee8]{margin:.5rem}}article[data-v-70afb46a]{padding:.5rem;border-radius:1rem}header h1[data-v-70afb46a],header[data-v-70afb46a]{margin-bottom:1rem}header h1[data-v-70afb46a]{font-size:2.25rem;letter-spacing:-.025rem}header .tags[data-v-70afb46a]{display:flex;flex-wrap:wrap;margin-bottom:1.5rem}header .tags .tag[data-v-70afb46a]{font-weight:500;line-height:1;padding:.5rem;margin:0 .5rem .5rem 0;border-radius:.25rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db}header .tags .tag[data-v-70afb46a]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header .tags .tag[data-v-70afb46a]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}header .image-wrapper[data-v-70afb46a]{position:relative;padding-bottom:56.25%;background-color:#d4dfe8;margin-bottom:1.5rem;border-radius:.5rem;overflow:hidden}@media(min-width:834px){header .image-wrapper[data-v-70afb46a]{margin-bottom:1.5rem}}header .image-wrapper img[data-v-70afb46a]{position:absolute;top:0;left:0;width:100%;height:100%;-o-object-fit:cover;object-fit:cover}header .meta[data-v-70afb46a]{line-height:1;font-size:.875rem;text-transform:uppercase;font-weight:500;letter-spacing:-.025rem;display:flex;align-items:center;justify-content:space-between}header .meta .scl[data-v-70afb46a]{display:flex}header .meta .scl span[data-v-70afb46a]{display:flex;align-items:center;margin-right:1rem}header .meta .scl span svg[data-v-70afb46a]{margin-right:.25rem}header .meta .scl .comments[data-v-70afb46a]{cursor:pointer}[data-v-70afb46a] .content .ltag__user{display:none}[data-v-70afb46a] .content iframe{max-width:100%}[data-v-70afb46a] .content h1{font-size:1.875rem}[data-v-70afb46a] .content h1,[data-v-70afb46a] .content h2{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h2{font-size:1.5rem}[data-v-70afb46a] .content h3{font-size:1.25rem}[data-v-70afb46a] .content h3,[data-v-70afb46a] .content h4{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h4{font-size:1rem}[data-v-70afb46a] .content a{color:#6e87d2}[data-v-70afb46a] .content p{margin-bottom:1rem;line-height:1.4}[data-v-70afb46a] .content p code{background-color:#d2f3e1;border-radius:.25rem;padding:.25rem}[data-v-70afb46a] .content img{width:100%;border-radius:.5rem}[data-v-70afb46a] .content .highlight{margin-bottom:1rem;border-radius:.5rem}[data-v-70afb46a] .content ul{list-style:numeral;margin-bottom:1rem}[data-v-70afb46a] .content ul li p{margin-bottom:0}[data-v-70afb46a] .content ol{margin-bottom:1rem}aside[data-v-37984f8c]{padding:1rem;background-color:#dfe8ef;border-radius:1rem}aside .username-heading[data-v-37984f8c]{display:flex;margin-bottom:1rem}aside .username-heading[data-v-37984f8c]:hover{color:#6e87d2}aside .username-heading img[data-v-37984f8c]{width:3rem;height:3rem;border-radius:50%;margin-right:1rem}aside .username-heading .text[data-v-37984f8c]{display:flex;flex-direction:column;justify-content:center}aside .username-heading .text a[data-v-37984f8c]{line-height:1}aside .username-heading .text a[data-v-37984f8c]:first-child{font-size:1.25rem;font-weight:500;letter-spacing:-.025rem;margin-bottom:.25rem}aside .username-heading .text a[data-v-37984f8c]:last-child{color:#999;font-size:.875rem}aside .username-heading.loading[data-v-37984f8c]{display:block}aside .f-button[data-v-37984f8c]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}aside .f-button[data-v-37984f8c]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}aside .f-button[data-v-37984f8c]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}aside .info>div[data-v-37984f8c]{margin-bottom:.5rem}aside .info .title[data-v-37984f8c]{font-size:.666666rem;letter-spacing:-.0125rem;font-weight:500;color:#999;text-transform:uppercase;margin-bottom:.1rem}aside .info .content[data-v-37984f8c]{font-size:.875rem;line-height:1.4}.add-comment[data-v-8c4375bc]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}.add-comment[data-v-8c4375bc]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}.add-comment[data-v-8c4375bc]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}footer[data-v-22cb8fd0]{padding:2rem;text-align:center;display:flex;align-items:center;justify-content:center}footer span[data-v-22cb8fd0]{display:inline-block;line-height:1;text-transform:uppercase;letter-spacing:-.025rem;font-size:.75rem;font-weight:500}footer a svg[data-v-22cb8fd0]{width:3rem;height:3rem;margin:0 .5rem}footer a .nuxt-icon[data-v-22cb8fd0]{width:2.5rem;height:2.5rem;margin:0 .25rem}</style>
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><div id="__layout"><div><header data-v-27046cca><a href="/nuxtstop/" class="logo-wrapper nuxt-link-active" data-v-27046cca><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-27046cca><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-27046cca></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-27046cca></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-27046cca></path></svg> <div class="name-wrapper" data-v-27046cca><span class="app-name" data-v-27046cca>Nuxtstop</span> <p class="subtitle" data-v-27046cca>For all things nuxt.js</p></div></a> <nav data-v-27046cca><ul data-v-27046cca><li data-v-27046cca><a href="/nuxtstop/" class="nuxt-link-active" data-v-27046cca>
          New
        </a></li><li data-v-27046cca><a href="/nuxtstop/top" data-v-27046cca>
          Top
        </a></li></ul></nav></header> <div class="page-wrapper" data-v-10d06ee8><div class="article-content-wrapper" data-v-10d06ee8><article data-fetch-key="data-v-70afb46a:0" class="article-block" data-v-70afb46a data-v-10d06ee8><header data-v-70afb46a><h1 data-v-70afb46a>Should Frontend Devs Care About Performance??</h1> <div class="tags" data-v-70afb46a><a href="/nuxtstop/t/javascript" class="tag" data-v-70afb46a>
          #javascript
        </a><a href="/nuxtstop/t/performance" class="tag" data-v-70afb46a>
          #performance
        </a><a href="/nuxtstop/t/webdev" class="tag" data-v-70afb46a>
          #webdev
        </a><a href="/nuxtstop/t/developer" class="tag" data-v-70afb46a>
          #developer
        </a></div> <div class="image-wrapper" data-v-70afb46a><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--1QULGcme--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xxo5nbnplde50lj1nehb.png" alt="Should Frontend Devs Care About Performance??" data-v-70afb46a></div> <div class="meta" data-v-70afb46a><div class="scl" data-v-70afb46a><span data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M16.4444 3C14.6733 3 13.0333 3.94162 12 5.34C10.9667 3.94162 9.32667 3 7.55556 3C4.49222 3 2 5.52338 2 8.625C2 14.8024 11.0267 20.586 11.4122 20.829C11.5922 20.9426 11.7956 21 12 21C12.2044 21 12.4078 20.9426 12.5878 20.829C12.9733 20.586 22 14.8024 22 8.625C22 5.52338 19.5078 3 16.4444 3Z" fill="#FF0000" data-v-70afb46a data-v-70afb46a></path></svg>
            364
          </span> <span class="comments" data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M6.11765 22H4.94118L5.64706 21.05C6.11765 20.3969 6.41176 19.5656 6.58824 18.5563C3.64706 17.1906 2 14.6375 2 11.3125C2 6.20625 5.82353 3 12 3C18.1765 3 22 6.20625 22 11.3125C22 16.5375 18.2353 19.625 12 19.625H11.5882C10.6471 20.7531 9 22 6.11765 22ZM12 4.1875C6.47059 4.1875 3.17647 6.85937 3.17647 11.3125C3.17647 15.1125 5.47059 16.8938 7.41177 17.6656L7.82353 17.8437L7.76471 18.3187C7.64706 19.2687 7.47059 20.1 7.11765 20.8125C9.05882 20.575 10.1765 19.5656 10.8235 18.7344L11 18.4969H12C19.9412 18.4969 20.8235 13.5094 20.8235 11.3719C20.8235 6.85938 17.5294 4.1875 12 4.1875Z" fill="black" data-v-70afb46a data-v-70afb46a></path></svg>
            50
          </span></div> <time data-v-70afb46a>Feb 27</time></div></header> <div class="content" data-v-70afb46a><p>I was recently talking to an architect at Amazon and he made a <em>very</em> interesting comment to me.  We were talking about the complexity of a given algorithm (discussed in Big-O notation), and before we even got too far into the explanation, he said:<br>
<br></p>

<blockquote>
<p>I mean, it's not like we need to worry <em>too</em> much about this.  After all, we're frontend devs!</p>
</blockquote>

<p><br>I found this admission to be extremely refreshing, and it was entirely unexpected coming from someone in the Ivory Tower that is Amazon.  It's something that I've always known.  But it was still really nice to hear it coming from someone working for the likes of a FAANG company.</p>

<p>You see, <em>performance</em> is one of those subjects that programmers love to obsess about.  They use it as a Badge of Honor.  They see that you've used JavaScript's native <code>.sort()</code> method, then they turn up their nose and say something like, "Well, <em>you know</em>... That uses <code>O(n log(n))</code> complexity."  Then they walk away with a smug smirk on their face, as though they've banished your code to the dustbin of Failed Algorithms.<br>
<br><br></p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--j36tnL_U--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/rv40jhqgjk5z7gpdd3eo.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--j36tnL_U--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/rv40jhqgjk5z7gpdd3eo.png" alt="Image description" loading="lazy" width="880" height="495"></a></p>
<h2>
  <a name="smart-clients-vs-dumb-terminals" href="#smart-clients-vs-dumb-terminals">
  </a>
  Smart Clients vs. Dumb Terminals
</h2>

<p>The terms "smart client" and "dumb terminal" have fallen somewhat by-the-wayside in recent decades.  But they're still valid definitions, even in our modern computing environments.  </p>

<p><strong>Mainframe Computing</strong></p>

<p>Way back in the Dark Ages, nearly all computing was done on massive computers (e.g., <em>mainframes</em>).  And you interacted with those computers by using a "terminal".  Those terminals were often called "dumb terminals" because the terminal itself had almost no computing power of its own.  It only served as a way for you to send commands to the mainframe and then view whatever results were returned from... the mainframe.  That's why it was called "dumb".  Because the terminal itself couldn't really <em>do</em> much of anything on its own.  It only served as a portal that gave you access to the mainframe.</p>

<p>For those who wrote mainframe code, they had to worry greatly about the <em>efficiency</em> of their algorithms.  Because even the mainframe had comparatively-little computing power (by today's standards).  More importantly, the mainframe's resources were <em>shared</em> by anyone with access to one of the dumb terminals.  So if 100 people, sitting at 100 dumb terminals, all sent resource-intensive commands at the same time, it was pretty easy to crash the mainframe.  (This is also why the allocation of terminals was very strict, and even those who had access to mainframe terminals often had to reserve time on them.)</p>

<p><strong>PC Computing</strong></p>

<p>With the PC explosion in the 80s, suddenly you had a lot of people with a lot of computing power (relatively speaking) sitting on their desktop.  And most of the time, that computing power was underutilized.  Thus spawned the age of "smart clients".</p>

<p>In a smart client model, every effort is made to allow the client to do its own computing.  It only communicates back to the server when existing data must be retrieved from the source, or when new/updated data must be sent back to that source.  This offloaded a great deal of work <em>off</em> of the mainframe, down to the clients, and allowed for the creation of much more robust applications.</p>

<p><strong>A Return To Mainframe Computing (Sorta...)</strong></p>

<p>But when the web came around, it knocked many applications back into a server/terminal kinda relationship.  That's because those apps <em>appeared</em> to be running in the browser, but the simple fact is that early browser technology was incapable of really <em>doing</em> much on its own.  Early browsers were quite analogous to dumb terminals.  They could see data that was sent from the server (in the form of HTML/CSS).  But if they wanted to <em>interact</em> with that data in any meaningful way, they needed to constantly send their commands <em>back</em> to the server.</p>

<p>This also meant that early web developers needed to be hyper-vigilant about efficiency.  Because even a seemingly-innocuous snippet of code could drag your server to its knees if your site suddenly went viral and that code was being run by hundreds (or thousands) of web surfers concurrently.</p>

<p>This could be somewhat alleviated by deploying more robust backend technologies.  For example, you could deploy a web <em>farm</em> that shared the load of requests for a single site.  Or you could write your code in a compiled language (like Java or C#), which helped (somewhat) because compiled code typically runs faster than interpreted code.  But you were still bound by the limits that came from having <em>all</em> of your public users hitting a finite set of server/computing resources.<br>
<br><br></p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Tzvwx6pK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vc6etpjun7dwy0ktvnz2.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Tzvwx6pK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vc6etpjun7dwy0ktvnz2.jpg" alt="Image description" loading="lazy" width="880" height="513"></a></p>
<h2>
  <a name="the-browser-as-smart-client" href="#the-browser-as-smart-client">
  </a>
  The Browser AS Smart Client
</h2>

<p>I'm not going to delve into the many arguments for-or-against Chrome.  But one of its greatest contributions to web development is that it was one of the first browsers that was continually optimized specifically for JavaScript performance.  When this optimization was combined with powerful new frameworks like jQuery (then Angular, then React, then...), it fostered the rise of the <em>frontend developer</em>.  </p>

<p>This didn't just give us new capabilities for frontend functionality, it also meant that we could start thinking, again, in terms of the desktop (browser) being a <em>smart</em> client.  In other words, we didn't necessarily have to stay up at night wondering if that one aberrant line of code was going to crash <em>the server</em>.  At worst, it might crash <em>someone's browser</em>.  (And don't get me wrong, writing code that crashes browsers is still a very <em>bad</em> thing to do.  But it's farrrrr less likely to occur when the desktop/browser typically has all those unused CPU cycles just waiting to be harnessed.)</p>

<p>So when you're writing, say, The Next Great React App, how much, exactly, do you even need to <em>care</em> about performance??  After all, the bulk of your app will be running in someone's browser.  And even if that browser is running <em>on a mobile device</em>, it probably has loads of unleveraged processing power available for you to use.  So how much do you need to be concerned about the nitty-gritty details of your code's performance?  IMHO, the answer is simple - yet nuanced. </p>

<p><strong>Care... But Not <em>That</em> Much</strong></p>

<p>Years ago, I was listening to a keynote address from the CEO of a public company.  Public companies must always (understandably) have one eye trained on the stock market.  During his talk, he posed the question: <em>How much do I care about our company's stock price?</em>  And his answer was that he cared... but not that much.  In other words, he was always <em>aware</em> of the stock price.  And of course, he was cognizant of the things his company could do (or avoid doing) that would potentially influence their stock price.  But he was adamant that he could not make every internal corporate decision based upon one simple factor - whether or not it would juice the stock price.  He had to <em>care</em> about the stock price, because a tanking stock price can cause all sorts of problems for a public company.  But if he allowed himself to focus, with tunnel vision, on that stock price, he could end up making decisions that bump the price by a few pennies - but end up hurting the company in the long run.</p>

<p>Frontend app development is very similar in my eyes.  You should always be <em>aware</em> of your code's performance.  You certainly don't want to write code that will cause your app to run noticeably <em>bad</em>.  But you also don't want to spend half of every sprint trying to micro-optimize every minute detail of your code.</p>

<p>If this all sounds terribly abstract, I'll try to give you some guidance on <em>when</em> you need to care about application performance - and when you shouldn't allow it to bog down your development.<br>
<br><br></p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--9gGhEpKX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/e6hv8m1s1uvr199yaey5.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--9gGhEpKX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/e6hv8m1s1uvr199yaey5.png" alt="Image description" loading="lazy" width="880" height="394"></a></p>
<h2>
  <a name="developer-trials" href="#developer-trials">
  </a>
  Developer Trials
</h2>

<p>The first thing you need to keep in mind is that your code will (hopefully) be reviewed by others devs.  This happens when you submit new code, or even when someone comes by months later and looks at what you've written.  And many devs <em>LOVE</em> to nitpick your code for performance.</p>

<p>You can't avoid these "trials".  They happen all the time.  The key is not to get sucked into theoretical debates about the benchmark performance of a <code>for</code> loop versus the <code>Array.prototype</code> function of <code>.forEach()</code>.  Instead, you should try, whenever possible, to steer the conversation back into the realm of reality.</p>

<p><strong>Benchmarking Based Upon Reality</strong></p>

<p>What do I mean by "reality"?  Well, first of all, we now have many tools that allow us to benchmark our apps <em>in the browser</em>.  So if someone can point out that I can shave a few seconds of load time off my app by making one-or-two minor changes, I'm all ears.  But if their proposed optimization only "saves" me a few <em>microseconds</em>, I'm probably gonna ignore their suggestions.</p>

<p>You should also be cognizant of the fact that a language's <em>built-in</em> functions will almost always outperform any custom code.  So if someone claims that they have a bit of custom code that is more performant than, say, <code>Array.prototype.find()</code>, I'm immediately skeptical.  But if they can show me how I can achieve the desired result without even <em>using</em> <code>Array.prototype.find()</code> at all, I'm happy to hear the suggestion.  However, if they simply believe that <em>their</em> method of doing a <code>.find()</code> is more performant than using the <code>Array.prototype.find()</code>, then I'm going to be incredibly skeptical.</p>

<p><strong>Your Code's Runtime Environment</strong></p>

<p>"Reality" is also driven by one simple question: <em>Where does the code RUN???</em>  If the code-in-question runs in, say, Node (meaning that it runs <em>on the server</em>), performance tweaks take on a heightened sense of urgency, because that code is <em>shared</em> and is being hit by everyone who uses the app.  But if the code runs <em>in the browser</em>, you're not a crappy dev just because the tweak is not forefront in your mind.</p>

<p>Sometimes, the code we're examining isn't even running in an app at all.  This happens whenever we decide to do purely academic exercises that are meant to gauge our overall awareness of performance metrics.  Code like this may be running in a JSPerf panel, or in a demo app written on StackBlitz.  In those scenarios, people are much more likely to be focused on finite details of performance, simply because <em>that's the whole point of the exercise</em>.  As you might imagine, these types of discussions tend to crop up most frequently during... job interviews.  So it's dangerous to be downright flippant about performance when the audience really cares about almost nothing <em>but</em> the performance.</p>

<p><strong>The "Weight" Of Data Types</strong></p>

<p>"Reality" should also encompass a thorough understanding of what <em>types</em> of data that you're manipulating.  For example, if you need to do a wholesale transformation on an array, it's perfectly acceptable to ask yourself: <em>How BIG can this array reasonably become?</em>  Or... <em>What TYPES of data can the array typically hold?</em></p>

<p>If you have an array that only holds integers, and we know that the array will <em>never</em> hold more than, say, a dozen values, then I really don't care much about the exact method(s) you've chosen to transform that data.  You can use <code>.reduce()</code> nested inside a <code>.find()</code>, nested inside a <code>.sort()</code>, which is ultimately returned from a <code>.map()</code>.  And you know what??  That code will run <em>just fine</em>, in <em>any</em> environment where you choose to run it.  But if your array could hold <em>any</em> type of data (e.g., objects that contain nested arrays, that contain more objects, that contain functions), and if that data could conceivably be of nearly <em>any</em> size, then you need to think much more carefully about the deeply-nested logic you're using to transform it.<br>
<br><br></p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Q_FJP0VD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pcbph8z928jxuhbot0rk.jpeg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Q_FJP0VD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pcbph8z928jxuhbot0rk.jpeg" alt="Image description" loading="lazy" width="880" height="495"></a></p>
<h2>
  <a name="bigo-notation" href="#bigo-notation">
  </a>
  Big-O Notation
</h2>

<p>One particular sore point (for me) about performance is with Big-O Notation.  If you earned a computer science degree, you probably had to become <em>very</em> familiar with Big-O.  If you're self-taught (like me), you probably find it to be... onerous.  Because it's abstract and it typically provides <em>no</em> value in your day-to-day coding tasks.  But if you're trying to get through coding interviews with Big Tech companies, it'll probably come up at some point.  So what do you do?</p>

<p>Well, if you're intent upon impressing those interviewers who are obsessed with Big-O Notation, then you may have little choice but to hunker down and force yourself to learn it.  But there are some shortcuts you can take to simply make yourself familiar with <em>the concepts</em>.</p>

<p>First, understand the dead-simple basics:</p>

<ol>
<li><p><code>O(1)</code> is the most immediate time complexity you can have.  If you simply set a variable, and then at some later point, you access the value in that same variable, this is <code>O(1)</code>.  It basically means that you have <em>immediate</em> access to the value stored in memory.</p></li>
<li><p><code>O(n)</code> is a loop.  <code>n</code> represents the number of times you need to traverse the loop.  So if you're just creating a single loop, you are writing something of <code>O(n)</code> complexity.  Also, if you have a loop nested <em>inside</em> another loop, and both loops are dependent upon <em>the same</em> variable, your algorithm will typically be <code>O(n-squared)</code>.  </p></li>
<li><p>Most of the "built-in" sorting mechanisms we use are of <code>O(n log(n))</code> complexity.  There are <em>many</em> different ways to do sorts.  But typically, when you're using a language's "native" sort functions, you're employing <code>O(n log(n))</code> complexity.</p></li>
</ol>

<p>You can go deeeeeep down a rabbit hole trying to master all of the "edge cases" in Big-O Notation.  But if you understand these dead-simple concepts, you're already on your way to at least being able to hold your own in a Big-O conversation.</p>

<p>Second, you don't necessarily need to "know" Big-O Notation in order to understand the concepts.  That's because Big-O is basically a shorthand way of explaining "how many hoops will my code need to jump through before it can finish its calculation."</p>

<p>For example:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">myBigHairyArray</span> <span class="o">=</span> <span class="p">[...</span> <span class="nx">thousandsUponThousandsOfValues</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">myBigHairyArray</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=></span> <span class="p">{</span>
  <span class="c1">// tranformation logic here</span>
<span class="p">});</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>This kinda logic is rarely problematic.  Because even if <code>myBigHairyArray</code> is incredibly large, you're only looping through the values <em>once</em>.  And modern browsers can loop through an array - even a <em>large</em> array - <em>very fast</em>.</p>

<p>But you should immediately start thinking about your approach if you're tempted to write something like this:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">myBigHairyArray</span> <span class="o">=</span> <span class="p">[...</span> <span class="nx">thousandsUponThousandsOfValues</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">myBigHairyArray</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">outerItem</span> <span class="o">=></span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">myBigHairyArray</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">innerItem</span> <span class="o">=></span> <span class="p">{</span>
    <span class="c1">// do inner tranformation logic </span>
    <span class="c1">// comparing outerItem to innerItem</span>
  <span class="p">});</span>
<span class="p">});</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>This is a nested loop.  And to be clear, <em>sometimes</em> nested loops are absolutely necessary, but your time complexity grows <em>exponentially</em> when you choose this approach.  In the example above, if <code>myBigHairArray</code> contains "only" 1,000 values, the logic will need to iterate through them <em>one million times</em> (1,000 x 1,000).</p>

<p>Generally speaking, even if you haven't the faintest clue about even the simplest aspects of Big-O Notation, you should always strive to avoid nesting <em>anything</em>.  Sure, sometimes it can't be avoided.  But you should always be thinking very carefully about whether there's <em>any</em> way to avoid it.</p>

<p><strong>Hidden Loops</strong></p>

<p>You should also be aware of the "gotchas" that can arise when using native functions.  Yes, native functions are generally a "good" thing.  But when you use a native function, it can be easy to forget that many of those functions are doing their magic <em>with loops</em> under the covers.  </p>

<p>For example: imagine in the examples above that you are then utilizing <code>.reduce()</code>.  There's nothing inherently "wrong" with using <code>.reduce()</code>.  But <code>.reduce()</code> is also <em>a loop</em>.  So if your code only <em>appears</em> to use one top-level loop, but you have a <code>.reduce()</code> happening inside every iteration of that loop, you are, in fact, writing logic with a <em>nested</em> loop.<br>
<br><br></p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s---cRlKBT0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gwvef6wr542v1t1spit1.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s---cRlKBT0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gwvef6wr542v1t1spit1.jpg" alt="Image description" loading="lazy" width="880" height="380"></a></p>

<h2>
  <a name="readability-maintainability" href="#readability-maintainability">
  </a>
  Readability / Maintainability
</h2>

<p>The problem with performance discussions is that they often focus on <em>micro-optimization</em> at the expense of readability / maintainability.  And I'm a firm believer that maintainability <em>almost</em> always trumps performance.</p>

<p>I was working for a large health insurance provider in town and I wrote a function that had to do some complex transformations of large data sets.  When I finished the first pass of the code, <em>it worked</em>.  But it was rather... obtuse.  So before committing the code, I refactored it so that, during the interim steps, I was saving the data set into different temp variables.  The purpose of this approach was to illustrate, to anyone <em>reading</em> the code, what had happened to the data at that point.  In other words, I was writing <em>self-documenting code</em>.  By assigning self-explanatory names to each of the temp variables, I was making it painfully clear to all future coders exactly what was happening after each step.</p>

<p>When I submitted the pull request, the dev manager (who, BTW, was a complete idiot) told me to yank out all the temp variables.  His "logic" was that those temp variables each represented an unnecessary allocation of memory.  And you know what?? He wasn't "wrong".  But his approach was ignorant.  Because the temp variables were going to make absolutely no discernible difference to the user, but they were going to make future maintenance on that code <em>sooooo</em> much easier.  You may have already guessed that I didn't stick around that gig for too long.</p>

<p>If your micro-optimization actually makes the code more difficult for other coders to understand, it's almost always a poor choice.<br>
<br><br></p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--eN1JAmIO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/brwda3zc9g0ant0k5bhv.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--eN1JAmIO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/brwda3zc9g0ant0k5bhv.jpg" alt="Image description" loading="lazy" width="880" height="495"></a></p>

<h2>
  <a name="what-to-do" href="#what-to-do">
  </a>
  What To Do?
</h2>

<p>I can confidently tell you that performance <em>is</em> something that you should be thinking about.  Almost constantly.  <em>Even</em> on frontend apps.  But you also need to be realistic about the fact that your code is almost always running in an environment where there are <em>tons</em> of unused resources.  You should also remember that the most "efficient" algorithm isn't always the "best" algorithm, especially if it looks like gobbledygook to all future coders.</p>

<p><em>Thinking</em> about code performance is a valuable exercise.  One that any serious programmer should probably have, almost always, in the back of their mind.  It's incredibly healthy to continually challenge yourself (and others) about the relative performance of code.  In doing so, you can vastly improve your own skills.  But performance alone should never be the end-all/be-all of your work.  And this is <em>especially</em> true if you're a "frontend developer".  </p>

</div></article> <div class="aside-username-wrapper" data-v-10d06ee8><aside class="aside-username-block" data-v-37984f8c data-v-10d06ee8><div class="username-heading loading" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-heading" data-v-37984f8c><div class="vue-content-placeholders-heading__img"></div> <div class="vue-content-placeholders-heading__content"><div class="vue-content-placeholders-heading__title"></div> <div class="vue-content-placeholders-heading__subtitle"></div></div></div></div></div> <div class="info" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-text" data-v-37984f8c><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div></div></div></div></aside></div></div> <div class="comments-block" data-v-8c4375bc data-v-10d06ee8><!----> <a href="https://dev.to/bytebodger/should-frontend-devs-care-about-performance-3eg1" target="_blank" rel="nofollow noopener noreferer" class="add-comment" data-v-8c4375bc>
    Add comment
  </a></div></div> <footer data-v-22cb8fd0><span data-v-22cb8fd0>Built with</span> <a href="https://nuxtjs.org" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="nuxt-icon" data-v-22cb8fd0 data-v-22cb8fd0><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a> <span data-v-22cb8fd0>&</span> <a href="https://docs.dev.to/api" rel="nofollow noopener" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-22cb8fd0 data-v-22cb8fd0><path d="M1.5726 5.13748C1.42945 5.20622 1.2411 5.36661 1.15822 5.48117C1 5.69503 1 5.74849 1 11.8739C1 17.9993 1 18.0528 1.15822 18.2667C1.2411 18.3812 1.42945 18.5416 1.5726 18.6104C1.8137 18.7402 2.46164 18.7478 12 18.7478C21.5384 18.7478 22.1863 18.7402 22.4274 18.6104C22.5706 18.5416 22.7589 18.3812 22.8418 18.2667C23 18.0528 23 17.9993 23 11.8739C23 5.74849 23 5.69503 22.8418 5.48117C22.7589 5.36661 22.5706 5.20622 22.4274 5.13748C22.1863 5.00764 21.5384 5 12 5C2.46164 5 1.8137 5.00764 1.5726 5.13748ZM7.7055 8.2613C8.0822 8.45989 8.59454 9.0098 8.77536 9.40694C8.89589 9.66664 8.91095 9.94922 8.91095 12.0649C8.91095 14.3104 8.90344 14.4478 8.75275 14.7839C8.51919 15.288 8.16506 15.6546 7.68288 15.899C7.26096 16.1052 7.22328 16.1128 5.7315 16.1358L4.20206 16.1663V12.1031V8.04744L5.80684 8.07035C7.27602 8.09327 7.42672 8.10854 7.7055 8.2613ZM13.6952 8.89521V9.73538H12.4521H11.2089V10.4991V11.2629H11.9623H12.7158V12.1031V12.9432H11.9623H11.2089V13.707V14.4708H12.4521H13.6952V15.3109V16.151H12C10.1315 16.151 10.0411 16.1358 9.67191 15.6928L9.47603 15.4484V12.1336C9.47603 8.46752 9.46851 8.49807 9.95069 8.20783C10.1692 8.07035 10.3425 8.05508 11.9473 8.05508H13.6952V8.89521ZM16.5658 10.3769C16.8897 11.6295 17.1685 12.6912 17.176 12.7293C17.1911 12.7675 17.4699 11.7441 17.8014 10.461C18.1254 9.17017 18.4343 8.1009 18.4795 8.08563C18.5247 8.06271 18.9541 8.06271 19.4288 8.07035L20.3028 8.09327L19.376 11.6219C18.8713 13.5542 18.4117 15.2269 18.3664 15.3261C18.0123 16.0135 17.274 16.3343 16.7164 16.0441C16.4528 15.899 16.0911 15.4865 15.9705 15.1887C15.9254 15.0665 15.4884 13.4549 15.0062 11.6142C14.524 9.76593 14.1171 8.20783 14.0945 8.15437C14.0644 8.07035 14.2301 8.05508 15.0212 8.07035L15.9856 8.09327L16.5658 10.3769Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M5.93491 12.103V14.4707H6.27394C6.66574 14.4707 7.01983 14.3103 7.1404 14.0965C7.18559 14.0048 7.21575 13.2105 7.21575 12.0648V10.1783L6.99725 9.95683C6.80133 9.76591 6.71847 9.73535 6.35683 9.73535H5.93491V12.103Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a></footer></div></div></div><script>window.__NUXT__=function(e,t,a,o,n){return t.type_of="article",t.id=1001820,t.title="Should Frontend Devs Care About Performance??",t.description="I was recently talking to an architect at Amazon and he made a very interesting comment to me.  We...",t.readable_publish_date="Feb 27",t.slug="should-frontend-devs-care-about-performance-3eg1",t.path="/bytebodger/should-frontend-devs-care-about-performance-3eg1",t.url=a,t.comments_count=50,t.public_reactions_count=364,t.collection_id=7422,t.published_timestamp=o,t.positive_reactions_count=364,t.cover_image="https://res.cloudinary.com/practicaldev/image/fetch/s--1QULGcme--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xxo5nbnplde50lj1nehb.png",t.social_image="https://res.cloudinary.com/practicaldev/image/fetch/s--xDTBqTK4--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xxo5nbnplde50lj1nehb.png",t.canonical_url=a,t.created_at="2022-02-25T22:37:30Z",t.edited_at="2022-03-04T20:26:50Z",t.crossposted_at=e,t.published_at=o,t.last_comment_at="2022-04-02T23:14:46Z",t.reading_time_minutes=12,t.tag_list="javascript, performance, webdev, developer",t.tags=["javascript","performance","webdev","developer"],t.body_html='<p>I was recently talking to an architect at Amazon and he made a <em>very</em> interesting comment to me.  We were talking about the complexity of a given algorithm (discussed in Big-O notation), and before we even got too far into the explanation, he said:<br>\n<br></p>\n\n<blockquote>\n<p>I mean, it\'s not like we need to worry <em>too</em> much about this.  After all, we\'re frontend devs!</p>\n</blockquote>\n\n<p><br>I found this admission to be extremely refreshing, and it was entirely unexpected coming from someone in the Ivory Tower that is Amazon.  It\'s something that I\'ve always known.  But it was still really nice to hear it coming from someone working for the likes of a FAANG company.</p>\n\n<p>You see, <em>performance</em> is one of those subjects that programmers love to obsess about.  They use it as a Badge of Honor.  They see that you\'ve used JavaScript\'s native <code>.sort()</code> method, then they turn up their nose and say something like, "Well, <em>you know</em>... That uses <code>O(n log(n))</code> complexity."  Then they walk away with a smug smirk on their face, as though they\'ve banished your code to the dustbin of Failed Algorithms.<br>\n<br><br></p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--j36tnL_U--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/rv40jhqgjk5z7gpdd3eo.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--j36tnL_U--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/rv40jhqgjk5z7gpdd3eo.png" alt="Image description" loading="lazy" width="880" height="495"></a></p>\n<h2>\n  <a name="smart-clients-vs-dumb-terminals" href="#smart-clients-vs-dumb-terminals">\n  </a>\n  Smart Clients vs. Dumb Terminals\n</h2>\n\n<p>The terms "smart client" and "dumb terminal" have fallen somewhat by-the-wayside in recent decades.  But they\'re still valid definitions, even in our modern computing environments.  </p>\n\n<p><strong>Mainframe Computing</strong></p>\n\n<p>Way back in the Dark Ages, nearly all computing was done on massive computers (e.g., <em>mainframes</em>).  And you interacted with those computers by using a "terminal".  Those terminals were often called "dumb terminals" because the terminal itself had almost no computing power of its own.  It only served as a way for you to send commands to the mainframe and then view whatever results were returned from... the mainframe.  That\'s why it was called "dumb".  Because the terminal itself couldn\'t really <em>do</em> much of anything on its own.  It only served as a portal that gave you access to the mainframe.</p>\n\n<p>For those who wrote mainframe code, they had to worry greatly about the <em>efficiency</em> of their algorithms.  Because even the mainframe had comparatively-little computing power (by today\'s standards).  More importantly, the mainframe\'s resources were <em>shared</em> by anyone with access to one of the dumb terminals.  So if 100 people, sitting at 100 dumb terminals, all sent resource-intensive commands at the same time, it was pretty easy to crash the mainframe.  (This is also why the allocation of terminals was very strict, and even those who had access to mainframe terminals often had to reserve time on them.)</p>\n\n<p><strong>PC Computing</strong></p>\n\n<p>With the PC explosion in the 80s, suddenly you had a lot of people with a lot of computing power (relatively speaking) sitting on their desktop.  And most of the time, that computing power was underutilized.  Thus spawned the age of "smart clients".</p>\n\n<p>In a smart client model, every effort is made to allow the client to do its own computing.  It only communicates back to the server when existing data must be retrieved from the source, or when new/updated data must be sent back to that source.  This offloaded a great deal of work <em>off</em> of the mainframe, down to the clients, and allowed for the creation of much more robust applications.</p>\n\n<p><strong>A Return To Mainframe Computing (Sorta...)</strong></p>\n\n<p>But when the web came around, it knocked many applications back into a server/terminal kinda relationship.  That\'s because those apps <em>appeared</em> to be running in the browser, but the simple fact is that early browser technology was incapable of really <em>doing</em> much on its own.  Early browsers were quite analogous to dumb terminals.  They could see data that was sent from the server (in the form of HTML/CSS).  But if they wanted to <em>interact</em> with that data in any meaningful way, they needed to constantly send their commands <em>back</em> to the server.</p>\n\n<p>This also meant that early web developers needed to be hyper-vigilant about efficiency.  Because even a seemingly-innocuous snippet of code could drag your server to its knees if your site suddenly went viral and that code was being run by hundreds (or thousands) of web surfers concurrently.</p>\n\n<p>This could be somewhat alleviated by deploying more robust backend technologies.  For example, you could deploy a web <em>farm</em> that shared the load of requests for a single site.  Or you could write your code in a compiled language (like Java or C#), which helped (somewhat) because compiled code typically runs faster than interpreted code.  But you were still bound by the limits that came from having <em>all</em> of your public users hitting a finite set of server/computing resources.<br>\n<br><br></p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Tzvwx6pK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vc6etpjun7dwy0ktvnz2.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Tzvwx6pK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vc6etpjun7dwy0ktvnz2.jpg" alt="Image description" loading="lazy" width="880" height="513"></a></p>\n<h2>\n  <a name="the-browser-as-smart-client" href="#the-browser-as-smart-client">\n  </a>\n  The Browser AS Smart Client\n</h2>\n\n<p>I\'m not going to delve into the many arguments for-or-against Chrome.  But one of its greatest contributions to web development is that it was one of the first browsers that was continually optimized specifically for JavaScript performance.  When this optimization was combined with powerful new frameworks like jQuery (then Angular, then React, then...), it fostered the rise of the <em>frontend developer</em>.  </p>\n\n<p>This didn\'t just give us new capabilities for frontend functionality, it also meant that we could start thinking, again, in terms of the desktop (browser) being a <em>smart</em> client.  In other words, we didn\'t necessarily have to stay up at night wondering if that one aberrant line of code was going to crash <em>the server</em>.  At worst, it might crash <em>someone\'s browser</em>.  (And don\'t get me wrong, writing code that crashes browsers is still a very <em>bad</em> thing to do.  But it\'s farrrrr less likely to occur when the desktop/browser typically has all those unused CPU cycles just waiting to be harnessed.)</p>\n\n<p>So when you\'re writing, say, The Next Great React App, how much, exactly, do you even need to <em>care</em> about performance??  After all, the bulk of your app will be running in someone\'s browser.  And even if that browser is running <em>on a mobile device</em>, it probably has loads of unleveraged processing power available for you to use.  So how much do you need to be concerned about the nitty-gritty details of your code\'s performance?  IMHO, the answer is simple - yet nuanced. </p>\n\n<p><strong>Care... But Not <em>That</em> Much</strong></p>\n\n<p>Years ago, I was listening to a keynote address from the CEO of a public company.  Public companies must always (understandably) have one eye trained on the stock market.  During his talk, he posed the question: <em>How much do I care about our company\'s stock price?</em>  And his answer was that he cared... but not that much.  In other words, he was always <em>aware</em> of the stock price.  And of course, he was cognizant of the things his company could do (or avoid doing) that would potentially influence their stock price.  But he was adamant that he could not make every internal corporate decision based upon one simple factor - whether or not it would juice the stock price.  He had to <em>care</em> about the stock price, because a tanking stock price can cause all sorts of problems for a public company.  But if he allowed himself to focus, with tunnel vision, on that stock price, he could end up making decisions that bump the price by a few pennies - but end up hurting the company in the long run.</p>\n\n<p>Frontend app development is very similar in my eyes.  You should always be <em>aware</em> of your code\'s performance.  You certainly don\'t want to write code that will cause your app to run noticeably <em>bad</em>.  But you also don\'t want to spend half of every sprint trying to micro-optimize every minute detail of your code.</p>\n\n<p>If this all sounds terribly abstract, I\'ll try to give you some guidance on <em>when</em> you need to care about application performance - and when you shouldn\'t allow it to bog down your development.<br>\n<br><br></p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--9gGhEpKX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/e6hv8m1s1uvr199yaey5.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--9gGhEpKX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/e6hv8m1s1uvr199yaey5.png" alt="Image description" loading="lazy" width="880" height="394"></a></p>\n<h2>\n  <a name="developer-trials" href="#developer-trials">\n  </a>\n  Developer Trials\n</h2>\n\n<p>The first thing you need to keep in mind is that your code will (hopefully) be reviewed by others devs.  This happens when you submit new code, or even when someone comes by months later and looks at what you\'ve written.  And many devs <em>LOVE</em> to nitpick your code for performance.</p>\n\n<p>You can\'t avoid these "trials".  They happen all the time.  The key is not to get sucked into theoretical debates about the benchmark performance of a <code>for</code> loop versus the <code>Array.prototype</code> function of <code>.forEach()</code>.  Instead, you should try, whenever possible, to steer the conversation back into the realm of reality.</p>\n\n<p><strong>Benchmarking Based Upon Reality</strong></p>\n\n<p>What do I mean by "reality"?  Well, first of all, we now have many tools that allow us to benchmark our apps <em>in the browser</em>.  So if someone can point out that I can shave a few seconds of load time off my app by making one-or-two minor changes, I\'m all ears.  But if their proposed optimization only "saves" me a few <em>microseconds</em>, I\'m probably gonna ignore their suggestions.</p>\n\n<p>You should also be cognizant of the fact that a language\'s <em>built-in</em> functions will almost always outperform any custom code.  So if someone claims that they have a bit of custom code that is more performant than, say, <code>Array.prototype.find()</code>, I\'m immediately skeptical.  But if they can show me how I can achieve the desired result without even <em>using</em> <code>Array.prototype.find()</code> at all, I\'m happy to hear the suggestion.  However, if they simply believe that <em>their</em> method of doing a <code>.find()</code> is more performant than using the <code>Array.prototype.find()</code>, then I\'m going to be incredibly skeptical.</p>\n\n<p><strong>Your Code\'s Runtime Environment</strong></p>\n\n<p>"Reality" is also driven by one simple question: <em>Where does the code RUN???</em>  If the code-in-question runs in, say, Node (meaning that it runs <em>on the server</em>), performance tweaks take on a heightened sense of urgency, because that code is <em>shared</em> and is being hit by everyone who uses the app.  But if the code runs <em>in the browser</em>, you\'re not a crappy dev just because the tweak is not forefront in your mind.</p>\n\n<p>Sometimes, the code we\'re examining isn\'t even running in an app at all.  This happens whenever we decide to do purely academic exercises that are meant to gauge our overall awareness of performance metrics.  Code like this may be running in a JSPerf panel, or in a demo app written on StackBlitz.  In those scenarios, people are much more likely to be focused on finite details of performance, simply because <em>that\'s the whole point of the exercise</em>.  As you might imagine, these types of discussions tend to crop up most frequently during... job interviews.  So it\'s dangerous to be downright flippant about performance when the audience really cares about almost nothing <em>but</em> the performance.</p>\n\n<p><strong>The "Weight" Of Data Types</strong></p>\n\n<p>"Reality" should also encompass a thorough understanding of what <em>types</em> of data that you\'re manipulating.  For example, if you need to do a wholesale transformation on an array, it\'s perfectly acceptable to ask yourself: <em>How BIG can this array reasonably become?</em>  Or... <em>What TYPES of data can the array typically hold?</em></p>\n\n<p>If you have an array that only holds integers, and we know that the array will <em>never</em> hold more than, say, a dozen values, then I really don\'t care much about the exact method(s) you\'ve chosen to transform that data.  You can use <code>.reduce()</code> nested inside a <code>.find()</code>, nested inside a <code>.sort()</code>, which is ultimately returned from a <code>.map()</code>.  And you know what??  That code will run <em>just fine</em>, in <em>any</em> environment where you choose to run it.  But if your array could hold <em>any</em> type of data (e.g., objects that contain nested arrays, that contain more objects, that contain functions), and if that data could conceivably be of nearly <em>any</em> size, then you need to think much more carefully about the deeply-nested logic you\'re using to transform it.<br>\n<br><br></p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Q_FJP0VD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pcbph8z928jxuhbot0rk.jpeg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Q_FJP0VD--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pcbph8z928jxuhbot0rk.jpeg" alt="Image description" loading="lazy" width="880" height="495"></a></p>\n<h2>\n  <a name="bigo-notation" href="#bigo-notation">\n  </a>\n  Big-O Notation\n</h2>\n\n<p>One particular sore point (for me) about performance is with Big-O Notation.  If you earned a computer science degree, you probably had to become <em>very</em> familiar with Big-O.  If you\'re self-taught (like me), you probably find it to be... onerous.  Because it\'s abstract and it typically provides <em>no</em> value in your day-to-day coding tasks.  But if you\'re trying to get through coding interviews with Big Tech companies, it\'ll probably come up at some point.  So what do you do?</p>\n\n<p>Well, if you\'re intent upon impressing those interviewers who are obsessed with Big-O Notation, then you may have little choice but to hunker down and force yourself to learn it.  But there are some shortcuts you can take to simply make yourself familiar with <em>the concepts</em>.</p>\n\n<p>First, understand the dead-simple basics:</p>\n\n<ol>\n<li><p><code>O(1)</code> is the most immediate time complexity you can have.  If you simply set a variable, and then at some later point, you access the value in that same variable, this is <code>O(1)</code>.  It basically means that you have <em>immediate</em> access to the value stored in memory.</p></li>\n<li><p><code>O(n)</code> is a loop.  <code>n</code> represents the number of times you need to traverse the loop.  So if you\'re just creating a single loop, you are writing something of <code>O(n)</code> complexity.  Also, if you have a loop nested <em>inside</em> another loop, and both loops are dependent upon <em>the same</em> variable, your algorithm will typically be <code>O(n-squared)</code>.  </p></li>\n<li><p>Most of the "built-in" sorting mechanisms we use are of <code>O(n log(n))</code> complexity.  There are <em>many</em> different ways to do sorts.  But typically, when you\'re using a language\'s "native" sort functions, you\'re employing <code>O(n log(n))</code> complexity.</p></li>\n</ol>\n\n<p>You can go deeeeeep down a rabbit hole trying to master all of the "edge cases" in Big-O Notation.  But if you understand these dead-simple concepts, you\'re already on your way to at least being able to hold your own in a Big-O conversation.</p>\n\n<p>Second, you don\'t necessarily need to "know" Big-O Notation in order to understand the concepts.  That\'s because Big-O is basically a shorthand way of explaining "how many hoops will my code need to jump through before it can finish its calculation."</p>\n\n<p>For example:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">myBigHairyArray</span> <span class="o">=</span> <span class="p">[...</span> <span class="nx">thousandsUponThousandsOfValues</span><span class="p">];</span>\n<span class="kd">const</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">myBigHairyArray</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="p">{</span>\n  <span class="c1">// tranformation logic here</span>\n<span class="p">});</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>This kinda logic is rarely problematic.  Because even if <code>myBigHairyArray</code> is incredibly large, you\'re only looping through the values <em>once</em>.  And modern browsers can loop through an array - even a <em>large</em> array - <em>very fast</em>.</p>\n\n<p>But you should immediately start thinking about your approach if you\'re tempted to write something like this:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight javascript"><code><span class="kd">const</span> <span class="nx">myBigHairyArray</span> <span class="o">=</span> <span class="p">[...</span> <span class="nx">thousandsUponThousandsOfValues</span><span class="p">];</span>\n<span class="kd">const</span> <span class="nx">newArray</span> <span class="o">=</span> <span class="nx">myBigHairyArray</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">outerItem</span> <span class="o">=&gt;</span> <span class="p">{</span>\n  <span class="k">return</span> <span class="nx">myBigHairyArray</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">innerItem</span> <span class="o">=&gt;</span> <span class="p">{</span>\n    <span class="c1">// do inner tranformation logic </span>\n    <span class="c1">// comparing outerItem to innerItem</span>\n  <span class="p">});</span>\n<span class="p">});</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>This is a nested loop.  And to be clear, <em>sometimes</em> nested loops are absolutely necessary, but your time complexity grows <em>exponentially</em> when you choose this approach.  In the example above, if <code>myBigHairArray</code> contains "only" 1,000 values, the logic will need to iterate through them <em>one million times</em> (1,000 x 1,000).</p>\n\n<p>Generally speaking, even if you haven\'t the faintest clue about even the simplest aspects of Big-O Notation, you should always strive to avoid nesting <em>anything</em>.  Sure, sometimes it can\'t be avoided.  But you should always be thinking very carefully about whether there\'s <em>any</em> way to avoid it.</p>\n\n<p><strong>Hidden Loops</strong></p>\n\n<p>You should also be aware of the "gotchas" that can arise when using native functions.  Yes, native functions are generally a "good" thing.  But when you use a native function, it can be easy to forget that many of those functions are doing their magic <em>with loops</em> under the covers.  </p>\n\n<p>For example: imagine in the examples above that you are then utilizing <code>.reduce()</code>.  There\'s nothing inherently "wrong" with using <code>.reduce()</code>.  But <code>.reduce()</code> is also <em>a loop</em>.  So if your code only <em>appears</em> to use one top-level loop, but you have a <code>.reduce()</code> happening inside every iteration of that loop, you are, in fact, writing logic with a <em>nested</em> loop.<br>\n<br><br></p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s---cRlKBT0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gwvef6wr542v1t1spit1.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s---cRlKBT0--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gwvef6wr542v1t1spit1.jpg" alt="Image description" loading="lazy" width="880" height="380"></a></p>\n\n<h2>\n  <a name="readability-maintainability" href="#readability-maintainability">\n  </a>\n  Readability / Maintainability\n</h2>\n\n<p>The problem with performance discussions is that they often focus on <em>micro-optimization</em> at the expense of readability / maintainability.  And I\'m a firm believer that maintainability <em>almost</em> always trumps performance.</p>\n\n<p>I was working for a large health insurance provider in town and I wrote a function that had to do some complex transformations of large data sets.  When I finished the first pass of the code, <em>it worked</em>.  But it was rather... obtuse.  So before committing the code, I refactored it so that, during the interim steps, I was saving the data set into different temp variables.  The purpose of this approach was to illustrate, to anyone <em>reading</em> the code, what had happened to the data at that point.  In other words, I was writing <em>self-documenting code</em>.  By assigning self-explanatory names to each of the temp variables, I was making it painfully clear to all future coders exactly what was happening after each step.</p>\n\n<p>When I submitted the pull request, the dev manager (who, BTW, was a complete idiot) told me to yank out all the temp variables.  His "logic" was that those temp variables each represented an unnecessary allocation of memory.  And you know what?? He wasn\'t "wrong".  But his approach was ignorant.  Because the temp variables were going to make absolutely no discernible difference to the user, but they were going to make future maintenance on that code <em>sooooo</em> much easier.  You may have already guessed that I didn\'t stick around that gig for too long.</p>\n\n<p>If your micro-optimization actually makes the code more difficult for other coders to understand, it\'s almost always a poor choice.<br>\n<br><br></p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--eN1JAmIO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/brwda3zc9g0ant0k5bhv.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--eN1JAmIO--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/brwda3zc9g0ant0k5bhv.jpg" alt="Image description" loading="lazy" width="880" height="495"></a></p>\n\n<h2>\n  <a name="what-to-do" href="#what-to-do">\n  </a>\n  What To Do?\n</h2>\n\n<p>I can confidently tell you that performance <em>is</em> something that you should be thinking about.  Almost constantly.  <em>Even</em> on frontend apps.  But you also need to be realistic about the fact that your code is almost always running in an environment where there are <em>tons</em> of unused resources.  You should also remember that the most "efficient" algorithm isn\'t always the "best" algorithm, especially if it looks like gobbledygook to all future coders.</p>\n\n<p><em>Thinking</em> about code performance is a valuable exercise.  One that any serious programmer should probably have, almost always, in the back of their mind.  It\'s incredibly healthy to continually challenge yourself (and others) about the relative performance of code.  In doing so, you can vastly improve your own skills.  But performance alone should never be the end-all/be-all of your work.  And this is <em>especially</em> true if you\'re a "frontend developer".  </p>\n\n',t.body_markdown="\nI was recently talking to an architect at Amazon and he made a _very_ interesting comment to me.  We were talking about the complexity of a given algorithm (discussed in Big-O notation), and before we even got too far into the explanation, he said:\n<br/>\n\n> I mean, it's not like we need to worry _too_ much about this.  After all, we're frontend devs!\n\n<br/>I found this admission to be extremely refreshing, and it was entirely unexpected coming from someone in the Ivory Tower that is Amazon.  It's something that I've always known.  But it was still really nice to hear it coming from someone working for the likes of a FAANG company.\n\nYou see, _performance_ is one of those subjects that programmers love to obsess about.  They use it as a Badge of Honor.  They see that you've used JavaScript's native `.sort()` method, then they turn up their nose and say something like, \"Well, _you know_... That uses `O(n log(n))` complexity.\"  Then they walk away with a smug smirk on their face, as though they've banished your code to the dustbin of Failed Algorithms.\n<br/><br/>\n\n\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/rv40jhqgjk5z7gpdd3eo.png)\n## Smart Clients vs. Dumb Terminals\nThe terms \"smart client\" and \"dumb terminal\" have fallen somewhat by-the-wayside in recent decades.  But they're still valid definitions, even in our modern computing environments.  \n\n**Mainframe Computing**\n\nWay back in the Dark Ages, nearly all computing was done on massive computers (e.g., _mainframes_).  And you interacted with those computers by using a \"terminal\".  Those terminals were often called \"dumb terminals\" because the terminal itself had almost no computing power of its own.  It only served as a way for you to send commands to the mainframe and then view whatever results were returned from... the mainframe.  That's why it was called \"dumb\".  Because the terminal itself couldn't really _do_ much of anything on its own.  It only served as a portal that gave you access to the mainframe.\n\nFor those who wrote mainframe code, they had to worry greatly about the _efficiency_ of their algorithms.  Because even the mainframe had comparatively-little computing power (by today's standards).  More importantly, the mainframe's resources were _shared_ by anyone with access to one of the dumb terminals.  So if 100 people, sitting at 100 dumb terminals, all sent resource-intensive commands at the same time, it was pretty easy to crash the mainframe.  (This is also why the allocation of terminals was very strict, and even those who had access to mainframe terminals often had to reserve time on them.)\n\n**PC Computing**\n\nWith the PC explosion in the 80s, suddenly you had a lot of people with a lot of computing power (relatively speaking) sitting on their desktop.  And most of the time, that computing power was underutilized.  Thus spawned the age of \"smart clients\".\n\nIn a smart client model, every effort is made to allow the client to do its own computing.  It only communicates back to the server when existing data must be retrieved from the source, or when new/updated data must be sent back to that source.  This offloaded a great deal of work _off_ of the mainframe, down to the clients, and allowed for the creation of much more robust applications.\n\n**A Return To Mainframe Computing (Sorta...)**\n\nBut when the web came around, it knocked many applications back into a server/terminal kinda relationship.  That's because those apps _appeared_ to be running in the browser, but the simple fact is that early browser technology was incapable of really _doing_ much on its own.  Early browsers were quite analogous to dumb terminals.  They could see data that was sent from the server (in the form of HTML/CSS).  But if they wanted to _interact_ with that data in any meaningful way, they needed to constantly send their commands _back_ to the server.\n\nThis also meant that early web developers needed to be hyper-vigilant about efficiency.  Because even a seemingly-innocuous snippet of code could drag your server to its knees if your site suddenly went viral and that code was being run by hundreds (or thousands) of web surfers concurrently.\n\nThis could be somewhat alleviated by deploying more robust backend technologies.  For example, you could deploy a web _farm_ that shared the load of requests for a single site.  Or you could write your code in a compiled language (like Java or C#), which helped (somewhat) because compiled code typically runs faster than interpreted code.  But you were still bound by the limits that came from having _all_ of your public users hitting a finite set of server/computing resources.\n<br/><br/>\n\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vc6etpjun7dwy0ktvnz2.jpg)\n## The Browser AS Smart Client\nI'm not going to delve into the many arguments for-or-against Chrome.  But one of its greatest contributions to web development is that it was one of the first browsers that was continually optimized specifically for JavaScript performance.  When this optimization was combined with powerful new frameworks like jQuery (then Angular, then React, then...), it fostered the rise of the _frontend developer_.  \n\nThis didn't just give us new capabilities for frontend functionality, it also meant that we could start thinking, again, in terms of the desktop (browser) being a _smart_ client.  In other words, we didn't necessarily have to stay up at night wondering if that one aberrant line of code was going to crash _the server_.  At worst, it might crash _someone's browser_.  (And don't get me wrong, writing code that crashes browsers is still a very _bad_ thing to do.  But it's farrrrr less likely to occur when the desktop/browser typically has all those unused CPU cycles just waiting to be harnessed.)\n\nSo when you're writing, say, The Next Great React App, how much, exactly, do you even need to _care_ about performance??  After all, the bulk of your app will be running in someone's browser.  And even if that browser is running _on a mobile device_, it probably has loads of unleveraged processing power available for you to use.  So how much do you need to be concerned about the nitty-gritty details of your code's performance?  IMHO, the answer is simple - yet nuanced. \n\n**Care... But Not _That_ Much**\n\nYears ago, I was listening to a keynote address from the CEO of a public company.  Public companies must always (understandably) have one eye trained on the stock market.  During his talk, he posed the question: _How much do I care about our company's stock price?_  And his answer was that he cared... but not that much.  In other words, he was always _aware_ of the stock price.  And of course, he was cognizant of the things his company could do (or avoid doing) that would potentially influence their stock price.  But he was adamant that he could not make every internal corporate decision based upon one simple factor - whether or not it would juice the stock price.  He had to _care_ about the stock price, because a tanking stock price can cause all sorts of problems for a public company.  But if he allowed himself to focus, with tunnel vision, on that stock price, he could end up making decisions that bump the price by a few pennies - but end up hurting the company in the long run.\n\nFrontend app development is very similar in my eyes.  You should always be _aware_ of your code's performance.  You certainly don't want to write code that will cause your app to run noticeably _bad_.  But you also don't want to spend half of every sprint trying to micro-optimize every minute detail of your code.\n\nIf this all sounds terribly abstract, I'll try to give you some guidance on _when_ you need to care about application performance - and when you shouldn't allow it to bog down your development.\n<br/><br/>\n\n\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/e6hv8m1s1uvr199yaey5.png)\n## Developer Trials\nThe first thing you need to keep in mind is that your code will (hopefully) be reviewed by others devs.  This happens when you submit new code, or even when someone comes by months later and looks at what you've written.  And many devs _LOVE_ to nitpick your code for performance.\n\nYou can't avoid these \"trials\".  They happen all the time.  The key is not to get sucked into theoretical debates about the benchmark performance of a `for` loop versus the `Array.prototype` function of `.forEach()`.  Instead, you should try, whenever possible, to steer the conversation back into the realm of reality.\n\n**Benchmarking Based Upon Reality**\n\nWhat do I mean by \"reality\"?  Well, first of all, we now have many tools that allow us to benchmark our apps _in the browser_.  So if someone can point out that I can shave a few seconds of load time off my app by making one-or-two minor changes, I'm all ears.  But if their proposed optimization only \"saves\" me a few _microseconds_, I'm probably gonna ignore their suggestions.\n\nYou should also be cognizant of the fact that a language's _built-in_ functions will almost always outperform any custom code.  So if someone claims that they have a bit of custom code that is more performant than, say, `Array.prototype.find()`, I'm immediately skeptical.  But if they can show me how I can achieve the desired result without even _using_ `Array.prototype.find()` at all, I'm happy to hear the suggestion.  However, if they simply believe that _their_ method of doing a `.find()` is more performant than using the `Array.prototype.find()`, then I'm going to be incredibly skeptical.\n\n**Your Code's Runtime Environment**\n\n\"Reality\" is also driven by one simple question: _Where does the code RUN???_  If the code-in-question runs in, say, Node (meaning that it runs _on the server_), performance tweaks take on a heightened sense of urgency, because that code is _shared_ and is being hit by everyone who uses the app.  But if the code runs _in the browser_, you're not a crappy dev just because the tweak is not forefront in your mind.\n\nSometimes, the code we're examining isn't even running in an app at all.  This happens whenever we decide to do purely academic exercises that are meant to gauge our overall awareness of performance metrics.  Code like this may be running in a JSPerf panel, or in a demo app written on StackBlitz.  In those scenarios, people are much more likely to be focused on finite details of performance, simply because _that's the whole point of the exercise_.  As you might imagine, these types of discussions tend to crop up most frequently during... job interviews.  So it's dangerous to be downright flippant about performance when the audience really cares about almost nothing _but_ the performance.\n\n**The \"Weight\" Of Data Types**\n\n\"Reality\" should also encompass a thorough understanding of what _types_ of data that you're manipulating.  For example, if you need to do a wholesale transformation on an array, it's perfectly acceptable to ask yourself: _How BIG can this array reasonably become?_  Or... _What TYPES of data can the array typically hold?_\n\nIf you have an array that only holds integers, and we know that the array will _never_ hold more than, say, a dozen values, then I really don't care much about the exact method(s) you've chosen to transform that data.  You can use `.reduce()` nested inside a `.find()`, nested inside a `.sort()`, which is ultimately returned from a `.map()`.  And you know what??  That code will run _just fine_, in _any_ environment where you choose to run it.  But if your array could hold _any_ type of data (e.g., objects that contain nested arrays, that contain more objects, that contain functions), and if that data could conceivably be of nearly _any_ size, then you need to think much more carefully about the deeply-nested logic you're using to transform it.\n<br/><br/>\n\n\n\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pcbph8z928jxuhbot0rk.jpeg)\n## Big-O Notation\nOne particular sore point (for me) about performance is with Big-O Notation.  If you earned a computer science degree, you probably had to become _very_ familiar with Big-O.  If you're self-taught (like me), you probably find it to be... onerous.  Because it's abstract and it typically provides _no_ value in your day-to-day coding tasks.  But if you're trying to get through coding interviews with Big Tech companies, it'll probably come up at some point.  So what do you do?\n\nWell, if you're intent upon impressing those interviewers who are obsessed with Big-O Notation, then you may have little choice but to hunker down and force yourself to learn it.  But there are some shortcuts you can take to simply make yourself familiar with _the concepts_.\n\nFirst, understand the dead-simple basics:\n\n1. `O(1)` is the most immediate time complexity you can have.  If you simply set a variable, and then at some later point, you access the value in that same variable, this is `O(1)`.  It basically means that you have _immediate_ access to the value stored in memory.\n\n1. `O(n)` is a loop.  `n` represents the number of times you need to traverse the loop.  So if you're just creating a single loop, you are writing something of `O(n)` complexity.  Also, if you have a loop nested _inside_ another loop, and both loops are dependent upon _the same_ variable, your algorithm will typically be `O(n-squared)`.  \n\n1. Most of the \"built-in\" sorting mechanisms we use are of `O(n log(n))` complexity.  There are _many_ different ways to do sorts.  But typically, when you're using a language's \"native\" sort functions, you're employing `O(n log(n))` complexity.\n\nYou can go deeeeeep down a rabbit hole trying to master all of the \"edge cases\" in Big-O Notation.  But if you understand these dead-simple concepts, you're already on your way to at least being able to hold your own in a Big-O conversation.\n\nSecond, you don't necessarily need to \"know\" Big-O Notation in order to understand the concepts.  That's because Big-O is basically a shorthand way of explaining \"how many hoops will my code need to jump through before it can finish its calculation.\"\n\nFor example:\n\n```javascript\nconst myBigHairyArray = [... thousandsUponThousandsOfValues];\nconst newArray = myBigHairyArray.map(item => {\n  // tranformation logic here\n});\n```\n\nThis kinda logic is rarely problematic.  Because even if `myBigHairyArray` is incredibly large, you're only looping through the values _once_.  And modern browsers can loop through an array - even a _large_ array - _very fast_.\n\nBut you should immediately start thinking about your approach if you're tempted to write something like this:\n\n```javascript\nconst myBigHairyArray = [... thousandsUponThousandsOfValues];\nconst newArray = myBigHairyArray.map(outerItem => {\n  return myBigHairyArray.map(innerItem => {\n    // do inner tranformation logic \n    // comparing outerItem to innerItem\n  });\n});\n```\n\nThis is a nested loop.  And to be clear, _sometimes_ nested loops are absolutely necessary, but your time complexity grows _exponentially_ when you choose this approach.  In the example above, if `myBigHairArray` contains \"only\" 1,000 values, the logic will need to iterate through them _one million times_ (1,000 x 1,000).\n\nGenerally speaking, even if you haven't the faintest clue about even the simplest aspects of Big-O Notation, you should always strive to avoid nesting _anything_.  Sure, sometimes it can't be avoided.  But you should always be thinking very carefully about whether there's _any_ way to avoid it.\n\n**Hidden Loops**\n\nYou should also be aware of the \"gotchas\" that can arise when using native functions.  Yes, native functions are generally a \"good\" thing.  But when you use a native function, it can be easy to forget that many of those functions are doing their magic _with loops_ under the covers.  \n\nFor example: imagine in the examples above that you are then utilizing `.reduce()`.  There's nothing inherently \"wrong\" with using `.reduce()`.  But `.reduce()` is also _a loop_.  So if your code only _appears_ to use one top-level loop, but you have a `.reduce()` happening inside every iteration of that loop, you are, in fact, writing logic with a _nested_ loop.\n<br/><br/>\n\n\n\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gwvef6wr542v1t1spit1.jpg)\n## Readability / Maintainability\nThe problem with performance discussions is that they often focus on _micro-optimization_ at the expense of readability / maintainability.  And I'm a firm believer that maintainability _almost_ always trumps performance.\n\nI was working for a large health insurance provider in town and I wrote a function that had to do some complex transformations of large data sets.  When I finished the first pass of the code, _it worked_.  But it was rather... obtuse.  So before committing the code, I refactored it so that, during the interim steps, I was saving the data set into different temp variables.  The purpose of this approach was to illustrate, to anyone _reading_ the code, what had happened to the data at that point.  In other words, I was writing _self-documenting code_.  By assigning self-explanatory names to each of the temp variables, I was making it painfully clear to all future coders exactly what was happening after each step.\n\nWhen I submitted the pull request, the dev manager (who, BTW, was a complete idiot) told me to yank out all the temp variables.  His \"logic\" was that those temp variables each represented an unnecessary allocation of memory.  And you know what?? He wasn't \"wrong\".  But his approach was ignorant.  Because the temp variables were going to make absolutely no discernible difference to the user, but they were going to make future maintenance on that code _sooooo_ much easier.  You may have already guessed that I didn't stick around that gig for too long.\n\nIf your micro-optimization actually makes the code more difficult for other coders to understand, it's almost always a poor choice.\n<br/><br/>\n\n\n\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/brwda3zc9g0ant0k5bhv.jpg)\n## What To Do?\nI can confidently tell you that performance _is_ something that you should be thinking about.  Almost constantly.  _Even_ on frontend apps.  But you also need to be realistic about the fact that your code is almost always running in an environment where there are _tons_ of unused resources.  You should also remember that the most \"efficient\" algorithm isn't always the \"best\" algorithm, especially if it looks like gobbledygook to all future coders.\n\n_Thinking_ about code performance is a valuable exercise.  One that any serious programmer should probably have, almost always, in the back of their mind.  It's incredibly healthy to continually challenge yourself (and others) about the relative performance of code.  In doing so, you can vastly improve your own skills.  But performance alone should never be the end-all/be-all of your work.  And this is _especially_ true if you're a \"frontend developer\".  \n\n",t.user={name:"Adam Nathaniel Davis",username:n,twitter_username:"WritingVoyage",github_username:n,website_url:"https://adamdavis.codes",profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s--qhxJlvcY--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/337841/75deba0f-8d8a-476a-b62b-557c6de1bc8f.jpg",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--cnc0z5xu--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/337841/75deba0f-8d8a-476a-b62b-557c6de1bc8f.jpg"},{layout:"default",data:[{}],fetch:{"data-v-70afb46a:0":{article:t}},error:e,state:{currentArticle:t},serverRendered:!0,routePath:"/bytebodger/1001820",config:{_app:{basePath:"/nuxtstop/",assetsPath:"/nuxtstop/_nuxt/",cdnURL:e}}}}(null,{},"https://dev.to/bytebodger/should-frontend-devs-care-about-performance-3eg1","2022-02-27T18:31:29Z","bytebodger")</script><script src="/nuxtstop/_nuxt/f6e87fb.js" defer></script><script src="/nuxtstop/_nuxt/dc9ce94.js" defer></script><script src="/nuxtstop/_nuxt/6474719.js" defer></script><script src="/nuxtstop/_nuxt/9b75090.js" defer></script><script src="/nuxtstop/_nuxt/18df600.js" defer></script>
  </body>
</html>
