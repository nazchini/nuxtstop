<!doctype html>
<html data-n-head-ssr lang="en" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>A comparison of transaction models in distributed document databases</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content="Using Nuxt.js fetch() hook to build dev.to with a new look"><meta data-n-head="ssr" name="format-detection" content="telephone=no"><base href="/nuxtstop/"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:400,500,600&display=swap"><link rel="preload" href="/nuxtstop/_nuxt/f6e87fb.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/6474719.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/9b75090.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/18df600.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/dc9ce94.js" as="script"><style data-vue-ssr-id="c650fd98:0 af4684f0:0 a9c71758:0 dcafa518:0 4b9cec49:0 b093d766:0 9d98bcb4:0 6b6a11ea:0 0248ed80:0 ea8e4264:0">html{box-sizing:border-box;font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}*,:after,:before{box-sizing:inherit}html{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,:after,:before{border:0 solid #e0e0e0}blockquote,body,dd,dl,figure,h1,h2,h3,h4,h5,h6,p,pre{margin:0}button{background:0 0;padding:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset,ol,ul{margin:0;padding:0}ol,ul{list-style:none}hr{border-width:1px}img{border-style:solid}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:inherit;opacity:.5}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:inherit;opacity:.5}input::placeholder,textarea::placeholder{color:inherit;opacity:.5}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit;font-family:sans-serif}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit;font-family:inherit;font-size:100%}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;overflow:auto;word-break:break-word;white-space:normal}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}html{height:100%;font-size:18px;-ms-overflow-style:scrollbar;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none}@media(min-width:640px){html{font-size:20px}}body{height:100%;min-width:320px;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:400;line-height:1.5;color:#000;background-color:#eff4f7;-webkit-text-rendering:optimizeLegibility;text-rendering:optimizeLegibility;font-synthesis:none;font-kerning:normal;font-feature-settings:"normal","kern";-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-overflow-scrolling:touch;overflow-x:hidden;overflow-y:scroll}h1,h2,h3,h4,h5,h6{color:#000;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:600;font-feature-settings:"normal";line-height:1.2}pre{background:#29292e;border-radius:2px;overflow:auto;padding:1rem;color:#eff1f9;line-height:1.42em;font-size:13px}@media screen and (min-width:380px){pre{font-size:15px}}pre code{background:#29292e;color:#eff0f9;white-space:pre}div.highlight pre.highlight code{font-size:inherit;padding:0}div.inner-comment div.body div.highlight pre.highlight{background:#29292e}div.inner-comment div.body div.highlight pre.highlight code{font-size:inherit;white-space:inherit;background:inherit;color:inherit}.highlight .hll{background-color:#49483e}.highlight{background:#29292e;color:#f8f8f2}.highlight .c{color:grey}.highlight .err{text-shadow:0 0 7px #f9690e}.highlight .k{color:#f39c12}.highlight .l{color:plum}.highlight .n{color:#f8f8f2}.highlight .o{color:#f9690e}.highlight .p{color:#f8f8f2}.highlight .c1,.highlight .ch,.highlight .cm,.highlight .cp,.highlight .cpf,.highlight .cs{color:grey}.highlight .gd{color:#f9690e}.highlight .ge{font-style:italic}.highlight .gi{color:#7ed07e}.highlight .gs{font-weight:700}.highlight .gu{color:grey}.highlight .kc,.highlight .kd{color:#f39c12}.highlight .kn{color:#f9690e}.highlight .kp,.highlight .kr,.highlight .kt{color:#f39c12}.highlight .ld{color:#f2ca27}.highlight .m{color:plum}.highlight .s{color:#f2ca27}.highlight .na{color:#7ed07e}.highlight .nb{color:#f8f8f2}.highlight .nc{color:#7ed07e}.highlight .no{color:#f39c12}.highlight .nd{color:#7ed07e}.highlight .ni{color:#f8f8f2}.highlight .ne,.highlight .nf{color:#7ed07e}.highlight .nl,.highlight .nn{color:#f8f8f2}.highlight .nx{color:#7ed07e}.highlight .py{color:#f8f8f2}.highlight .nt{color:#f9690e}.highlight .nv{color:#f8f8f2}.highlight .ow{color:#f9690e}.highlight .w{color:#f8f8f2}.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo{color:plum}.highlight .dl,.highlight .s2,.highlight .sa,.highlight .sb,.highlight .sc,.highlight .sd{color:#f2ca27}.highlight .se{color:plum}.highlight .s1,.highlight .sh,.highlight .si,.highlight .sr,.highlight .ss,.highlight .sx{color:#f2ca27}.highlight .bp{color:#f8f8f2}.highlight .fm{color:#7ed07e}.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#f8f8f2}.highlight .il{color:plum}.vue-content-placeholders-heading__img,.vue-content-placeholders-heading__subtitle,.vue-content-placeholders-heading__title,.vue-content-placeholders-img,.vue-content-placeholders-text__line{background:#bfcdec!important}.vue-content-placeholders-is-animated .vue-content-placeholders-heading__img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__subtitle:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__title:before,.vue-content-placeholders-is-animated .vue-content-placeholders-img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-text__line:before{background:linear-gradient(90deg,transparent 0,#d3ddf9 15%,transparent 30%)!important}header[data-v-27046cca]{max-width:1280px;margin:auto;padding:1rem;height:6rem;border-bottom:1px solid rgba(0,0,0,.2)}header .logo-wrapper[data-v-27046cca],header[data-v-27046cca]{display:flex;align-items:center;justify-content:space-between}header .logo-wrapper[data-v-27046cca]{margin:0 .5rem}header .logo-wrapper svg[data-v-27046cca]{width:3rem;height:100%}header .logo-wrapper .name-wrapper[data-v-27046cca]{margin-left:.6em}header .logo-wrapper .name-wrapper .subtitle[data-v-27046cca]{font-size:1rem}header .logo-wrapper .name-wrapper .app-name[data-v-27046cca]{font-weight:700;font-size:2.25rem;line-height:1.25}header nav[data-v-27046cca]{letter-spacing:-.025rem;font-weight:600;text-transform:uppercase}header nav ul[data-v-27046cca]{display:flex}header nav ul li[data-v-27046cca]{margin:0 .5rem}header nav ul li a[data-v-27046cca]{box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;padding:.25rem 1rem;border-radius:.5rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}header nav ul li a[data-v-27046cca]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header nav ul li a.nuxt-link-exact-active[data-v-27046cca]{cursor:default}header nav ul li a.nuxt-link-exact-active[data-v-27046cca],header nav ul li a[data-v-27046cca]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}.page-wrapper[data-v-10d06ee8]{max-width:1280px;margin:auto;padding:1rem}.article-content-wrapper[data-v-10d06ee8]{display:flex;flex-direction:column;align-items:center;margin:auto auto 2rem}@media(min-width:1024px){.article-content-wrapper[data-v-10d06ee8]{align-items:normal;flex-direction:row}}.article-content-wrapper .article-block[data-v-10d06ee8]{width:100%;max-width:880px}@media(min-width:1024px){.article-content-wrapper .article-block[data-v-10d06ee8]{margin-right:1rem;width:66.66666%;margin-bottom:2rem}}.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{max-width:880px;width:100%;position:relative}@media(min-width:1024px){.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{display:block;width:33.33333%}}.article-content-wrapper .aside-username-wrapper .aside-username-block[data-v-10d06ee8]{position:-webkit-sticky;position:sticky;top:1rem}@media(min-width:1280px){.comments-block[data-v-10d06ee8]{margin:.5rem}}article[data-v-70afb46a]{padding:.5rem;border-radius:1rem}header h1[data-v-70afb46a],header[data-v-70afb46a]{margin-bottom:1rem}header h1[data-v-70afb46a]{font-size:2.25rem;letter-spacing:-.025rem}header .tags[data-v-70afb46a]{display:flex;flex-wrap:wrap;margin-bottom:1.5rem}header .tags .tag[data-v-70afb46a]{font-weight:500;line-height:1;padding:.5rem;margin:0 .5rem .5rem 0;border-radius:.25rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db}header .tags .tag[data-v-70afb46a]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header .tags .tag[data-v-70afb46a]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}header .image-wrapper[data-v-70afb46a]{position:relative;padding-bottom:56.25%;background-color:#d4dfe8;margin-bottom:1.5rem;border-radius:.5rem;overflow:hidden}@media(min-width:834px){header .image-wrapper[data-v-70afb46a]{margin-bottom:1.5rem}}header .image-wrapper img[data-v-70afb46a]{position:absolute;top:0;left:0;width:100%;height:100%;-o-object-fit:cover;object-fit:cover}header .meta[data-v-70afb46a]{line-height:1;font-size:.875rem;text-transform:uppercase;font-weight:500;letter-spacing:-.025rem;display:flex;align-items:center;justify-content:space-between}header .meta .scl[data-v-70afb46a]{display:flex}header .meta .scl span[data-v-70afb46a]{display:flex;align-items:center;margin-right:1rem}header .meta .scl span svg[data-v-70afb46a]{margin-right:.25rem}header .meta .scl .comments[data-v-70afb46a]{cursor:pointer}[data-v-70afb46a] .content .ltag__user{display:none}[data-v-70afb46a] .content iframe{max-width:100%}[data-v-70afb46a] .content h1{font-size:1.875rem}[data-v-70afb46a] .content h1,[data-v-70afb46a] .content h2{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h2{font-size:1.5rem}[data-v-70afb46a] .content h3{font-size:1.25rem}[data-v-70afb46a] .content h3,[data-v-70afb46a] .content h4{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h4{font-size:1rem}[data-v-70afb46a] .content a{color:#6e87d2}[data-v-70afb46a] .content p{margin-bottom:1rem;line-height:1.4}[data-v-70afb46a] .content p code{background-color:#d2f3e1;border-radius:.25rem;padding:.25rem}[data-v-70afb46a] .content img{width:100%;border-radius:.5rem}[data-v-70afb46a] .content .highlight{margin-bottom:1rem;border-radius:.5rem}[data-v-70afb46a] .content ul{list-style:numeral;margin-bottom:1rem}[data-v-70afb46a] .content ul li p{margin-bottom:0}[data-v-70afb46a] .content ol{margin-bottom:1rem}aside[data-v-37984f8c]{padding:1rem;background-color:#dfe8ef;border-radius:1rem}aside .username-heading[data-v-37984f8c]{display:flex;margin-bottom:1rem}aside .username-heading[data-v-37984f8c]:hover{color:#6e87d2}aside .username-heading img[data-v-37984f8c]{width:3rem;height:3rem;border-radius:50%;margin-right:1rem}aside .username-heading .text[data-v-37984f8c]{display:flex;flex-direction:column;justify-content:center}aside .username-heading .text a[data-v-37984f8c]{line-height:1}aside .username-heading .text a[data-v-37984f8c]:first-child{font-size:1.25rem;font-weight:500;letter-spacing:-.025rem;margin-bottom:.25rem}aside .username-heading .text a[data-v-37984f8c]:last-child{color:#999;font-size:.875rem}aside .username-heading.loading[data-v-37984f8c]{display:block}aside .f-button[data-v-37984f8c]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}aside .f-button[data-v-37984f8c]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}aside .f-button[data-v-37984f8c]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}aside .info>div[data-v-37984f8c]{margin-bottom:.5rem}aside .info .title[data-v-37984f8c]{font-size:.666666rem;letter-spacing:-.0125rem;font-weight:500;color:#999;text-transform:uppercase;margin-bottom:.1rem}aside .info .content[data-v-37984f8c]{font-size:.875rem;line-height:1.4}.add-comment[data-v-8c4375bc]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}.add-comment[data-v-8c4375bc]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}.add-comment[data-v-8c4375bc]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}footer[data-v-22cb8fd0]{padding:2rem;text-align:center;display:flex;align-items:center;justify-content:center}footer span[data-v-22cb8fd0]{display:inline-block;line-height:1;text-transform:uppercase;letter-spacing:-.025rem;font-size:.75rem;font-weight:500}footer a svg[data-v-22cb8fd0]{width:3rem;height:3rem;margin:0 .5rem}footer a .nuxt-icon[data-v-22cb8fd0]{width:2.5rem;height:2.5rem;margin:0 .25rem}</style>
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><div id="__layout"><div><header data-v-27046cca><a href="/nuxtstop/" class="logo-wrapper nuxt-link-active" data-v-27046cca><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-27046cca><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-27046cca></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-27046cca></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-27046cca></path></svg> <div class="name-wrapper" data-v-27046cca><span class="app-name" data-v-27046cca>Nuxtstop</span> <p class="subtitle" data-v-27046cca>For all things nuxt.js</p></div></a> <nav data-v-27046cca><ul data-v-27046cca><li data-v-27046cca><a href="/nuxtstop/" class="nuxt-link-active" data-v-27046cca>
          New
        </a></li><li data-v-27046cca><a href="/nuxtstop/top" data-v-27046cca>
          Top
        </a></li></ul></nav></header> <div class="page-wrapper" data-v-10d06ee8><div class="article-content-wrapper" data-v-10d06ee8><article data-fetch-key="data-v-70afb46a:0" class="article-block" data-v-70afb46a data-v-10d06ee8><header data-v-70afb46a><h1 data-v-70afb46a>A comparison of transaction models in distributed document databases</h1> <div class="tags" data-v-70afb46a><a href="/nuxtstop/t/fauna" class="tag" data-v-70afb46a>
          #fauna
        </a><a href="/nuxtstop/t/database" class="tag" data-v-70afb46a>
          #database
        </a><a href="/nuxtstop/t/serverless" class="tag" data-v-70afb46a>
          #serverless
        </a></div> <div class="image-wrapper" data-v-70afb46a><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--GpjmSdEb--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/z2id2xjtn4985j5it6sr.png" alt="A comparison of transaction models in distributed document databases" data-v-70afb46a></div> <div class="meta" data-v-70afb46a><div class="scl" data-v-70afb46a><span data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M16.4444 3C14.6733 3 13.0333 3.94162 12 5.34C10.9667 3.94162 9.32667 3 7.55556 3C4.49222 3 2 5.52338 2 8.625C2 14.8024 11.0267 20.586 11.4122 20.829C11.5922 20.9426 11.7956 21 12 21C12.2044 21 12.4078 20.9426 12.5878 20.829C12.9733 20.586 22 14.8024 22 8.625C22 5.52338 19.5078 3 16.4444 3Z" fill="#FF0000" data-v-70afb46a data-v-70afb46a></path></svg>
            11
          </span> <span class="comments" data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M6.11765 22H4.94118L5.64706 21.05C6.11765 20.3969 6.41176 19.5656 6.58824 18.5563C3.64706 17.1906 2 14.6375 2 11.3125C2 6.20625 5.82353 3 12 3C18.1765 3 22 6.20625 22 11.3125C22 16.5375 18.2353 19.625 12 19.625H11.5882C10.6471 20.7531 9 22 6.11765 22ZM12 4.1875C6.47059 4.1875 3.17647 6.85937 3.17647 11.3125C3.17647 15.1125 5.47059 16.8938 7.41177 17.6656L7.82353 17.8437L7.76471 18.3187C7.64706 19.2687 7.47059 20.1 7.11765 20.8125C9.05882 20.575 10.1765 19.5656 10.8235 18.7344L11 18.4969H12C19.9412 18.4969 20.8235 13.5094 20.8235 11.3719C20.8235 6.85938 17.5294 4.1875 12 4.1875Z" fill="black" data-v-70afb46a data-v-70afb46a></path></svg>
            0
          </span></div> <time data-v-70afb46a>Aug 25 '21</time></div></header> <div class="content" data-v-70afb46a><p><em>This is the first in a series of posts comparing different aspects of modern operational databases. Written by Evan Weaver, CTO and co-founder of Fauna, it originally appeared on <a href="http://www.fauna.com/blog">www.fauna.com/blog</a>.</em></p>

<p>A distributed document database is a NoSQL database that stores semi-structured data, usually in a format similar to JSON, and is horizontally scalable across multiple machines. Document databases are very convenient for modern application development, because modern application frameworks and languages are also based on semi-structured objects instead of tabular data. They are often a better fit than a SQL database, where rigid schemas resist object evolution, and complex client-side object-relational mappers simulate an object-oriented interface with incomplete success.</p>

<p>In the distant past of the 2010’s, distributed document databases didn’t offer transaction support, instead implementing various forms of eventual consistency. Vendors and open-source maintainers promoted the idea that transactionality was an unnecessary, complexifying feature that damaged scalability and availability—and many claimed that adding it to their systems was <a href="https://stackoverflow.com/questions/16779348/does-the-cap-theorem-imply-that-acid-is-not-possible-for-distributed-databases">impossible</a>.</p>

<p>Time has gone by and things are very different now. The benefits of transactionality are widely accepted outside of the context of SQL and <a href="https://docs.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga">even databases in general</a>, and key distributed systems problems have <a href="https://fauna.com/blog/distributed-consistency-at-scale-spanner-vs-calvin?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog">been solved</a>. All modern distributed document databases now offer some form of transactionality, but their implementations and characteristics vary widely.</p>

<p>Read on to explore the differences between Couchbase, MongoDB, Google Cloud Firestore, and Fauna.</p>

<h4>
  <a name="what-is-best-in-life-and-transactions" href="#what-is-best-in-life-and-transactions">
  </a>
  What is best in life and transactions?
</h4>

<p>Database transactions keep changes to disparate records bundled together, ensuring that applications can read and write data without colliding with each other or interleaving their updates in confusing or invalid ways. </p>

<p>The ACID acronym (“atomicity, consistency, isolation, durability”) is commonly used to describe the basic properties of transactions, but doesn’t fully describe what it’s like to use them. In practice, when evaluating transaction implementations, we want to look for:</p>

<ul>
<li>
<strong>Consistency level:</strong> higher consistency levels are easier to reason about</li>
<li>
<strong>Generality:</strong> fewer special cases in implementation and interface lead to fewer bugs</li>
<li>
<strong>Performance:</strong> the less that transactions impact throughput and latency, the better</li>
<li>
<strong>Ease-of-use:</strong> writing transactional queries should be straightforward, and reading transactional data should be transparent</li>
</ul>

<p>We will keep this framework in mind as we discuss the various systems.</p>

<h2>
  <a name="couchbase" href="#couchbase">
  </a>
  Couchbase
</h2>

<p><a href="https://www.couchbase.com/">Couchbase</a> was originally developed by merging Membase, a fork of Memcache with on-disk durability, with CouchDB, a somewhat experimental document database written in Erlang. As such, it has a relatively tortured development history. It has adopted a relatively tortured transaction model as well.</p>

<p>Couchbase transactions work <a href="https://blog.couchbase.com/distributed-multi-document-acid-transactions/">purely from the client-side</a>. Each Couchbase SDK implements an algorithm that essentially writes a lock record into each shard, then writes uncommitted writes into each document as metadata, then updates the lock records, then moves the metadata into the documents to become the primary data. Other clients that observe document metadata must check the locking document to find out the state of the transaction, and race to clean up unapplied or aborted writes based on wall clock time.</p>

<h4>
  <a name="acid-properties" href="#acid-properties">
  </a>
  ACID properties
</h4>

<p>Couchbase’s algorithm provides read-committed isolation as far as document reads go, but no isolation at all for <a href="https://docs.couchbase.com/server/current/learn/data/transactions.html#indexes-and-transactions">derived data like indexes</a>, which have no way to tell if data is being modified concurrently or not. It also does not offer snapshot isolation for readers, which means that nobody really has a consistent view of the entire database at any time, and it is vulnerable to clock skew in the locking mechanism.</p>

<p>As far as I can tell, when Couchbase transactions span shards, they are not actually isolated or atomic, because there is no specific reason to assume that readers will observe transaction record state in the same order that writers do, or that a writer will successfully update all locking documents.</p>

<p>Couchbase offers several tunable durability and quorum options that interact with transaction read and write consistency in confusing ways, and the default does not require disk persistence for writes. Finally, multi-region transactions are not supported at all because there is no synchronous multi-region replication.</p>

<p>Couchbase has not verified their transactions under Jepsen, but only done some <a href="https://blog.couchbase.com/introduction-to-jepsen-testing-at-couchbase/">in-house work</a> to verify the basic single-document replication protocol. Ultimately, Couchbase does not offer any meaningful general level of consistency, so maybe there’s nothing to verify. For example, you cannot use this system to implement unique constraints, a very basic goal.</p>

<h4>
  <a name="interface" href="#interface">
  </a>
  Interface
</h4>

<p>Couchbase has adopted a SQL-like syntax called N1QL and applied the same tactic to <a href="https://blog.couchbase.com/couchbase-transactions-with-n1ql/">transaction support</a>, with explicit START TRANSACTION/COMMIT TRANSACTION statements. Transactions are interactive in that clients can hold them open indefinitely (well, as long as the cleanup window lasts) and interleave them with client-side computation. </p>

<p>Here is a N1QL example:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight sql"><code><span class="k">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>
<span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">airport</span> <span class="k">WHERE</span> <span class="n">city</span><span class="o">=</span><span class="s1">'Stanted'</span><span class="p">;</span>
<span class="k">UPDATE</span> <span class="n">airport</span> <span class="k">SET</span> <span class="n">city</span><span class="o">=</span><span class="s1">'London'</span> <span class="k">WHERE</span> <span class="n">faa</span><span class="o">=</span><span class="s1">'STN'</span><span class="p">;</span>
<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">airport</span> <span class="k">WHERE</span> <span class="n">city</span><span class="o">=</span><span class="s1">'London'</span> <span class="k">AND</span> <span class="n">faa</span> <span class="o">!=</span> <span class="s1">'STN'</span><span class="p">;</span>
<span class="k">COMMIT</span> <span class="n">TRANSACTION</span><span class="p">;</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>This interface is reasonable, although many other Couchbase interfaces, and even other SDKs, are not transaction-aware and will serve stale reads during commits.</p>

<h4>
  <a name="performance" href="#performance">
  </a>
  Performance
</h4>

<p>Because the transactional operations involve so many additional client-side reads and writes, they are much slower than normal operation, which Couchbase touts as a feature—because you can avoid the slowdown by not using transactions.</p>

<h4>
  <a name="summary" href="#summary">
  </a>
  Summary
</h4>

<p>So how does Couchbase fare according to our criteria? The consistency level offered is essentially no consistency at all by database standards. Generality is poor since transactions due not affect indexes or non-transactional clients. Theoretical performance is also poor relative to baseline due to the multiphase client-side lock management. Ease-of-use is adequate, though, as long as the interface supports it. </p>

<p>Personally, I feel like Couchbase transactions should really be called batch writes, as they offer essentially none of the properties one would expect from a multi-document transaction.</p>

<h2>
  <a name="mongodb" href="#mongodb">
  </a>
  MongoDB
</h2>

<p><a href="https://www.mongodb.com/">MongoDB</a> began its life essentially as a JSON database for node.js. Very easy to use for JavaScript developers, it struggled with basic durability until the addition of the WiredTiger storage engine. After many years of preaching that transactions were unnecessary and advocating for extensive data denormalization to compensate, MongoDB capitulated and added transaction support a few years ago.</p>

<p>MongoDB implements a sharded primary-secondary replication system, with a dizzying array of <a href="https://developer.mongodb.com/how-to/global-read-write-concerns/#overriding-global-read-and-write-concerns">tunable read and write consistency levels</a>. Its transactions are implemented via a cluster-wide <a href="https://www.mongodb.com/blog/post/transactions-background-part-4-the-global-logical-clock">hybrid logical clock</a> from which transaction timestamps are derived. Within a shard, transactions are written first to a write-ahead log on the primary node, and then the values of the transactions are written with their timestamps into the storage engine, which offers multi-version concurrency control for snapshot reads. Transactions that span shards have an additional layer of what appears to be two-phase commit coordination.</p>

<h4>
  <a name="acid-properties" href="#acid-properties">
  </a>
  ACID properties
</h4>

<p>At best, MongoDB offers snapshot isolation. This means that unlike Couchbase, it at least has some hope of being serializable (which basically means transactions get applied in some non-overlapping order, even if it wasn’t the one you would expect).</p>

<p>Unfortunately, the default consistency levels allow reads of committed data to happen before replication has occurred, so dirty reads and lost transactions are possible during failover. Like Couchbase, even this level of fault-intolerant isolation is limited to a single shard. For transactions which span shards, <a href="https://docs.mongodb.com/manual/core/transactions-sharded-clusters/">there is no read-side coordination</a>: readers will observe transactions torn at their shard boundaries, violating snapshot consistency. Even readers within transactions will not see isolated commits of other transactions unless a non-default read consistency level is used.</p>

<p>Unique constraints are supported, but apparently via a different mechanism than transactions as they predate them. It is unclear to me how indexes with unique constraints interact with snapshot isolation within transactions.</p>

<p>MongoDB has been independently tested with Jepsen, but there is <a href="https://jepsen.io/analyses/mongodb-4.2.6">extensive disagreement</a> between the company and the Jepsen team about the correct interpretation of the results. There are <a href="https://docs.mongodb.com/manual/core/transactions/%23transactions-and-write-concern">many combinations</a> of read and write consistency levels that will violate even the most basic transactional properties.</p>

<h4>
  <a name="interface" href="#interface">
  </a>
  Interface
</h4>

<p>Rather than a true query language, MongoDB implements DSLs in its drivers that follow the same basic syntactic patterns. Beginning and ending a transaction requires creating a session object with correct read and write consistency levels, and then separately beginning a transaction with (possibly different) read and write consistency levels, and then committing the transaction. Naively using the transactional feature will not reliably result in transactional behavior.</p>

<p>Here is a <a href="https://docs.mongodb.com/v4.0/core/transactions/">JavaScript example</a>:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight javascript"><code><span class="nx">session</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">getMongo</span><span class="p">().</span><span class="nx">startSession</span><span class="p">(</span> <span class="p">{</span> <span class="na">readPreference</span><span class="p">:</span> <span class="p">{</span> <span class="na">mode</span><span class="p">:</span> <span class="dl">"</span><span class="s2">primary</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span> <span class="nx">session</span><span class="p">.</span><span class="nx">startTransaction</span><span class="p">(</span> <span class="p">{</span> <span class="na">readConcern</span><span class="p">:</span> <span class="p">{</span> <span class="na">level</span><span class="p">:</span> <span class="dl">"</span><span class="s2">snapshot</span><span class="dl">"</span> <span class="p">},</span> <span class="na">writeConcern</span><span class="p">:</span> <span class="p">{</span> <span class="na">w</span><span class="p">:</span> <span class="dl">"</span><span class="s2">majority</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span>
<span class="nx">session</span><span class="p">.</span><span class="nx">getDatabase</span><span class="p">(</span><span class="dl">"</span><span class="s2">hr</span><span class="dl">"</span><span class="p">).</span><span class="nx">employees</span><span class="p">.</span><span class="nx">updateOne</span><span class="p">(</span> <span class="p">{</span> <span class="na">employee</span><span class="p">:</span> <span class="mi">3</span> <span class="p">},</span> <span class="p">{</span> <span class="na">$set</span><span class="p">:</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Inactive</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span>
<span class="nx">session</span><span class="p">.</span><span class="nx">getDatabase</span><span class="p">(</span><span class="dl">"</span><span class="s2">reporting</span><span class="dl">"</span><span class="p">).</span><span class="nx">events</span><span class="p">.</span><span class="nx">insertOne</span><span class="p">(</span> <span class="p">{</span> <span class="na">employee</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">status</span><span class="p">:</span> <span class="p">{</span> <span class="na">new</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Inactive</span><span class="dl">"</span><span class="p">,</span> <span class="na">old</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Active</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span>
<span class="nx">session</span><span class="p">.</span><span class="nx">commitTransaction</span><span class="p">();</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>Additionally, out of band coordination, most likely via human beings, is required to make sure that all potential readers of the transactional writes are also transaction-aware.</p>

<h4>
  <a name="performance" href="#performance">
  </a>
  Performance
</h4>

<p>MongoDB transactions add little overhead to single shard queries in their default configuration, but also don’t really offer any transactional properties. Setting the appropriate read and write consistency levels means that both readers and writers will block on quorum among the primaries and secondaries of the shard. This impacts the latency profile of writes, and the throughput and latency profile of reads, since more nodes have to be queried.</p>

<p>Moving to sharded queries slows down writes substantially due to the extra roundtrips the two-phase model layers on top. Unless transactions and shard keys are carefully designed to avoid this, the performance discontinuity may be unpredictable.</p>

<h4>
  <a name="summary" href="#summary">
  </a>
  Summary
</h4>

<p>MongoDB’s consistency level is adequate, but the generality is poor because of all the edge cases. Theoretical performance is poor and unpredictable relative to baseline. And due to the confusing interaction of the read, write, and transaction consistency, ease-of-use is also not good, putting aside any issues with the query language itself. </p>

<p>However, I will grant that unlike Couchbase, MongoDB transactions really are transactions.</p>

<h2>
  <a name="google-cloud-firestore" href="#google-cloud-firestore">
  </a>
  Google Cloud Firestore
</h2>

<p>Some databases are actually domain-specific interfaces to other databases, and <a href="https://firebase.google.com/products/firestore">Firestore</a> is one of them. Firestore is the updated version of <a href="https://firebase.google.com/docs/database">Firebase Realtime Database</a>, a mobile-oriented cloud service that was originally implemented as a service on top of MongoDB. Google acquired Firebase in 2014, and ported the interface, with modifications, to a<a href="https://cloud.google.com/spanner"> Google Spanner</a> backend in 2019. </p>

<p>Firebase implemented an unusual hierarchical data model, somewhat similar to<a href="https://en.wikipedia.org/wiki/MUMPS"> MUMPS</a>. This caused a lot of problems because it was difficult to query and update subtrees of the hierarchy in a predictable and performant way. Nevertheless, treating the entire database as a single document did allow for atomic updates of subtrees. </p>

<p>Firestore improved on the Firebase data model by switching to a <a href="https://firebase.google.com/docs/firestore/data-model">hybrid document-hierarchical model</a>. Instead of a giant tree, the database is now composed of collections, which can contain documents, which can contain subcollections, which can contain subdocuments, more or less indefinitely. This creates natural record boundaries at the document level which corresponds well with the underlying relational model of Spanner. </p>

<p>This data model was influenced by the Google Cloud Datastore data model, an eventually consistent document database originally built for Google App Engine that also predated Google Spanner. In fact, Firestore includes a Datastore compatibility mode.</p>

<h4>
  <a name="acid-properties" href="#acid-properties">
  </a>
  ACID properties
</h4>

<p>Conceptually, Firestore is rewriting document queries into relational queries for Spanner, and inherits Spanner’s consistency model. Spanner implements<a href="https://fauna.com/blog/a-comparison-of-scalable-database-isolation-levels?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog"> serializability</a> via a multi-phase implementation backed by<a href="https://fauna.com/blog/distributed-consistency-at-scale-spanner-vs-calvin?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog"> physical atomic clocks</a>. Serializability is a very good isolation level.</p>

<p>However, there are some nuances here. Due to its origin as a mobile database, Firestore is designed around mixed client access. Because mobile devices are usually highly latent, Firestore transactions are implemented in mobile clients with client-side <a href="https://firebase.google.com/docs/firestore/transaction-data-contention#concurrency-controls">optimistic concurrency control</a>. Effectively, all mobile transactions are rewritten into a series of incremental reads, and then a transactional compare-and-swap operation for the writes. This has a number of implications:</p>

<ul>
<li>In a Firestore transaction, <a href="https://firebase.google.com/docs/firestore/manage-data/transactions#transaction_failure">all reads are executed before all writes</a>
</li>
<li>Reads cannot see the result of writes within the transaction</li>
<li>A transaction, including its client side logic, may run multiple times, so side effects are dangerous</li>
</ul>

<p>On the other hand, server-side transactions use a more typical <a href="https://firebase.google.com/docs/firestore/transaction-data-contention#concurrency-controls">pessimistic relational lock</a>. They open a transaction, do some work, and then commit it. </p>

<p>Read-only queries appear to default to strong consistency, with no way to drop to snapshot consistency like Spanner, unless you use the alternate Datastore API.</p>

<p>Firestore mobile clients also use a local cache for offline syncing. This means that it is possible for several things to happen when the client is offline:</p>

<ul>
<li>Stale reads will be served from cache</li>
<li>Non-transactional writes and write-only transactions will be buffered and submitted when the client reconnects</li>
<li>Read-write transactions will error out</li>
</ul>

<p>Although these are desirable behaviors for Firestore, they violate the consistency model. </p>

<p>Firestore has not been verified with Jepsen, but there is no serious doubt in the industry that Spanner’s <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf">implementation</a> is sound. Nevertheless the mobile clients clearly violate the database’s consistency guarantees. </p>

<h4>
  <a name="interface" href="#interface">
  </a>
  Interface
</h4>

<p>Firestore’s interface is composed around transaction lambdas, which can intermix client-side compute with simple calls for database reads and writes. As discussed above, whether the transaction executes optimistically and potentially multiple times, or pessimistically and only once, depends on whether a server or mobile driver is used. </p>

<p>Here is a <a href="https://firebase.google.com/docs/firestore/manage-data/transactions">JavaScript example</a>:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight javascript"><code><span class="nx">db</span><span class="p">.</span><span class="nx">runTransaction</span><span class="p">((</span><span class="nx">transaction</span><span class="p">)</span> <span class="o">=></span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">transaction</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">collection</span><span class="p">(</span><span class="dl">"</span><span class="s2">cities</span><span class="dl">"</span><span class="p">).</span><span class="nx">doc</span><span class="p">(</span><span class="dl">"</span><span class="s2">SF</span><span class="dl">"</span><span class="p">)).</span><span class="nx">then</span><span class="p">((</span><span class="nx">sfDoc</span><span class="p">)</span> <span class="o">=></span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">newPopulation</span> <span class="o">=</span> <span class="nx">sfDoc</span><span class="p">.</span><span class="nx">data</span><span class="p">().</span><span class="nx">population</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="nx">transaction</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">collection</span><span class="p">(</span><span class="dl">"</span><span class="s2">cities</span><span class="dl">"</span><span class="p">).</span><span class="nx">doc</span><span class="p">(</span><span class="dl">"</span><span class="s2">SF</span><span class="dl">"</span><span class="p">),</span> <span class="p">{</span> <span class="na">population</span><span class="p">:</span> <span class="nx">newPopulation</span> <span class="p">});</span>
    <span class="p">});</span>
<span class="p">});</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>Like MongoDB, Firestore does not offer a true query language, and supports quite a bit less in terms of query sophistication. As far as transactions go, this interface is reasonable, but the inability to read your own writes within a transaction is an inconvenience.</p>

<p>Firestore appears to <a href="https://firebase.google.com/docs/firestore/query-data/indexing">implement its indexes</a> as separate tables within Spanner. It requires the user to explicitly lay out the index data to support the application’s query patterns, rather than delegating to indexed relational queries underneath. Firestore indexes every individual field within a document by default, to make naive querying easier. This comes at a cost: transaction sizes by default are relatively large. It is possible to manually exempt fields from indexing.</p>

<h4>
  <a name="performance" href="#performance">
  </a>
  Performance
</h4>

<p>Firestore offers many Google Cloud single-datacenter <a href="https://firebase.google.com/docs/firestore/locations">locations</a>, but only multi-datacenter support in the US and Europe. Multi-datacenter support comes with a higher cost and higher write latency, but potentially lower read latency depending on client location.  </p>

<p>Firestore transactions run in Spanner’s default strong consistency mode, which is fast, especially for single-datacenter databases. Multi-datacenter transactions must block on a write quorum for every shard in the query. How indexing affects the shard layout within a transaction is unclear.</p>

<h4>
  <a name="summary" href="#summary">
  </a>
  Summary
</h4>

<p>Firestore’s consistency model, after the rewrite onto Spanner, is very good. Generality is optimal with no meaningful edge cases except for well-documented and predictable ones. However, ease of use could be better. Performance is good. But the data model and indexing scheme are strange, even if they are familiar to longtime Firebase users. And the lack of query flexibility limits utility compared to something like SQL or N1QL. </p>

<h2>
  <a name="fauna" href="#fauna">
  </a>
  Fauna
</h2>

<p>Fauna is a database as an API. Is it a document database? Yes, and it is also a document-relational database, since it offers not just transactions, but foreign keys, views, and joins. It supports a GraphQL interface and its own query language FQL, and also provides temporal access to data history.</p>

<p>Fauna implements a unique single-phase transaction architecture<a href="https://fauna.com/blog/consistency-without-clocks-faunadb-transaction-protocol?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog"> based on Calvin</a>. Like MongoDB, its data model is based on documents and collections. Like Spanner, it offers a best-in-class consistency model. Like Firestore, it has a serverless operational model. And unlike other document databases, it offers the ability to compute close to the data with a rich standard library and function model—as rich or richer than SQL. </p>

<h4>
  <a name="acid-properties" href="#acid-properties">
  </a>
  ACID properties
</h4>

<p>In Fauna, every query is a transaction. Read-write transactions are <a href="https://docs.fauna.com/fauna/current/concepts/isolation_levels.html?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog">strictly serializable</a> via the transaction log, which offers a partitioned and replicated commit point without coordination with the data replicas or with atomic clocks. Read-only transactions are serializable via careful timestamp management within the database and the database drivers, and in practice, indistinguishable from strict serializability. </p>

<p>Unlike the other databases here, there are no default consistency level concerns or driver features that can violate the consistency model. Transactions can read their own writes as well. </p>

<p>The one thing transactions can’t do is client-side compute; instead, Fauna focuses on in-database computation, with a Turing-complete query language called FQL and support for complex branching and looping, math and string manipulation, and user-defined functions.</p>

<p>Fauna’s consistency model and implementation have been independently<a href="https://fauna.com/blog/faunadbs-official-jepsen-results?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog"> verified with Jepsen</a> and found to be sound, although the analysis is out of date and the database is much improved since.</p>

<h4>
  <a name="interface" href="#interface">
  </a>
  Interface
</h4>

<p>Like Firestore, Fauna’s interface is composed around query lambdas. However, within the lambda, the user cannot make application-side calls with side effects or that have read or write dependencies. Instead, this work is delegated to the database itself. </p>

<p>Here is a<a href="https://fireship.io/lessons/fauna-db-quickstart/"> Javascript example</a>:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight javascript"><code><span class="k">await</span> <span class="nx">client</span><span class="p">.</span><span class="nx">query</span><span class="p">(</span>
        <span class="nx">Create</span><span class="p">(</span>
            <span class="nx">Collection</span><span class="p">(</span><span class="dl">'</span><span class="s1">relationships</span><span class="dl">'</span><span class="p">),</span>
            <span class="nx">follower</span><span class="p">:</span> <span class="nx">Call</span><span class="p">(</span><span class="nx">Fn</span><span class="p">(</span><span class="dl">"</span><span class="s2">getUser</span><span class="dl">"</span><span class="p">),</span> <span class="dl">'</span><span class="s1">alice</span><span class="dl">'</span><span class="p">),</span>
            <span class="nx">followee</span><span class="p">:</span> <span class="nx">Call</span><span class="p">(</span><span class="nx">Fn</span><span class="p">(</span><span class="dl">"</span><span class="s2">getUser</span><span class="dl">"</span><span class="p">),</span> <span class="dl">'</span><span class="s1">bob</span><span class="dl">'</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">});</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>This query is transactional by default and refers to a user-defined database function “getUser”, part of this database's schema, to simplify the logic. </p>

<p>Although side-effects and computation on dependencies are not allowed, client language features can still be used for query composition; for example, defining a subquery ahead of time and referring to it with a local variable.</p>

<p>Although Fauna encourages an index-per-query pattern similar to Firebase, it is not required, and Fauna does not automatically create multiple default indexes for documents.</p>

<h4>
  <a name="performance" href="#performance">
  </a>
  Performance
</h4>

<p>Fauna is designed to minimize latency in <a href="https://fauna.com/blog/meeting-data-residence-and-increasing-performance-with-fauna-region-groups?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog">multi-datacenter replication scenarios</a>. A read-write transaction only requires one roundtrip within a majority of replication sites, and read-only transactions do not require any round trips at all. This makes the performance profile similar to Spanner and presumably to Firestore as well.</p>

<p>Fauna does not yet offer single-datacenter region configurations, so its latency will be higher than other databases configured without multi-region replication.</p>

<p>Couchbase, MongoDB, and Firestore all use an interactive session model: reads and  writes are issued incrementally, and compute is run in the client. This means that latency stacks up more or less linearly with the number of database operations within the transaction. </p>

<p>Fauna, on the other hand, includes a <a href="https://docs.fauna.com/fauna/current/api/fql/cheat_sheet?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog">comprehensive standard library</a> within FQL itself. This allows the database to execute business logic colocated with the data, and also to guarantee that the logic runs only once and is side-effect free. </p>

<h4>
  <a name="summary" href="#summary">
  </a>
  Summary
</h4>

<p>At Fauna, we want to give developers the best database infrastructure possible delivered by the ideal APIs, especially document APIs like GraphQL and FQL. The Fauna architecture offers the highest level of consistency, strict serializibility,  without edge cases. Performance is very good and theoretically optimal in multi-region scenarios. And since Fauna is delivered as an API, our customers are responsible for no operational tasks of any kind, even though the underlying service is continuously being improved. </p>

<p>Although FQL is unfamiliar to most, we are working hard to improve its ease of use and expand its capability. Certainly taking advantage of its transactionality is trivial because everything is a transaction by default, with no “escape routes” that could lead to potential correctness problems. </p>

<p>If you are looking for a document database, I hope this article helps guide you in the right direction. And if you want to never have to manage that  database again, don’t forget to <a href="https://dashboard.fauna.com/accounts/register?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog">give Fauna a try</a>. </p>

</div></article> <div class="aside-username-wrapper" data-v-10d06ee8><aside class="aside-username-block" data-v-37984f8c data-v-10d06ee8><div class="username-heading loading" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-heading" data-v-37984f8c><div class="vue-content-placeholders-heading__img"></div> <div class="vue-content-placeholders-heading__content"><div class="vue-content-placeholders-heading__title"></div> <div class="vue-content-placeholders-heading__subtitle"></div></div></div></div></div> <div class="info" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-text" data-v-37984f8c><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div></div></div></div></aside></div></div> <div class="comments-block" data-v-8c4375bc data-v-10d06ee8><!----> <a href="https://dev.to/fauna_admin/a-comparison-of-transaction-models-in-distributed-document-databases-1naj" target="_blank" rel="nofollow noopener noreferer" class="add-comment" data-v-8c4375bc>
    Add comment
  </a></div></div> <footer data-v-22cb8fd0><span data-v-22cb8fd0>Built with</span> <a href="https://nuxtjs.org" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="nuxt-icon" data-v-22cb8fd0 data-v-22cb8fd0><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a> <span data-v-22cb8fd0>&</span> <a href="https://docs.dev.to/api" rel="nofollow noopener" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-22cb8fd0 data-v-22cb8fd0><path d="M1.5726 5.13748C1.42945 5.20622 1.2411 5.36661 1.15822 5.48117C1 5.69503 1 5.74849 1 11.8739C1 17.9993 1 18.0528 1.15822 18.2667C1.2411 18.3812 1.42945 18.5416 1.5726 18.6104C1.8137 18.7402 2.46164 18.7478 12 18.7478C21.5384 18.7478 22.1863 18.7402 22.4274 18.6104C22.5706 18.5416 22.7589 18.3812 22.8418 18.2667C23 18.0528 23 17.9993 23 11.8739C23 5.74849 23 5.69503 22.8418 5.48117C22.7589 5.36661 22.5706 5.20622 22.4274 5.13748C22.1863 5.00764 21.5384 5 12 5C2.46164 5 1.8137 5.00764 1.5726 5.13748ZM7.7055 8.2613C8.0822 8.45989 8.59454 9.0098 8.77536 9.40694C8.89589 9.66664 8.91095 9.94922 8.91095 12.0649C8.91095 14.3104 8.90344 14.4478 8.75275 14.7839C8.51919 15.288 8.16506 15.6546 7.68288 15.899C7.26096 16.1052 7.22328 16.1128 5.7315 16.1358L4.20206 16.1663V12.1031V8.04744L5.80684 8.07035C7.27602 8.09327 7.42672 8.10854 7.7055 8.2613ZM13.6952 8.89521V9.73538H12.4521H11.2089V10.4991V11.2629H11.9623H12.7158V12.1031V12.9432H11.9623H11.2089V13.707V14.4708H12.4521H13.6952V15.3109V16.151H12C10.1315 16.151 10.0411 16.1358 9.67191 15.6928L9.47603 15.4484V12.1336C9.47603 8.46752 9.46851 8.49807 9.95069 8.20783C10.1692 8.07035 10.3425 8.05508 11.9473 8.05508H13.6952V8.89521ZM16.5658 10.3769C16.8897 11.6295 17.1685 12.6912 17.176 12.7293C17.1911 12.7675 17.4699 11.7441 17.8014 10.461C18.1254 9.17017 18.4343 8.1009 18.4795 8.08563C18.5247 8.06271 18.9541 8.06271 19.4288 8.07035L20.3028 8.09327L19.376 11.6219C18.8713 13.5542 18.4117 15.2269 18.3664 15.3261C18.0123 16.0135 17.274 16.3343 16.7164 16.0441C16.4528 15.899 16.0911 15.4865 15.9705 15.1887C15.9254 15.0665 15.4884 13.4549 15.0062 11.6142C14.524 9.76593 14.1171 8.20783 14.0945 8.15437C14.0644 8.07035 14.2301 8.05508 15.0212 8.07035L15.9856 8.09327L16.5658 10.3769Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M5.93491 12.103V14.4707H6.27394C6.66574 14.4707 7.01983 14.3103 7.1404 14.0965C7.18559 14.0048 7.21575 13.2105 7.21575 12.0648V10.1783L6.99725 9.95683C6.80133 9.76591 6.71847 9.73535 6.35683 9.73535H5.93491V12.103Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a></footer></div></div></div><script>window.__NUXT__=function(a,e,n,s){return s.type_of="article",s.id=803635,s.title="A comparison of transaction models in distributed document databases",s.description="This is the first in a series of posts comparing different aspects of modern operational databases....",s.readable_publish_date="Aug 25 '21",s.slug="a-comparison-of-transaction-models-in-distributed-document-databases-1naj",s.path="/fauna/a-comparison-of-transaction-models-in-distributed-document-databases-1naj",s.url="https://dev.to/fauna/a-comparison-of-transaction-models-in-distributed-document-databases-1naj",s.comments_count=0,s.public_reactions_count=11,s.collection_id=a,s.published_timestamp=n,s.positive_reactions_count=11,s.cover_image="https://res.cloudinary.com/practicaldev/image/fetch/s--GpjmSdEb--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/z2id2xjtn4985j5it6sr.png",s.social_image="https://res.cloudinary.com/practicaldev/image/fetch/s--dWSvXwrN--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/z2id2xjtn4985j5it6sr.png",s.canonical_url="https://fauna.com/blog/comparison-of-transaction-models-in-document-databases",s.created_at="2021-08-25T23:13:42Z",s.edited_at="2021-08-26T12:56:27Z",s.crossposted_at=a,s.published_at=n,s.last_comment_at=n,s.reading_time_minutes=14,s.tag_list="fauna, database, serverless",s.tags=[e,"database","serverless"],s.body_html='<p><em>This is the first in a series of posts comparing different aspects of modern operational databases. Written by Evan Weaver, CTO and co-founder of Fauna, it originally appeared on <a href="http://www.fauna.com/blog">www.fauna.com/blog</a>.</em></p>\n\n<p>A distributed document database is a NoSQL database that stores semi-structured data, usually in a format similar to JSON, and is horizontally scalable across multiple machines. Document databases are very convenient for modern application development, because modern application frameworks and languages are also based on semi-structured objects instead of tabular data. They are often a better fit than a SQL database, where rigid schemas resist object evolution, and complex client-side object-relational mappers simulate an object-oriented interface with incomplete success.</p>\n\n<p>In the distant past of the 2010’s, distributed document databases didn’t offer transaction support, instead implementing various forms of eventual consistency. Vendors and open-source maintainers promoted the idea that transactionality was an unnecessary, complexifying feature that damaged scalability and availability—and many claimed that adding it to their systems was <a href="https://stackoverflow.com/questions/16779348/does-the-cap-theorem-imply-that-acid-is-not-possible-for-distributed-databases">impossible</a>.</p>\n\n<p>Time has gone by and things are very different now. The benefits of transactionality are widely accepted outside of the context of SQL and <a href="https://docs.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga">even databases in general</a>, and key distributed systems problems have <a href="https://fauna.com/blog/distributed-consistency-at-scale-spanner-vs-calvin?utm_source=dev.to&amp;utm_medium=referral&amp;utm_campaign=fauna_blog">been solved</a>. All modern distributed document databases now offer some form of transactionality, but their implementations and characteristics vary widely.</p>\n\n<p>Read on to explore the differences between Couchbase, MongoDB, Google Cloud Firestore, and Fauna.</p>\n\n<h4>\n  <a name="what-is-best-in-life-and-transactions" href="#what-is-best-in-life-and-transactions">\n  </a>\n  What is best in life and transactions?\n</h4>\n\n<p>Database transactions keep changes to disparate records bundled together, ensuring that applications can read and write data without colliding with each other or interleaving their updates in confusing or invalid ways. </p>\n\n<p>The ACID acronym (“atomicity, consistency, isolation, durability”) is commonly used to describe the basic properties of transactions, but doesn’t fully describe what it’s like to use them. In practice, when evaluating transaction implementations, we want to look for:</p>\n\n<ul>\n<li>\n<strong>Consistency level:</strong> higher consistency levels are easier to reason about</li>\n<li>\n<strong>Generality:</strong> fewer special cases in implementation and interface lead to fewer bugs</li>\n<li>\n<strong>Performance:</strong> the less that transactions impact throughput and latency, the better</li>\n<li>\n<strong>Ease-of-use:</strong> writing transactional queries should be straightforward, and reading transactional data should be transparent</li>\n</ul>\n\n<p>We will keep this framework in mind as we discuss the various systems.</p>\n\n<h2>\n  <a name="couchbase" href="#couchbase">\n  </a>\n  Couchbase\n</h2>\n\n<p><a href="https://www.couchbase.com/">Couchbase</a> was originally developed by merging Membase, a fork of Memcache with on-disk durability, with CouchDB, a somewhat experimental document database written in Erlang. As such, it has a relatively tortured development history. It has adopted a relatively tortured transaction model as well.</p>\n\n<p>Couchbase transactions work <a href="https://blog.couchbase.com/distributed-multi-document-acid-transactions/">purely from the client-side</a>. Each Couchbase SDK implements an algorithm that essentially writes a lock record into each shard, then writes uncommitted writes into each document as metadata, then updates the lock records, then moves the metadata into the documents to become the primary data. Other clients that observe document metadata must check the locking document to find out the state of the transaction, and race to clean up unapplied or aborted writes based on wall clock time.</p>\n\n<h4>\n  <a name="acid-properties" href="#acid-properties">\n  </a>\n  ACID properties\n</h4>\n\n<p>Couchbase’s algorithm provides read-committed isolation as far as document reads go, but no isolation at all for <a href="https://docs.couchbase.com/server/current/learn/data/transactions.html#indexes-and-transactions">derived data like indexes</a>, which have no way to tell if data is being modified concurrently or not. It also does not offer snapshot isolation for readers, which means that nobody really has a consistent view of the entire database at any time, and it is vulnerable to clock skew in the locking mechanism.</p>\n\n<p>As far as I can tell, when Couchbase transactions span shards, they are not actually isolated or atomic, because there is no specific reason to assume that readers will observe transaction record state in the same order that writers do, or that a writer will successfully update all locking documents.</p>\n\n<p>Couchbase offers several tunable durability and quorum options that interact with transaction read and write consistency in confusing ways, and the default does not require disk persistence for writes. Finally, multi-region transactions are not supported at all because there is no synchronous multi-region replication.</p>\n\n<p>Couchbase has not verified their transactions under Jepsen, but only done some <a href="https://blog.couchbase.com/introduction-to-jepsen-testing-at-couchbase/">in-house work</a> to verify the basic single-document replication protocol. Ultimately, Couchbase does not offer any meaningful general level of consistency, so maybe there’s nothing to verify. For example, you cannot use this system to implement unique constraints, a very basic goal.</p>\n\n<h4>\n  <a name="interface" href="#interface">\n  </a>\n  Interface\n</h4>\n\n<p>Couchbase has adopted a SQL-like syntax called N1QL and applied the same tactic to <a href="https://blog.couchbase.com/couchbase-transactions-with-n1ql/">transaction support</a>, with explicit START TRANSACTION/COMMIT TRANSACTION statements. Transactions are interactive in that clients can hold them open indefinitely (well, as long as the cleanup window lasts) and interleave them with client-side computation. </p>\n\n<p>Here is a N1QL example:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight sql"><code><span class="k">START</span> <span class="n">TRANSACTION</span><span class="p">;</span>\n<span class="k">SELECT</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">FROM</span> <span class="n">airport</span> <span class="k">WHERE</span> <span class="n">city</span><span class="o">=</span><span class="s1">\'Stanted\'</span><span class="p">;</span>\n<span class="k">UPDATE</span> <span class="n">airport</span> <span class="k">SET</span> <span class="n">city</span><span class="o">=</span><span class="s1">\'London\'</span> <span class="k">WHERE</span> <span class="n">faa</span><span class="o">=</span><span class="s1">\'STN\'</span><span class="p">;</span>\n<span class="k">DELETE</span> <span class="k">FROM</span> <span class="n">airport</span> <span class="k">WHERE</span> <span class="n">city</span><span class="o">=</span><span class="s1">\'London\'</span> <span class="k">AND</span> <span class="n">faa</span> <span class="o">!=</span> <span class="s1">\'STN\'</span><span class="p">;</span>\n<span class="k">COMMIT</span> <span class="n">TRANSACTION</span><span class="p">;</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>This interface is reasonable, although many other Couchbase interfaces, and even other SDKs, are not transaction-aware and will serve stale reads during commits.</p>\n\n<h4>\n  <a name="performance" href="#performance">\n  </a>\n  Performance\n</h4>\n\n<p>Because the transactional operations involve so many additional client-side reads and writes, they are much slower than normal operation, which Couchbase touts as a feature—because you can avoid the slowdown by not using transactions.</p>\n\n<h4>\n  <a name="summary" href="#summary">\n  </a>\n  Summary\n</h4>\n\n<p>So how does Couchbase fare according to our criteria? The consistency level offered is essentially no consistency at all by database standards. Generality is poor since transactions due not affect indexes or non-transactional clients. Theoretical performance is also poor relative to baseline due to the multiphase client-side lock management. Ease-of-use is adequate, though, as long as the interface supports it. </p>\n\n<p>Personally, I feel like Couchbase transactions should really be called batch writes, as they offer essentially none of the properties one would expect from a multi-document transaction.</p>\n\n<h2>\n  <a name="mongodb" href="#mongodb">\n  </a>\n  MongoDB\n</h2>\n\n<p><a href="https://www.mongodb.com/">MongoDB</a> began its life essentially as a JSON database for node.js. Very easy to use for JavaScript developers, it struggled with basic durability until the addition of the WiredTiger storage engine. After many years of preaching that transactions were unnecessary and advocating for extensive data denormalization to compensate, MongoDB capitulated and added transaction support a few years ago.</p>\n\n<p>MongoDB implements a sharded primary-secondary replication system, with a dizzying array of <a href="https://developer.mongodb.com/how-to/global-read-write-concerns/#overriding-global-read-and-write-concerns">tunable read and write consistency levels</a>. Its transactions are implemented via a cluster-wide <a href="https://www.mongodb.com/blog/post/transactions-background-part-4-the-global-logical-clock">hybrid logical clock</a> from which transaction timestamps are derived. Within a shard, transactions are written first to a write-ahead log on the primary node, and then the values of the transactions are written with their timestamps into the storage engine, which offers multi-version concurrency control for snapshot reads. Transactions that span shards have an additional layer of what appears to be two-phase commit coordination.</p>\n\n<h4>\n  <a name="acid-properties" href="#acid-properties">\n  </a>\n  ACID properties\n</h4>\n\n<p>At best, MongoDB offers snapshot isolation. This means that unlike Couchbase, it at least has some hope of being serializable (which basically means transactions get applied in some non-overlapping order, even if it wasn’t the one you would expect).</p>\n\n<p>Unfortunately, the default consistency levels allow reads of committed data to happen before replication has occurred, so dirty reads and lost transactions are possible during failover. Like Couchbase, even this level of fault-intolerant isolation is limited to a single shard. For transactions which span shards, <a href="https://docs.mongodb.com/manual/core/transactions-sharded-clusters/">there is no read-side coordination</a>: readers will observe transactions torn at their shard boundaries, violating snapshot consistency. Even readers within transactions will not see isolated commits of other transactions unless a non-default read consistency level is used.</p>\n\n<p>Unique constraints are supported, but apparently via a different mechanism than transactions as they predate them. It is unclear to me how indexes with unique constraints interact with snapshot isolation within transactions.</p>\n\n<p>MongoDB has been independently tested with Jepsen, but there is <a href="https://jepsen.io/analyses/mongodb-4.2.6">extensive disagreement</a> between the company and the Jepsen team about the correct interpretation of the results. There are <a href="https://docs.mongodb.com/manual/core/transactions/%23transactions-and-write-concern">many combinations</a> of read and write consistency levels that will violate even the most basic transactional properties.</p>\n\n<h4>\n  <a name="interface" href="#interface">\n  </a>\n  Interface\n</h4>\n\n<p>Rather than a true query language, MongoDB implements DSLs in its drivers that follow the same basic syntactic patterns. Beginning and ending a transaction requires creating a session object with correct read and write consistency levels, and then separately beginning a transaction with (possibly different) read and write consistency levels, and then committing the transaction. Naively using the transactional feature will not reliably result in transactional behavior.</p>\n\n<p>Here is a <a href="https://docs.mongodb.com/v4.0/core/transactions/">JavaScript example</a>:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight javascript"><code><span class="nx">session</span> <span class="o">=</span> <span class="nx">db</span><span class="p">.</span><span class="nx">getMongo</span><span class="p">().</span><span class="nx">startSession</span><span class="p">(</span> <span class="p">{</span> <span class="na">readPreference</span><span class="p">:</span> <span class="p">{</span> <span class="na">mode</span><span class="p">:</span> <span class="dl">"</span><span class="s2">primary</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span> <span class="nx">session</span><span class="p">.</span><span class="nx">startTransaction</span><span class="p">(</span> <span class="p">{</span> <span class="na">readConcern</span><span class="p">:</span> <span class="p">{</span> <span class="na">level</span><span class="p">:</span> <span class="dl">"</span><span class="s2">snapshot</span><span class="dl">"</span> <span class="p">},</span> <span class="na">writeConcern</span><span class="p">:</span> <span class="p">{</span> <span class="na">w</span><span class="p">:</span> <span class="dl">"</span><span class="s2">majority</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span>\n<span class="nx">session</span><span class="p">.</span><span class="nx">getDatabase</span><span class="p">(</span><span class="dl">"</span><span class="s2">hr</span><span class="dl">"</span><span class="p">).</span><span class="nx">employees</span><span class="p">.</span><span class="nx">updateOne</span><span class="p">(</span> <span class="p">{</span> <span class="na">employee</span><span class="p">:</span> <span class="mi">3</span> <span class="p">},</span> <span class="p">{</span> <span class="na">$set</span><span class="p">:</span> <span class="p">{</span> <span class="na">status</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Inactive</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span>\n<span class="nx">session</span><span class="p">.</span><span class="nx">getDatabase</span><span class="p">(</span><span class="dl">"</span><span class="s2">reporting</span><span class="dl">"</span><span class="p">).</span><span class="nx">events</span><span class="p">.</span><span class="nx">insertOne</span><span class="p">(</span> <span class="p">{</span> <span class="na">employee</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="na">status</span><span class="p">:</span> <span class="p">{</span> <span class="na">new</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Inactive</span><span class="dl">"</span><span class="p">,</span> <span class="na">old</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Active</span><span class="dl">"</span> <span class="p">}</span> <span class="p">}</span> <span class="p">);</span>\n<span class="nx">session</span><span class="p">.</span><span class="nx">commitTransaction</span><span class="p">();</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>Additionally, out of band coordination, most likely via human beings, is required to make sure that all potential readers of the transactional writes are also transaction-aware.</p>\n\n<h4>\n  <a name="performance" href="#performance">\n  </a>\n  Performance\n</h4>\n\n<p>MongoDB transactions add little overhead to single shard queries in their default configuration, but also don’t really offer any transactional properties. Setting the appropriate read and write consistency levels means that both readers and writers will block on quorum among the primaries and secondaries of the shard. This impacts the latency profile of writes, and the throughput and latency profile of reads, since more nodes have to be queried.</p>\n\n<p>Moving to sharded queries slows down writes substantially due to the extra roundtrips the two-phase model layers on top. Unless transactions and shard keys are carefully designed to avoid this, the performance discontinuity may be unpredictable.</p>\n\n<h4>\n  <a name="summary" href="#summary">\n  </a>\n  Summary\n</h4>\n\n<p>MongoDB’s consistency level is adequate, but the generality is poor because of all the edge cases. Theoretical performance is poor and unpredictable relative to baseline. And due to the confusing interaction of the read, write, and transaction consistency, ease-of-use is also not good, putting aside any issues with the query language itself. </p>\n\n<p>However, I will grant that unlike Couchbase, MongoDB transactions really are transactions.</p>\n\n<h2>\n  <a name="google-cloud-firestore" href="#google-cloud-firestore">\n  </a>\n  Google Cloud Firestore\n</h2>\n\n<p>Some databases are actually domain-specific interfaces to other databases, and <a href="https://firebase.google.com/products/firestore">Firestore</a> is one of them. Firestore is the updated version of <a href="https://firebase.google.com/docs/database">Firebase Realtime Database</a>, a mobile-oriented cloud service that was originally implemented as a service on top of MongoDB. Google acquired Firebase in 2014, and ported the interface, with modifications, to a<a href="https://cloud.google.com/spanner"> Google Spanner</a> backend in 2019. </p>\n\n<p>Firebase implemented an unusual hierarchical data model, somewhat similar to<a href="https://en.wikipedia.org/wiki/MUMPS"> MUMPS</a>. This caused a lot of problems because it was difficult to query and update subtrees of the hierarchy in a predictable and performant way. Nevertheless, treating the entire database as a single document did allow for atomic updates of subtrees. </p>\n\n<p>Firestore improved on the Firebase data model by switching to a <a href="https://firebase.google.com/docs/firestore/data-model">hybrid document-hierarchical model</a>. Instead of a giant tree, the database is now composed of collections, which can contain documents, which can contain subcollections, which can contain subdocuments, more or less indefinitely. This creates natural record boundaries at the document level which corresponds well with the underlying relational model of Spanner. </p>\n\n<p>This data model was influenced by the Google Cloud Datastore data model, an eventually consistent document database originally built for Google App Engine that also predated Google Spanner. In fact, Firestore includes a Datastore compatibility mode.</p>\n\n<h4>\n  <a name="acid-properties" href="#acid-properties">\n  </a>\n  ACID properties\n</h4>\n\n<p>Conceptually, Firestore is rewriting document queries into relational queries for Spanner, and inherits Spanner’s consistency model. Spanner implements<a href="https://fauna.com/blog/a-comparison-of-scalable-database-isolation-levels?utm_source=dev.to&amp;utm_medium=referral&amp;utm_campaign=fauna_blog"> serializability</a> via a multi-phase implementation backed by<a href="https://fauna.com/blog/distributed-consistency-at-scale-spanner-vs-calvin?utm_source=dev.to&amp;utm_medium=referral&amp;utm_campaign=fauna_blog"> physical atomic clocks</a>. Serializability is a very good isolation level.</p>\n\n<p>However, there are some nuances here. Due to its origin as a mobile database, Firestore is designed around mixed client access. Because mobile devices are usually highly latent, Firestore transactions are implemented in mobile clients with client-side <a href="https://firebase.google.com/docs/firestore/transaction-data-contention#concurrency-controls">optimistic concurrency control</a>. Effectively, all mobile transactions are rewritten into a series of incremental reads, and then a transactional compare-and-swap operation for the writes. This has a number of implications:</p>\n\n<ul>\n<li>In a Firestore transaction, <a href="https://firebase.google.com/docs/firestore/manage-data/transactions#transaction_failure">all reads are executed before all writes</a>\n</li>\n<li>Reads cannot see the result of writes within the transaction</li>\n<li>A transaction, including its client side logic, may run multiple times, so side effects are dangerous</li>\n</ul>\n\n<p>On the other hand, server-side transactions use a more typical <a href="https://firebase.google.com/docs/firestore/transaction-data-contention#concurrency-controls">pessimistic relational lock</a>. They open a transaction, do some work, and then commit it. </p>\n\n<p>Read-only queries appear to default to strong consistency, with no way to drop to snapshot consistency like Spanner, unless you use the alternate Datastore API.</p>\n\n<p>Firestore mobile clients also use a local cache for offline syncing. This means that it is possible for several things to happen when the client is offline:</p>\n\n<ul>\n<li>Stale reads will be served from cache</li>\n<li>Non-transactional writes and write-only transactions will be buffered and submitted when the client reconnects</li>\n<li>Read-write transactions will error out</li>\n</ul>\n\n<p>Although these are desirable behaviors for Firestore, they violate the consistency model. </p>\n\n<p>Firestore has not been verified with Jepsen, but there is no serious doubt in the industry that Spanner’s <a href="https://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf">implementation</a> is sound. Nevertheless the mobile clients clearly violate the database’s consistency guarantees. </p>\n\n<h4>\n  <a name="interface" href="#interface">\n  </a>\n  Interface\n</h4>\n\n<p>Firestore’s interface is composed around transaction lambdas, which can intermix client-side compute with simple calls for database reads and writes. As discussed above, whether the transaction executes optimistically and potentially multiple times, or pessimistically and only once, depends on whether a server or mobile driver is used. </p>\n\n<p>Here is a <a href="https://firebase.google.com/docs/firestore/manage-data/transactions">JavaScript example</a>:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight javascript"><code><span class="nx">db</span><span class="p">.</span><span class="nx">runTransaction</span><span class="p">((</span><span class="nx">transaction</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>\n    <span class="k">return</span> <span class="nx">transaction</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">collection</span><span class="p">(</span><span class="dl">"</span><span class="s2">cities</span><span class="dl">"</span><span class="p">).</span><span class="nx">doc</span><span class="p">(</span><span class="dl">"</span><span class="s2">SF</span><span class="dl">"</span><span class="p">)).</span><span class="nx">then</span><span class="p">((</span><span class="nx">sfDoc</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>\n        <span class="kd">var</span> <span class="nx">newPopulation</span> <span class="o">=</span> <span class="nx">sfDoc</span><span class="p">.</span><span class="nx">data</span><span class="p">().</span><span class="nx">population</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>\n        <span class="nx">transaction</span><span class="p">.</span><span class="nx">update</span><span class="p">(</span><span class="nx">db</span><span class="p">.</span><span class="nx">collection</span><span class="p">(</span><span class="dl">"</span><span class="s2">cities</span><span class="dl">"</span><span class="p">).</span><span class="nx">doc</span><span class="p">(</span><span class="dl">"</span><span class="s2">SF</span><span class="dl">"</span><span class="p">),</span> <span class="p">{</span> <span class="na">population</span><span class="p">:</span> <span class="nx">newPopulation</span> <span class="p">});</span>\n    <span class="p">});</span>\n<span class="p">});</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>Like MongoDB, Firestore does not offer a true query language, and supports quite a bit less in terms of query sophistication. As far as transactions go, this interface is reasonable, but the inability to read your own writes within a transaction is an inconvenience.</p>\n\n<p>Firestore appears to <a href="https://firebase.google.com/docs/firestore/query-data/indexing">implement its indexes</a> as separate tables within Spanner. It requires the user to explicitly lay out the index data to support the application’s query patterns, rather than delegating to indexed relational queries underneath. Firestore indexes every individual field within a document by default, to make naive querying easier. This comes at a cost: transaction sizes by default are relatively large. It is possible to manually exempt fields from indexing.</p>\n\n<h4>\n  <a name="performance" href="#performance">\n  </a>\n  Performance\n</h4>\n\n<p>Firestore offers many Google Cloud single-datacenter <a href="https://firebase.google.com/docs/firestore/locations">locations</a>, but only multi-datacenter support in the US and Europe. Multi-datacenter support comes with a higher cost and higher write latency, but potentially lower read latency depending on client location.  </p>\n\n<p>Firestore transactions run in Spanner’s default strong consistency mode, which is fast, especially for single-datacenter databases. Multi-datacenter transactions must block on a write quorum for every shard in the query. How indexing affects the shard layout within a transaction is unclear.</p>\n\n<h4>\n  <a name="summary" href="#summary">\n  </a>\n  Summary\n</h4>\n\n<p>Firestore’s consistency model, after the rewrite onto Spanner, is very good. Generality is optimal with no meaningful edge cases except for well-documented and predictable ones. However, ease of use could be better. Performance is good. But the data model and indexing scheme are strange, even if they are familiar to longtime Firebase users. And the lack of query flexibility limits utility compared to something like SQL or N1QL. </p>\n\n<h2>\n  <a name="fauna" href="#fauna">\n  </a>\n  Fauna\n</h2>\n\n<p>Fauna is a database as an API. Is it a document database? Yes, and it is also a document-relational database, since it offers not just transactions, but foreign keys, views, and joins. It supports a GraphQL interface and its own query language FQL, and also provides temporal access to data history.</p>\n\n<p>Fauna implements a unique single-phase transaction architecture<a href="https://fauna.com/blog/consistency-without-clocks-faunadb-transaction-protocol?utm_source=dev.to&amp;utm_medium=referral&amp;utm_campaign=fauna_blog"> based on Calvin</a>. Like MongoDB, its data model is based on documents and collections. Like Spanner, it offers a best-in-class consistency model. Like Firestore, it has a serverless operational model. And unlike other document databases, it offers the ability to compute close to the data with a rich standard library and function model—as rich or richer than SQL. </p>\n\n<h4>\n  <a name="acid-properties" href="#acid-properties">\n  </a>\n  ACID properties\n</h4>\n\n<p>In Fauna, every query is a transaction. Read-write transactions are <a href="https://docs.fauna.com/fauna/current/concepts/isolation_levels.html?utm_source=dev.to&amp;utm_medium=referral&amp;utm_campaign=fauna_blog">strictly serializable</a> via the transaction log, which offers a partitioned and replicated commit point without coordination with the data replicas or with atomic clocks. Read-only transactions are serializable via careful timestamp management within the database and the database drivers, and in practice, indistinguishable from strict serializability. </p>\n\n<p>Unlike the other databases here, there are no default consistency level concerns or driver features that can violate the consistency model. Transactions can read their own writes as well. </p>\n\n<p>The one thing transactions can’t do is client-side compute; instead, Fauna focuses on in-database computation, with a Turing-complete query language called FQL and support for complex branching and looping, math and string manipulation, and user-defined functions.</p>\n\n<p>Fauna’s consistency model and implementation have been independently<a href="https://fauna.com/blog/faunadbs-official-jepsen-results?utm_source=dev.to&amp;utm_medium=referral&amp;utm_campaign=fauna_blog"> verified with Jepsen</a> and found to be sound, although the analysis is out of date and the database is much improved since.</p>\n\n<h4>\n  <a name="interface" href="#interface">\n  </a>\n  Interface\n</h4>\n\n<p>Like Firestore, Fauna’s interface is composed around query lambdas. However, within the lambda, the user cannot make application-side calls with side effects or that have read or write dependencies. Instead, this work is delegated to the database itself. </p>\n\n<p>Here is a<a href="https://fireship.io/lessons/fauna-db-quickstart/"> Javascript example</a>:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight javascript"><code><span class="k">await</span> <span class="nx">client</span><span class="p">.</span><span class="nx">query</span><span class="p">(</span>\n        <span class="nx">Create</span><span class="p">(</span>\n            <span class="nx">Collection</span><span class="p">(</span><span class="dl">\'</span><span class="s1">relationships</span><span class="dl">\'</span><span class="p">),</span>\n            <span class="nx">follower</span><span class="p">:</span> <span class="nx">Call</span><span class="p">(</span><span class="nx">Fn</span><span class="p">(</span><span class="dl">"</span><span class="s2">getUser</span><span class="dl">"</span><span class="p">),</span> <span class="dl">\'</span><span class="s1">alice</span><span class="dl">\'</span><span class="p">),</span>\n            <span class="nx">followee</span><span class="p">:</span> <span class="nx">Call</span><span class="p">(</span><span class="nx">Fn</span><span class="p">(</span><span class="dl">"</span><span class="s2">getUser</span><span class="dl">"</span><span class="p">),</span> <span class="dl">\'</span><span class="s1">bob</span><span class="dl">\'</span><span class="p">)</span>\n        <span class="p">)</span>\n    <span class="p">)</span>\n<span class="p">});</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>This query is transactional by default and refers to a user-defined database function “getUser”, part of this database\'s schema, to simplify the logic. </p>\n\n<p>Although side-effects and computation on dependencies are not allowed, client language features can still be used for query composition; for example, defining a subquery ahead of time and referring to it with a local variable.</p>\n\n<p>Although Fauna encourages an index-per-query pattern similar to Firebase, it is not required, and Fauna does not automatically create multiple default indexes for documents.</p>\n\n<h4>\n  <a name="performance" href="#performance">\n  </a>\n  Performance\n</h4>\n\n<p>Fauna is designed to minimize latency in <a href="https://fauna.com/blog/meeting-data-residence-and-increasing-performance-with-fauna-region-groups?utm_source=dev.to&amp;utm_medium=referral&amp;utm_campaign=fauna_blog">multi-datacenter replication scenarios</a>. A read-write transaction only requires one roundtrip within a majority of replication sites, and read-only transactions do not require any round trips at all. This makes the performance profile similar to Spanner and presumably to Firestore as well.</p>\n\n<p>Fauna does not yet offer single-datacenter region configurations, so its latency will be higher than other databases configured without multi-region replication.</p>\n\n<p>Couchbase, MongoDB, and Firestore all use an interactive session model: reads and  writes are issued incrementally, and compute is run in the client. This means that latency stacks up more or less linearly with the number of database operations within the transaction. </p>\n\n<p>Fauna, on the other hand, includes a <a href="https://docs.fauna.com/fauna/current/api/fql/cheat_sheet?utm_source=dev.to&amp;utm_medium=referral&amp;utm_campaign=fauna_blog">comprehensive standard library</a> within FQL itself. This allows the database to execute business logic colocated with the data, and also to guarantee that the logic runs only once and is side-effect free. </p>\n\n<h4>\n  <a name="summary" href="#summary">\n  </a>\n  Summary\n</h4>\n\n<p>At Fauna, we want to give developers the best database infrastructure possible delivered by the ideal APIs, especially document APIs like GraphQL and FQL. The Fauna architecture offers the highest level of consistency, strict serializibility,  without edge cases. Performance is very good and theoretically optimal in multi-region scenarios. And since Fauna is delivered as an API, our customers are responsible for no operational tasks of any kind, even though the underlying service is continuously being improved. </p>\n\n<p>Although FQL is unfamiliar to most, we are working hard to improve its ease of use and expand its capability. Certainly taking advantage of its transactionality is trivial because everything is a transaction by default, with no “escape routes” that could lead to potential correctness problems. </p>\n\n<p>If you are looking for a document database, I hope this article helps guide you in the right direction. And if you want to never have to manage that  database again, don’t forget to <a href="https://dashboard.fauna.com/accounts/register?utm_source=dev.to&amp;utm_medium=referral&amp;utm_campaign=fauna_blog">give Fauna a try</a>. </p>\n\n',s.body_markdown='_This is the first in a series of posts comparing different aspects of modern operational databases. Written by Evan Weaver, CTO and co-founder of Fauna, it originally appeared on www.fauna.com/blog._\n\nA distributed document database is a NoSQL database that stores semi-structured data, usually in a format similar to JSON, and is horizontally scalable across multiple machines. Document databases are very convenient for modern application development, because modern application frameworks and languages are also based on semi-structured objects instead of tabular data. They are often a better fit than a SQL database, where rigid schemas resist object evolution, and complex client-side object-relational mappers simulate an object-oriented interface with incomplete success.\n\nIn the distant past of the 2010’s, distributed document databases didn’t offer transaction support, instead implementing various forms of eventual consistency. Vendors and open-source maintainers promoted the idea that transactionality was an unnecessary, complexifying feature that damaged scalability and availability—and many claimed that adding it to their systems was [impossible](https://stackoverflow.com/questions/16779348/does-the-cap-theorem-imply-that-acid-is-not-possible-for-distributed-databases).\n\nTime has gone by and things are very different now. The benefits of transactionality are widely accepted outside of the context of SQL and [even databases in general](https://docs.microsoft.com/en-us/azure/architecture/reference-architectures/saga/saga), and key distributed systems problems have [been solved](https://fauna.com/blog/distributed-consistency-at-scale-spanner-vs-calvin?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog). All modern distributed document databases now offer some form of transactionality, but their implementations and characteristics vary widely.\n\nRead on to explore the differences between Couchbase, MongoDB, Google Cloud Firestore, and Fauna.\n\n#### What is best in life and transactions?\n\n Database transactions keep changes to disparate records bundled together, ensuring that applications can read and write data without colliding with each other or interleaving their updates in confusing or invalid ways. \n\nThe ACID acronym (“atomicity, consistency, isolation, durability”) is commonly used to describe the basic properties of transactions, but doesn’t fully describe what it’s like to use them. In practice, when evaluating transaction implementations, we want to look for:\n\n* **Consistency level:** higher consistency levels are easier to reason about\n* **Generality:** fewer special cases in implementation and interface lead to fewer bugs\n* **Performance:** the less that transactions impact throughput and latency, the better\n* **Ease-of-use:** writing transactional queries should be straightforward, and reading transactional data should be transparent\n\nWe will keep this framework in mind as we discuss the various systems.\n\n## Couchbase\n\n[Couchbase](https://www.couchbase.com/) was originally developed by merging Membase, a fork of Memcache with on-disk durability, with CouchDB, a somewhat experimental document database written in Erlang. As such, it has a relatively tortured development history. It has adopted a relatively tortured transaction model as well.\n\nCouchbase transactions work [purely from the client-side](https://blog.couchbase.com/distributed-multi-document-acid-transactions/). Each Couchbase SDK implements an algorithm that essentially writes a lock record into each shard, then writes uncommitted writes into each document as metadata, then updates the lock records, then moves the metadata into the documents to become the primary data. Other clients that observe document metadata must check the locking document to find out the state of the transaction, and race to clean up unapplied or aborted writes based on wall clock time.\n\n#### ACID properties\n\nCouchbase’s algorithm provides read-committed isolation as far as document reads go, but no isolation at all for [derived data like indexes](https://docs.couchbase.com/server/current/learn/data/transactions.html#indexes-and-transactions), which have no way to tell if data is being modified concurrently or not. It also does not offer snapshot isolation for readers, which means that nobody really has a consistent view of the entire database at any time, and it is vulnerable to clock skew in the locking mechanism.\n\n As far as I can tell, when Couchbase transactions span shards, they are not actually isolated or atomic, because there is no specific reason to assume that readers will observe transaction record state in the same order that writers do, or that a writer will successfully update all locking documents.\n\nCouchbase offers several tunable durability and quorum options that interact with transaction read and write consistency in confusing ways, and the default does not require disk persistence for writes. Finally, multi-region transactions are not supported at all because there is no synchronous multi-region replication.\n\nCouchbase has not verified their transactions under Jepsen, but only done some [in-house work](https://blog.couchbase.com/introduction-to-jepsen-testing-at-couchbase/) to verify the basic single-document replication protocol. Ultimately, Couchbase does not offer any meaningful general level of consistency, so maybe there’s nothing to verify. For example, you cannot use this system to implement unique constraints, a very basic goal.\n\n#### Interface\n\nCouchbase has adopted a SQL-like syntax called N1QL and applied the same tactic to [transaction support](https://blog.couchbase.com/couchbase-transactions-with-n1ql/), with explicit START TRANSACTION/COMMIT TRANSACTION statements. Transactions are interactive in that clients can hold them open indefinitely (well, as long as the cleanup window lasts) and interleave them with client-side computation. \n\nHere is a N1QL example: \n\n```sql\nSTART TRANSACTION;\nSELECT COUNT(*) FROM airport WHERE city=\'Stanted\';\nUPDATE airport SET city=\'London\' WHERE faa=\'STN\';\nDELETE FROM airport WHERE city=\'London\' AND faa != \'STN\';\nCOMMIT TRANSACTION;\n```\n\nThis interface is reasonable, although many other Couchbase interfaces, and even other SDKs, are not transaction-aware and will serve stale reads during commits.\n\n#### Performance\n\nBecause the transactional operations involve so many additional client-side reads and writes, they are much slower than normal operation, which Couchbase touts as a feature—because you can avoid the slowdown by not using transactions.\n\n#### Summary\n\nSo how does Couchbase fare according to our criteria? The consistency level offered is essentially no consistency at all by database standards. Generality is poor since transactions due not affect indexes or non-transactional clients. Theoretical performance is also poor relative to baseline due to the multiphase client-side lock management. Ease-of-use is adequate, though, as long as the interface supports it. \n\nPersonally, I feel like Couchbase transactions should really be called batch writes, as they offer essentially none of the properties one would expect from a multi-document transaction.\n\n## MongoDB\n\n[MongoDB](https://www.mongodb.com/) began its life essentially as a JSON database for node.js. Very easy to use for JavaScript developers, it struggled with basic durability until the addition of the WiredTiger storage engine. After many years of preaching that transactions were unnecessary and advocating for extensive data denormalization to compensate, MongoDB capitulated and added transaction support a few years ago.\n\nMongoDB implements a sharded primary-secondary replication system, with a dizzying array of [tunable read and write consistency levels](https://developer.mongodb.com/how-to/global-read-write-concerns/#overriding-global-read-and-write-concerns). Its transactions are implemented via a cluster-wide [hybrid logical clock](https://www.mongodb.com/blog/post/transactions-background-part-4-the-global-logical-clock) from which transaction timestamps are derived. Within a shard, transactions are written first to a write-ahead log on the primary node, and then the values of the transactions are written with their timestamps into the storage engine, which offers multi-version concurrency control for snapshot reads. Transactions that span shards have an additional layer of what appears to be two-phase commit coordination.\n\n#### ACID properties\n\nAt best, MongoDB offers snapshot isolation. This means that unlike Couchbase, it at least has some hope of being serializable (which basically means transactions get applied in some non-overlapping order, even if it wasn’t the one you would expect).\n\nUnfortunately, the default consistency levels allow reads of committed data to happen before replication has occurred, so dirty reads and lost transactions are possible during failover. Like Couchbase, even this level of fault-intolerant isolation is limited to a single shard. For transactions which span shards, [there is no read-side coordination](https://docs.mongodb.com/manual/core/transactions-sharded-clusters/): readers will observe transactions torn at their shard boundaries, violating snapshot consistency. Even readers within transactions will not see isolated commits of other transactions unless a non-default read consistency level is used.\n\nUnique constraints are supported, but apparently via a different mechanism than transactions as they predate them. It is unclear to me how indexes with unique constraints interact with snapshot isolation within transactions.\n\nMongoDB has been independently tested with Jepsen, but there is [extensive disagreement](https://jepsen.io/analyses/mongodb-4.2.6) between the company and the Jepsen team about the correct interpretation of the results. There are [many combinations](https://docs.mongodb.com/manual/core/transactions/%23transactions-and-write-concern) of read and write consistency levels that will violate even the most basic transactional properties.\n\n#### Interface\n\nRather than a true query language, MongoDB implements DSLs in its drivers that follow the same basic syntactic patterns. Beginning and ending a transaction requires creating a session object with correct read and write consistency levels, and then separately beginning a transaction with (possibly different) read and write consistency levels, and then committing the transaction. Naively using the transactional feature will not reliably result in transactional behavior.\n\nHere is a [JavaScript example](https://docs.mongodb.com/v4.0/core/transactions/):\n\n```js\nsession = db.getMongo().startSession( { readPreference: { mode: "primary" } } ); session.startTransaction( { readConcern: { level: "snapshot" }, writeConcern: { w: "majority" } } );\nsession.getDatabase("hr").employees.updateOne( { employee: 3 }, { $set: { status: "Inactive" } } );\nsession.getDatabase("reporting").events.insertOne( { employee: 3, status: { new: "Inactive", old: "Active" } } );\nsession.commitTransaction();\n```\n\nAdditionally, out of band coordination, most likely via human beings, is required to make sure that all potential readers of the transactional writes are also transaction-aware.\n\n#### Performance\n\nMongoDB transactions add little overhead to single shard queries in their default configuration, but also don’t really offer any transactional properties. Setting the appropriate read and write consistency levels means that both readers and writers will block on quorum among the primaries and secondaries of the shard. This impacts the latency profile of writes, and the throughput and latency profile of reads, since more nodes have to be queried.\n\nMoving to sharded queries slows down writes substantially due to the extra roundtrips the two-phase model layers on top. Unless transactions and shard keys are carefully designed to avoid this, the performance discontinuity may be unpredictable.\n\n#### Summary\n\nMongoDB’s consistency level is adequate, but the generality is poor because of all the edge cases. Theoretical performance is poor and unpredictable relative to baseline. And due to the confusing interaction of the read, write, and transaction consistency, ease-of-use is also not good, putting aside any issues with the query language itself. \n\nHowever, I will grant that unlike Couchbase, MongoDB transactions really are transactions.\n\n## Google Cloud Firestore\n\nSome databases are actually domain-specific interfaces to other databases, and [Firestore](https://firebase.google.com/products/firestore) is one of them. Firestore is the updated version of [Firebase Realtime Database](https://firebase.google.com/docs/database), a mobile-oriented cloud service that was originally implemented as a service on top of MongoDB. Google acquired Firebase in 2014, and ported the interface, with modifications, to a[ Google Spanner](https://cloud.google.com/spanner) backend in 2019. \n\nFirebase implemented an unusual hierarchical data model, somewhat similar to[ MUMPS](https://en.wikipedia.org/wiki/MUMPS). This caused a lot of problems because it was difficult to query and update subtrees of the hierarchy in a predictable and performant way. Nevertheless, treating the entire database as a single document did allow for atomic updates of subtrees. \n\nFirestore improved on the Firebase data model by switching to a [hybrid document-hierarchical model](https://firebase.google.com/docs/firestore/data-model). Instead of a giant tree, the database is now composed of collections, which can contain documents, which can contain subcollections, which can contain subdocuments, more or less indefinitely. This creates natural record boundaries at the document level which corresponds well with the underlying relational model of Spanner. \n\nThis data model was influenced by the Google Cloud Datastore data model, an eventually consistent document database originally built for Google App Engine that also predated Google Spanner. In fact, Firestore includes a Datastore compatibility mode.\n\n#### ACID properties\n\nConceptually, Firestore is rewriting document queries into relational queries for Spanner, and inherits Spanner’s consistency model. Spanner implements[ serializability](https://fauna.com/blog/a-comparison-of-scalable-database-isolation-levels?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog) via a multi-phase implementation backed by[ physical atomic clocks](https://fauna.com/blog/distributed-consistency-at-scale-spanner-vs-calvin?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog). Serializability is a very good isolation level.\n\nHowever, there are some nuances here. Due to its origin as a mobile database, Firestore is designed around mixed client access. Because mobile devices are usually highly latent, Firestore transactions are implemented in mobile clients with client-side [optimistic concurrency control](https://firebase.google.com/docs/firestore/transaction-data-contention#concurrency-controls). Effectively, all mobile transactions are rewritten into a series of incremental reads, and then a transactional compare-and-swap operation for the writes. This has a number of implications:\n\n* In a Firestore transaction, [all reads are executed before all writes](https://firebase.google.com/docs/firestore/manage-data/transactions#transaction_failure)\n* Reads cannot see the result of writes within the transaction\n* A transaction, including its client side logic, may run multiple times, so side effects are dangerous\n\nOn the other hand, server-side transactions use a more typical [pessimistic relational lock](https://firebase.google.com/docs/firestore/transaction-data-contention#concurrency-controls). They open a transaction, do some work, and then commit it. \n\nRead-only queries appear to default to strong consistency, with no way to drop to snapshot consistency like Spanner, unless you use the alternate Datastore API.\n\nFirestore mobile clients also use a local cache for offline syncing. This means that it is possible for several things to happen when the client is offline:\n\n* Stale reads will be served from cache\n* Non-transactional writes and write-only transactions will be buffered and submitted when the client reconnects\n* Read-write transactions will error out\n\nAlthough these are desirable behaviors for Firestore, they violate the consistency model. \n\nFirestore has not been verified with Jepsen, but there is no serious doubt in the industry that Spanner’s [implementation](https://static.googleusercontent.com/media/research.google.com/en//archive/spanner-osdi2012.pdf) is sound. Nevertheless the mobile clients clearly violate the database’s consistency guarantees. \n\n#### Interface\n\nFirestore’s interface is composed around transaction lambdas, which can intermix client-side compute with simple calls for database reads and writes. As discussed above, whether the transaction executes optimistically and potentially multiple times, or pessimistically and only once, depends on whether a server or mobile driver is used. \n\nHere is a [JavaScript example](https://firebase.google.com/docs/firestore/manage-data/transactions):\n\n```js\ndb.runTransaction((transaction) => {\n    return transaction.get(db.collection("cities").doc("SF")).then((sfDoc) => {\n        var newPopulation = sfDoc.data().population + 1;\n        transaction.update(db.collection("cities").doc("SF"), { population: newPopulation });\n    });\n});\n```\n\nLike MongoDB, Firestore does not offer a true query language, and supports quite a bit less in terms of query sophistication. As far as transactions go, this interface is reasonable, but the inability to read your own writes within a transaction is an inconvenience.\n\nFirestore appears to [implement its indexes](https://firebase.google.com/docs/firestore/query-data/indexing) as separate tables within Spanner. It requires the user to explicitly lay out the index data to support the application’s query patterns, rather than delegating to indexed relational queries underneath. Firestore indexes every individual field within a document by default, to make naive querying easier. This comes at a cost: transaction sizes by default are relatively large. It is possible to manually exempt fields from indexing.\n\n#### Performance\n\nFirestore offers many Google Cloud single-datacenter [locations](https://firebase.google.com/docs/firestore/locations), but only multi-datacenter support in the US and Europe. Multi-datacenter support comes with a higher cost and higher write latency, but potentially lower read latency depending on client location.  \n\nFirestore transactions run in Spanner’s default strong consistency mode, which is fast, especially for single-datacenter databases. Multi-datacenter transactions must block on a write quorum for every shard in the query. How indexing affects the shard layout within a transaction is unclear.\n\n#### Summary\n\nFirestore’s consistency model, after the rewrite onto Spanner, is very good. Generality is optimal with no meaningful edge cases except for well-documented and predictable ones. However, ease of use could be better. Performance is good. But the data model and indexing scheme are strange, even if they are familiar to longtime Firebase users. And the lack of query flexibility limits utility compared to something like SQL or N1QL. \n\n## Fauna\n\nFauna is a database as an API. Is it a document database? Yes, and it is also a document-relational database, since it offers not just transactions, but foreign keys, views, and joins. It supports a GraphQL interface and its own query language FQL, and also provides temporal access to data history.\n\nFauna implements a unique single-phase transaction architecture[ based on Calvin](https://fauna.com/blog/consistency-without-clocks-faunadb-transaction-protocol?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog). Like MongoDB, its data model is based on documents and collections. Like Spanner, it offers a best-in-class consistency model. Like Firestore, it has a serverless operational model. And unlike other document databases, it offers the ability to compute close to the data with a rich standard library and function model—as rich or richer than SQL. \n\n#### ACID properties\n\nIn Fauna, every query is a transaction. Read-write transactions are [strictly serializable](https://docs.fauna.com/fauna/current/concepts/isolation_levels.html?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog) via the transaction log, which offers a partitioned and replicated commit point without coordination with the data replicas or with atomic clocks. Read-only transactions are serializable via careful timestamp management within the database and the database drivers, and in practice, indistinguishable from strict serializability. \n\nUnlike the other databases here, there are no default consistency level concerns or driver features that can violate the consistency model. Transactions can read their own writes as well. \n\nThe one thing transactions can’t do is client-side compute; instead, Fauna focuses on in-database computation, with a Turing-complete query language called FQL and support for complex branching and looping, math and string manipulation, and user-defined functions.\n\nFauna’s consistency model and implementation have been independently[ verified with Jepsen](https://fauna.com/blog/faunadbs-official-jepsen-results?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog) and found to be sound, although the analysis is out of date and the database is much improved since.\n\n#### Interface\n\nLike Firestore, Fauna’s interface is composed around query lambdas. However, within the lambda, the user cannot make application-side calls with side effects or that have read or write dependencies. Instead, this work is delegated to the database itself. \n\nHere is a[ Javascript example](https://fireship.io/lessons/fauna-db-quickstart/):\n\n```js\nawait client.query(\n        Create(\n            Collection(\'relationships\'),\n            follower: Call(Fn("getUser"), \'alice\'),\n            followee: Call(Fn("getUser"), \'bob\')\n        )\n    )\n});\n```\n\nThis query is transactional by default and refers to a user-defined database function “getUser”, part of this database\'s schema, to simplify the logic. \n\nAlthough side-effects and computation on dependencies are not allowed, client language features can still be used for query composition; for example, defining a subquery ahead of time and referring to it with a local variable.\n\nAlthough Fauna encourages an index-per-query pattern similar to Firebase, it is not required, and Fauna does not automatically create multiple default indexes for documents.\n\n#### Performance\n\nFauna is designed to minimize latency in [multi-datacenter replication scenarios](https://fauna.com/blog/meeting-data-residence-and-increasing-performance-with-fauna-region-groups?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog). A read-write transaction only requires one roundtrip within a majority of replication sites, and read-only transactions do not require any round trips at all. This makes the performance profile similar to Spanner and presumably to Firestore as well.\n\nFauna does not yet offer single-datacenter region configurations, so its latency will be higher than other databases configured without multi-region replication.\n\nCouchbase, MongoDB, and Firestore all use an interactive session model: reads and  writes are issued incrementally, and compute is run in the client. This means that latency stacks up more or less linearly with the number of database operations within the transaction. \n\nFauna, on the other hand, includes a [comprehensive standard library](https://docs.fauna.com/fauna/current/api/fql/cheat_sheet?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog) within FQL itself. This allows the database to execute business logic colocated with the data, and also to guarantee that the logic runs only once and is side-effect free. \n\n#### Summary\n\nAt Fauna, we want to give developers the best database infrastructure possible delivered by the ideal APIs, especially document APIs like GraphQL and FQL. The Fauna architecture offers the highest level of consistency, strict serializibility,  without edge cases. Performance is very good and theoretically optimal in multi-region scenarios. And since Fauna is delivered as an API, our customers are responsible for no operational tasks of any kind, even though the underlying service is continuously being improved. \n\nAlthough FQL is unfamiliar to most, we are working hard to improve its ease of use and expand its capability. Certainly taking advantage of its transactionality is trivial because everything is a transaction by default, with no “escape routes” that could lead to potential correctness problems. \n\nIf you are looking for a document database, I hope this article helps guide you in the right direction. And if you want to never have to manage that  database again, don’t forget to [give Fauna a try](https://dashboard.fauna.com/accounts/register?utm_source=dev.to&utm_medium=referral&utm_campaign=fauna_blog). \n',s.user={name:"Fauna",username:"fauna_admin",twitter_username:e,github_username:a,website_url:"https://fauna.com",profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s--Qo2AjKRX--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/220097/6333f971-f032-4097-a7c8-64749ae2630c.png",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--NzoFB6fZ--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/220097/6333f971-f032-4097-a7c8-64749ae2630c.png"},s.organization={name:"Fauna, Inc.",username:e,slug:e,profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s--SGEkZxB0--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/1138/dba4b734-81c2-404c-b23e-9608ae98ee49.png",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--IYWG4g54--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/1138/dba4b734-81c2-404c-b23e-9608ae98ee49.png"},{layout:"default",data:[{}],fetch:{"data-v-70afb46a:0":{article:s}},error:a,state:{currentArticle:s},serverRendered:!0,routePath:"/fauna_admin/803635",config:{_app:{basePath:"/nuxtstop/",assetsPath:"/nuxtstop/_nuxt/",cdnURL:a}}}}(null,"fauna","2021-08-25T23:14:18Z",{})</script><script src="/nuxtstop/_nuxt/f6e87fb.js" defer></script><script src="/nuxtstop/_nuxt/dc9ce94.js" defer></script><script src="/nuxtstop/_nuxt/6474719.js" defer></script><script src="/nuxtstop/_nuxt/9b75090.js" defer></script><script src="/nuxtstop/_nuxt/18df600.js" defer></script>
  </body>
</html>
