<!doctype html>
<html data-n-head-ssr lang="en" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>How to Model Your Gitops Environments and Promote Releases between Them</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content="Using Nuxt.js fetch() hook to build dev.to with a new look"><meta data-n-head="ssr" name="format-detection" content="telephone=no"><base href="/nuxtstop/"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:400,500,600&display=swap"><link rel="preload" href="/nuxtstop/_nuxt/f6e87fb.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/6474719.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/9b75090.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/18df600.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/dc9ce94.js" as="script"><style data-vue-ssr-id="c650fd98:0 af4684f0:0 a9c71758:0 dcafa518:0 4b9cec49:0 b093d766:0 9d98bcb4:0 6b6a11ea:0 0248ed80:0 ea8e4264:0">html{box-sizing:border-box;font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}*,:after,:before{box-sizing:inherit}html{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,:after,:before{border:0 solid #e0e0e0}blockquote,body,dd,dl,figure,h1,h2,h3,h4,h5,h6,p,pre{margin:0}button{background:0 0;padding:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset,ol,ul{margin:0;padding:0}ol,ul{list-style:none}hr{border-width:1px}img{border-style:solid}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:inherit;opacity:.5}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:inherit;opacity:.5}input::placeholder,textarea::placeholder{color:inherit;opacity:.5}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit;font-family:sans-serif}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit;font-family:inherit;font-size:100%}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;overflow:auto;word-break:break-word;white-space:normal}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}html{height:100%;font-size:18px;-ms-overflow-style:scrollbar;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none}@media(min-width:640px){html{font-size:20px}}body{height:100%;min-width:320px;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:400;line-height:1.5;color:#000;background-color:#eff4f7;-webkit-text-rendering:optimizeLegibility;text-rendering:optimizeLegibility;font-synthesis:none;font-kerning:normal;font-feature-settings:"normal","kern";-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-overflow-scrolling:touch;overflow-x:hidden;overflow-y:scroll}h1,h2,h3,h4,h5,h6{color:#000;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:600;font-feature-settings:"normal";line-height:1.2}pre{background:#29292e;border-radius:2px;overflow:auto;padding:1rem;color:#eff1f9;line-height:1.42em;font-size:13px}@media screen and (min-width:380px){pre{font-size:15px}}pre code{background:#29292e;color:#eff0f9;white-space:pre}div.highlight pre.highlight code{font-size:inherit;padding:0}div.inner-comment div.body div.highlight pre.highlight{background:#29292e}div.inner-comment div.body div.highlight pre.highlight code{font-size:inherit;white-space:inherit;background:inherit;color:inherit}.highlight .hll{background-color:#49483e}.highlight{background:#29292e;color:#f8f8f2}.highlight .c{color:grey}.highlight .err{text-shadow:0 0 7px #f9690e}.highlight .k{color:#f39c12}.highlight .l{color:plum}.highlight .n{color:#f8f8f2}.highlight .o{color:#f9690e}.highlight .p{color:#f8f8f2}.highlight .c1,.highlight .ch,.highlight .cm,.highlight .cp,.highlight .cpf,.highlight .cs{color:grey}.highlight .gd{color:#f9690e}.highlight .ge{font-style:italic}.highlight .gi{color:#7ed07e}.highlight .gs{font-weight:700}.highlight .gu{color:grey}.highlight .kc,.highlight .kd{color:#f39c12}.highlight .kn{color:#f9690e}.highlight .kp,.highlight .kr,.highlight .kt{color:#f39c12}.highlight .ld{color:#f2ca27}.highlight .m{color:plum}.highlight .s{color:#f2ca27}.highlight .na{color:#7ed07e}.highlight .nb{color:#f8f8f2}.highlight .nc{color:#7ed07e}.highlight .no{color:#f39c12}.highlight .nd{color:#7ed07e}.highlight .ni{color:#f8f8f2}.highlight .ne,.highlight .nf{color:#7ed07e}.highlight .nl,.highlight .nn{color:#f8f8f2}.highlight .nx{color:#7ed07e}.highlight .py{color:#f8f8f2}.highlight .nt{color:#f9690e}.highlight .nv{color:#f8f8f2}.highlight .ow{color:#f9690e}.highlight .w{color:#f8f8f2}.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo{color:plum}.highlight .dl,.highlight .s2,.highlight .sa,.highlight .sb,.highlight .sc,.highlight .sd{color:#f2ca27}.highlight .se{color:plum}.highlight .s1,.highlight .sh,.highlight .si,.highlight .sr,.highlight .ss,.highlight .sx{color:#f2ca27}.highlight .bp{color:#f8f8f2}.highlight .fm{color:#7ed07e}.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#f8f8f2}.highlight .il{color:plum}.vue-content-placeholders-heading__img,.vue-content-placeholders-heading__subtitle,.vue-content-placeholders-heading__title,.vue-content-placeholders-img,.vue-content-placeholders-text__line{background:#bfcdec!important}.vue-content-placeholders-is-animated .vue-content-placeholders-heading__img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__subtitle:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__title:before,.vue-content-placeholders-is-animated .vue-content-placeholders-img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-text__line:before{background:linear-gradient(90deg,transparent 0,#d3ddf9 15%,transparent 30%)!important}header[data-v-27046cca]{max-width:1280px;margin:auto;padding:1rem;height:6rem;border-bottom:1px solid rgba(0,0,0,.2)}header .logo-wrapper[data-v-27046cca],header[data-v-27046cca]{display:flex;align-items:center;justify-content:space-between}header .logo-wrapper[data-v-27046cca]{margin:0 .5rem}header .logo-wrapper svg[data-v-27046cca]{width:3rem;height:100%}header .logo-wrapper .name-wrapper[data-v-27046cca]{margin-left:.6em}header .logo-wrapper .name-wrapper .subtitle[data-v-27046cca]{font-size:1rem}header .logo-wrapper .name-wrapper .app-name[data-v-27046cca]{font-weight:700;font-size:2.25rem;line-height:1.25}header nav[data-v-27046cca]{letter-spacing:-.025rem;font-weight:600;text-transform:uppercase}header nav ul[data-v-27046cca]{display:flex}header nav ul li[data-v-27046cca]{margin:0 .5rem}header nav ul li a[data-v-27046cca]{box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;padding:.25rem 1rem;border-radius:.5rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}header nav ul li a[data-v-27046cca]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header nav ul li a.nuxt-link-exact-active[data-v-27046cca]{cursor:default}header nav ul li a.nuxt-link-exact-active[data-v-27046cca],header nav ul li a[data-v-27046cca]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}.page-wrapper[data-v-10d06ee8]{max-width:1280px;margin:auto;padding:1rem}.article-content-wrapper[data-v-10d06ee8]{display:flex;flex-direction:column;align-items:center;margin:auto auto 2rem}@media(min-width:1024px){.article-content-wrapper[data-v-10d06ee8]{align-items:normal;flex-direction:row}}.article-content-wrapper .article-block[data-v-10d06ee8]{width:100%;max-width:880px}@media(min-width:1024px){.article-content-wrapper .article-block[data-v-10d06ee8]{margin-right:1rem;width:66.66666%;margin-bottom:2rem}}.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{max-width:880px;width:100%;position:relative}@media(min-width:1024px){.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{display:block;width:33.33333%}}.article-content-wrapper .aside-username-wrapper .aside-username-block[data-v-10d06ee8]{position:-webkit-sticky;position:sticky;top:1rem}@media(min-width:1280px){.comments-block[data-v-10d06ee8]{margin:.5rem}}article[data-v-70afb46a]{padding:.5rem;border-radius:1rem}header h1[data-v-70afb46a],header[data-v-70afb46a]{margin-bottom:1rem}header h1[data-v-70afb46a]{font-size:2.25rem;letter-spacing:-.025rem}header .tags[data-v-70afb46a]{display:flex;flex-wrap:wrap;margin-bottom:1.5rem}header .tags .tag[data-v-70afb46a]{font-weight:500;line-height:1;padding:.5rem;margin:0 .5rem .5rem 0;border-radius:.25rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db}header .tags .tag[data-v-70afb46a]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header .tags .tag[data-v-70afb46a]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}header .image-wrapper[data-v-70afb46a]{position:relative;padding-bottom:56.25%;background-color:#d4dfe8;margin-bottom:1.5rem;border-radius:.5rem;overflow:hidden}@media(min-width:834px){header .image-wrapper[data-v-70afb46a]{margin-bottom:1.5rem}}header .image-wrapper img[data-v-70afb46a]{position:absolute;top:0;left:0;width:100%;height:100%;-o-object-fit:cover;object-fit:cover}header .meta[data-v-70afb46a]{line-height:1;font-size:.875rem;text-transform:uppercase;font-weight:500;letter-spacing:-.025rem;display:flex;align-items:center;justify-content:space-between}header .meta .scl[data-v-70afb46a]{display:flex}header .meta .scl span[data-v-70afb46a]{display:flex;align-items:center;margin-right:1rem}header .meta .scl span svg[data-v-70afb46a]{margin-right:.25rem}header .meta .scl .comments[data-v-70afb46a]{cursor:pointer}[data-v-70afb46a] .content .ltag__user{display:none}[data-v-70afb46a] .content iframe{max-width:100%}[data-v-70afb46a] .content h1{font-size:1.875rem}[data-v-70afb46a] .content h1,[data-v-70afb46a] .content h2{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h2{font-size:1.5rem}[data-v-70afb46a] .content h3{font-size:1.25rem}[data-v-70afb46a] .content h3,[data-v-70afb46a] .content h4{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h4{font-size:1rem}[data-v-70afb46a] .content a{color:#6e87d2}[data-v-70afb46a] .content p{margin-bottom:1rem;line-height:1.4}[data-v-70afb46a] .content p code{background-color:#d2f3e1;border-radius:.25rem;padding:.25rem}[data-v-70afb46a] .content img{width:100%;border-radius:.5rem}[data-v-70afb46a] .content .highlight{margin-bottom:1rem;border-radius:.5rem}[data-v-70afb46a] .content ul{list-style:numeral;margin-bottom:1rem}[data-v-70afb46a] .content ul li p{margin-bottom:0}[data-v-70afb46a] .content ol{margin-bottom:1rem}aside[data-v-37984f8c]{padding:1rem;background-color:#dfe8ef;border-radius:1rem}aside .username-heading[data-v-37984f8c]{display:flex;margin-bottom:1rem}aside .username-heading[data-v-37984f8c]:hover{color:#6e87d2}aside .username-heading img[data-v-37984f8c]{width:3rem;height:3rem;border-radius:50%;margin-right:1rem}aside .username-heading .text[data-v-37984f8c]{display:flex;flex-direction:column;justify-content:center}aside .username-heading .text a[data-v-37984f8c]{line-height:1}aside .username-heading .text a[data-v-37984f8c]:first-child{font-size:1.25rem;font-weight:500;letter-spacing:-.025rem;margin-bottom:.25rem}aside .username-heading .text a[data-v-37984f8c]:last-child{color:#999;font-size:.875rem}aside .username-heading.loading[data-v-37984f8c]{display:block}aside .f-button[data-v-37984f8c]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}aside .f-button[data-v-37984f8c]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}aside .f-button[data-v-37984f8c]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}aside .info>div[data-v-37984f8c]{margin-bottom:.5rem}aside .info .title[data-v-37984f8c]{font-size:.666666rem;letter-spacing:-.0125rem;font-weight:500;color:#999;text-transform:uppercase;margin-bottom:.1rem}aside .info .content[data-v-37984f8c]{font-size:.875rem;line-height:1.4}.add-comment[data-v-8c4375bc]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}.add-comment[data-v-8c4375bc]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}.add-comment[data-v-8c4375bc]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}footer[data-v-22cb8fd0]{padding:2rem;text-align:center;display:flex;align-items:center;justify-content:center}footer span[data-v-22cb8fd0]{display:inline-block;line-height:1;text-transform:uppercase;letter-spacing:-.025rem;font-size:.75rem;font-weight:500}footer a svg[data-v-22cb8fd0]{width:3rem;height:3rem;margin:0 .5rem}footer a .nuxt-icon[data-v-22cb8fd0]{width:2.5rem;height:2.5rem;margin:0 .25rem}</style>
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><div id="__layout"><div><header data-v-27046cca><a href="/nuxtstop/" class="logo-wrapper nuxt-link-active" data-v-27046cca><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-27046cca><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-27046cca></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-27046cca></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-27046cca></path></svg> <div class="name-wrapper" data-v-27046cca><span class="app-name" data-v-27046cca>Nuxtstop</span> <p class="subtitle" data-v-27046cca>For all things nuxt.js</p></div></a> <nav data-v-27046cca><ul data-v-27046cca><li data-v-27046cca><a href="/nuxtstop/" class="nuxt-link-active" data-v-27046cca>
          New
        </a></li><li data-v-27046cca><a href="/nuxtstop/top" data-v-27046cca>
          Top
        </a></li></ul></nav></header> <div class="page-wrapper" data-v-10d06ee8><div class="article-content-wrapper" data-v-10d06ee8><article data-fetch-key="data-v-70afb46a:0" class="article-block" data-v-70afb46a data-v-10d06ee8><header data-v-70afb46a><h1 data-v-70afb46a>How to Model Your Gitops Environments and Promote Releases between Them</h1> <div class="tags" data-v-70afb46a><a href="/nuxtstop/t/kubernetes" class="tag" data-v-70afb46a>
          #kubernetes
        </a><a href="/nuxtstop/t/gitops" class="tag" data-v-70afb46a>
          #gitops
        </a><a href="/nuxtstop/t/cloud" class="tag" data-v-70afb46a>
          #cloud
        </a><a href="/nuxtstop/t/devops" class="tag" data-v-70afb46a>
          #devops
        </a></div> <div class="image-wrapper" data-v-70afb46a><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--uroeqGhT--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/85gjq7hxrxxckb57vj5z.png" alt="How to Model Your Gitops Environments and Promote Releases between Them" data-v-70afb46a></div> <div class="meta" data-v-70afb46a><div class="scl" data-v-70afb46a><span data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M16.4444 3C14.6733 3 13.0333 3.94162 12 5.34C10.9667 3.94162 9.32667 3 7.55556 3C4.49222 3 2 5.52338 2 8.625C2 14.8024 11.0267 20.586 11.4122 20.829C11.5922 20.9426 11.7956 21 12 21C12.2044 21 12.4078 20.9426 12.5878 20.829C12.9733 20.586 22 14.8024 22 8.625C22 5.52338 19.5078 3 16.4444 3Z" fill="#FF0000" data-v-70afb46a data-v-70afb46a></path></svg>
            6
          </span> <span class="comments" data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M6.11765 22H4.94118L5.64706 21.05C6.11765 20.3969 6.41176 19.5656 6.58824 18.5563C3.64706 17.1906 2 14.6375 2 11.3125C2 6.20625 5.82353 3 12 3C18.1765 3 22 6.20625 22 11.3125C22 16.5375 18.2353 19.625 12 19.625H11.5882C10.6471 20.7531 9 22 6.11765 22ZM12 4.1875C6.47059 4.1875 3.17647 6.85937 3.17647 11.3125C3.17647 15.1125 5.47059 16.8938 7.41177 17.6656L7.82353 17.8437L7.76471 18.3187C7.64706 19.2687 7.47059 20.1 7.11765 20.8125C9.05882 20.575 10.1765 19.5656 10.8235 18.7344L11 18.4969H12C19.9412 18.4969 20.8235 13.5094 20.8235 11.3719C20.8235 6.85938 17.5294 4.1875 12 4.1875Z" fill="black" data-v-70afb46a data-v-70afb46a></path></svg>
            0
          </span></div> <time data-v-70afb46a>Mar 23</time></div></header> <div class="content" data-v-70afb46a><p>Two of the most important questions that people ask themselves on day 2 after adopting GitOps are:</p>

<ol>
<li>How should I represent different environments on Git?</li>
<li>How should I handle promoting releases between environments?</li>
</ol>

<p>In <a href="https://codefresh.io/about-gitops/branches-gitops-environments/">the previous article of the series</a>, I focused on what NOT to do and explained why using Git branches for different environments is a bad idea. I also hinted that the “environment-per-folder” approach is a better idea. This article has proved hugely popular and several people wanted to see all the details about the suggested structure for environments when folders are used.</p>

<p>In this article, I am going to explain how to model your GitOps environments using different folders on the same Git branch, and as an added bonus, how to handle environment promotion (both simple and complex) with simple file copy operations.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Z1Aoaz7K--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6xd34ou4vc1lwvnm71vc.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Z1Aoaz7K--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6xd34ou4vc1lwvnm71vc.png" alt="GitOps promotion" loading="lazy" width="851" height="218"></a></p>

<p>Hopefully this article will help with the endless stream of <a href="https://github.com/argoproj/argocd-example-apps/issues/57">questions</a> and <a href="https://github.com/argoproj/argo-cd/discussions/5667">discussions</a> on this hot topic.</p>

<h2>
  <a name="learn-your-application-first" href="#learn-your-application-first">
  </a>
  Learn your application first
</h2>

<p>Before creating your folder structure you need to do some research first and understand the “settings” of your application. Even though several people talk about application configuration in a generic manner, in reality not all configuration settings are equally important.</p>

<p>In the context of a Kubernetes application, we have the following categories of “environment configuration”:</p>

<ol>
<li>The <strong>application version</strong> in the form of the container tag used. This is probably the most important setting in a Kubernetes manifest (as far as environment promotions are concerned). Depending on your use case, you might get away with simply changing the version of the container image. However, several times a new change in the source code also requires a new change in the deployment environment</li>
<li>
<strong>Kubernetes specific settings</strong> for your application. This includes the replicas of the application and other Kubernetes related information such as resource limits, health checks, persistent volumes, affinity rules, etc.</li>
<li>Mostly <strong>static business settings</strong>. This is the set of settings that are unrelated to Kubernetes but have to do with the business of your application. It might be external URLs, internal queue sizes, UI defaults, authentication profiles, etc. By “mostly static,” I mean settings that are defined once for each environment and then never change afterwards. For example, you always want your production environment to use production.paypal.com and your non-production environments to use staging.paypal.com. This is a setting that you never want to promote between environments</li>
<li>
<strong>Non-static business settings</strong>. This is the same thing as the previous point, but it includes settings that you DO want to promote between environments. This could be a global VAT setting, your recommendation engine parameters, the available bitrate encodings, and any other setting that is specific to your business.</li>
</ol>

<p>It is imperative that you understand what all the different settings are and, more importantly, which of them belong to category 4 as these are the ones that you also want to promote along with your application version.</p>

<p>This way you can cover all possible promotion scenarios:</p>

<ol>
<li>Your application moves from version 1.34 to 1.35 in QA. This is a simple source code change. Therefore you only need to change the container image property in your QA environment.</li>
<li>Your application moves from version 3.23 to 3.24 in Staging. This is not a simple source code change. You need to update the container image property and also bring the new setting “recommender.batch_size” from QA to staging.</li>
</ol>

<p>I see too many teams that don’t understand the distinction between different configuration parameters and have a single configuration file (or mechanism) with values from different areas (i.e. both runtime and application business settings).</p>

<p>Once you have the list of your settings and which area they belong to, you are ready to create your environment structure and optimize the file copy operations for the settings that change a lot and need to be moved between environments.</p>

<h2>
  <a name="example-with-5-gitops-environments-and-variations-between-them" href="#example-with-5-gitops-environments-and-variations-between-them">
  </a>
  Example with 5 GitOps environments and variations between them
</h2>

<p>Let’s see an actual example. I thought about doing the classic QA/Staging/Production trilogy, but this is rather boring so let’s dive into a more realistic example. </p>

<p>We are going to model the environment situation mentioned in the first article of the series. The company that we will examine has 5 distinct environments:</p>

<ul>
<li>Load Testing</li>
<li>Integration Testing</li>
<li>QA</li>
<li>Staging</li>
<li>Production</li>
</ul>

<p>Then let’s assume that the last 2 environments are also deployed to EU, US, and Asia while the first 2 also have GPU and Non-GPU variations. This means that the company has a total of 11 environments. </p>

<p>You can find the suggested folder structure at  <a href="https://github.com/kostis-codefresh/gitops-environment-promotion">https://github.com/kostis-codefresh/gitops-environment-promotion</a>. All environments are different folders in the same branch. There are NO branches for the different environments. If you want to know what is deployed in an environment, you simply look at envs/ in the main branch of the repo.</p>

<p>Before we explain the structure, here are some disclaimers: </p>

<p><strong>Disclaimer 1:</strong> Writing this article took a long time because I wasn’t sure if I should cover <a href="https://kustomize.io/">Kustomize</a> or <a href="https://helm.sh/">Helm</a> or plain manifests. I chose Kustomize as it makes things a bit easier (and I also mention Helm at the end of the article). Note however that the Kustomize templates in the example repo are simply for illustration purposes. The present article is NOT a Kustomize tutorial. In a real application, you might have <a href="https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/configmapgenerator/">Configmap generators</a>, <a href="https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesstrategicmerge/">custom patches</a> and adopt a completely different “component” structure than the one I am showing here. If you are not familiar with Kustomize, spend some time understanding its capabilities first and then come back to this article.</p>

<p><strong>Disclaimer 2:</strong> The <a href="https://github.com/kostis-codefresh/gitops-promotion-source-code">application I use</a> for the promotions is completely dummy, and its configuration misses several best practices mainly for brevity and simplicity reasons. For example, some deployments are missing <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">health checks</a>, and all of them are missing <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/">resource limits</a>. Again, this article is NOT about how to create Kubernetes deployments. You should already know how proper deployment manifests look. If you want to learn more about production-grade best practices, then see my other article at <a href="https://codefresh.io/kubernetes-tutorial/kubernetes-antipatterns-1/">https://codefresh.io/kubernetes-tutorial/kubernetes-antipatterns-1/</a></p>

<p>With the disclaimers out of the way, here is the repository structure:</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--NmdZpVhJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7kluawshadkmduowh8wa.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--NmdZpVhJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7kluawshadkmduowh8wa.jpg" alt="GitOps folder structure" loading="lazy" width="566" height="627"></a> </p>

<p>The base directory holds configuration which is common to all environments. It is not expected to change often. If you want to do changes to multiple environments at the same time, it is best to use the “variants” folder.</p>

<p>The variants folder (a.k.a mixins, a.k.a. components) holds common characteristics between environments. It is up to you to define what exactly you think is “common” between your environments after researching your application as discussed in the previous section.</p>

<p>In the example application, we have variants for all prod and non-prod environments and also the regions. Here is an example of the <a href="https://raw.githubusercontent.com/kostis-codefresh/gitops-environment-promotion/main/variants/prod/prod.yml">prod variant</a> that applies to ALL production environments.<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight yaml"><code><span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">simple-deployment</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">webserver-simple</span>
        <span class="na">env</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">ENV_TYPE</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">production"</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">PAYPAL_URL</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">production.paypal.com"</span>   
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">DB_USER</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">prod_username"</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">DB_PASSWORD</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">prod_password"</span>                     
        <span class="na">livenessProbe</span><span class="pi">:</span>
          <span class="na">httpGet</span><span class="pi">:</span>
            <span class="na">path</span><span class="pi">:</span> <span class="s">/health</span>
            <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>In the example above, we make sure that all production environments are using the production DB credentials, the production payment gateway, and a liveness probe (this is a contrived example, please see disclaimer 2 at the start of this section). These settings belong to the set of configuration that we don’t expect to promote between environments, but we assume that they will be static across the application lifecycle.</p>

<p>With the base and variants ready, we can now define every final environment with a combination of those properties.</p>

<p>Here is an example of the <a href="https://github.com/kostis-codefresh/gitops-environment-promotion/tree/main/envs/staging-asia">staging ASIA environment</a>:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight yaml"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kustomize.config.k8s.io/v1beta1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Kustomization</span>

<span class="na">namespace</span><span class="pi">:</span> <span class="s">staging</span>
<span class="na">namePrefix</span><span class="pi">:</span> <span class="s">staging-asia-</span>

<span class="na">resources</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">../../base</span>

<span class="na">components</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">../../variants/non-prod</span>
  <span class="pi">-</span> <span class="s">../../variants/asia</span>

<span class="na">patchesStrategicMerge</span><span class="pi">:</span>
<span class="pi">-</span> <span class="s">deployment.yml</span>
<span class="pi">-</span> <span class="s">version.yml</span>
<span class="pi">-</span> <span class="s">replicas.yml</span>
<span class="pi">-</span> <span class="s">settings.yml</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>First we define some common properties. We inherit all configuration from base, from non-prod environments, and for all environments in Asia.</p>

<p>The key point here is the patches that we apply. The <a href="https://github.com/kostis-codefresh/gitops-environment-promotion/blob/main/envs/staging-asia/version.yml">version.yml</a> and <a href="https://github.com/kostis-codefresh/gitops-environment-promotion/blob/main/envs/staging-asia/replicas.yml">replicas.yml</a> are self-explanatory. They only define the image and replicas on their own and nothing else.</p>

<p>The version.yml file (which is the most important thing to promote between environments) defines only the image of the application and nothing else.<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight yaml"><code><span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">simple-deployment</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">webserver-simple</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">docker.io/kostiscodefresh/simple-env-app:2.0</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>The associated settings for each release that we <strong>DO</strong> expect to promote between environments are also defined in <a href="https://github.com/kostis-codefresh/gitops-environment-promotion/blob/main/envs/staging-asia/settings.yml">settings.yml</a><br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight yaml"><code><span class="nn">---</span>
<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">simple-deployment</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">webserver-simple</span>
        <span class="na">env</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">UI_THEME</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">dark"</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">CACHE_SIZE</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1024kb"</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">PAGE_LIMIT</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">25"</span>
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">SORTING</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">ascending"</span>    
        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">N_BUCKETS</span>
          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">42"</span>         
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>Feel free to look at the <a href="https://github.com/kostis-codefresh/gitops-environment-promotion">whole repository</a> to understand the way all kustomizations are formed.</p>

<h2>
  <a name="performing-the-initial-deployment-via-gitops" href="#performing-the-initial-deployment-via-gitops">
  </a>
  Performing the initial deployment via GitOps
</h2>

<p>To deploy an application to its associated environment, just point your GitOps controller to the respective “env” folder and kustomize will create the complete hierarchy of settings and values.</p>

<p>Here is the <a href="https://github.com/kostis-codefresh/gitops-promotion-source-code">example application</a> as it runs in Staging/Asia.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Xh2Td7RF--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jthmsbi5qg1hsfhf46wq.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Xh2Td7RF--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jthmsbi5qg1hsfhf46wq.jpg" alt="GitOps application example" loading="lazy" width="537" height="360"></a></p>

<p>You can also use Kustomize on the command line to preview what is going to be deployed for each environment. Examples:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight shell"><code>kustomize build envs/staging-asia
kustomize build envs/qa
kustomize build envs/integration-gpu
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>You can of course pipe the output to kubectl to deploy each environment, but in the context of GitOps, you should always let your GitOps controller deploy your environments and avoid manual kubectl operations.</p>

<h2>
  <a name="comparing-the-configuration-of-two-environments" href="#comparing-the-configuration-of-two-environments">
  </a>
  Comparing the configuration of two environments
</h2>

<p>A very common need for a software team is to understand what is different between two environments. I have seen several teams who have the misconception that only with branches you can easily find differences between environments.</p>

<p>This could not be further from the truth. You can easily use mature file-diffing utilities to find what is different between environments just by comparing files and folders.</p>

<p>The simplest way is to diff only the settings that are critical to the app.<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight shell"><code>vimdiff envs/integration-gpu/settings.yml envs/integration-non-gpu/settings.yml
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--wLakkrDX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8xsimyy6qbq5920lqkf6.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--wLakkrDX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8xsimyy6qbq5920lqkf6.jpg" alt="GitOps settings diff" loading="lazy" width="880" height="480"></a></p>

<p>And with the help of kustomize, you can compare any number of whole environments for the full picture:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight shell"><code>kustomize build envs/qa/> /tmp/qa.yml
kustomize build envs/staging-us/ <span class="o">></span> /tmp/staging-us.yml
kustomize build envs/prod-us/ <span class="o">></span> /tmp/prod-us.yml
vimdiff /tmp/staging-us.yml /tmp/qa.yml /tmp/prod-us.yml
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--5wSVXrSB--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mjwjvvgiu2i9vgokr0n3.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--5wSVXrSB--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mjwjvvgiu2i9vgokr0n3.jpg" alt="GitOps environment diff" loading="lazy" width="880" height="447"></a></p>

<p>I personally don’t see any disadvantage between this method and performing “git diff” between environment branches.</p>

<h2>
  <a name="how-to-perform-promotions-between-gitops-environments" href="#how-to-perform-promotions-between-gitops-environments">
  </a>
  How to perform promotions between GitOps environments
</h2>

<p>Now that the file structure is clear, we can finally answer the age-old question “how do I promote releases with GitOps”?</p>

<p>Let’s see some promotion scenarios. If you have been paying attention to the file structure, you should already understand how all promotions resolve to simple file copy operations.</p>

<p><strong>Scenario:</strong> Promote application version from QA to staging environment in the US:</p>

<ol>
<li>cp envs/qa/version.yml envs/staging-us/version.yml</li>
<li>commit/push changes</li>
</ol>

<p><strong>Scenario:</strong> Promote application version from integration testing (GPU) to load testing (GPU) and then to QA. This is a 2 step process</p>

<ol>
<li>cp envs/integration-gpu/version.yml  envs/load-gpu/version.yml</li>
<li>commit/push changes</li>
<li>cp envs/load-gpu/version.yml  envs/qa/version.yml</li>
<li>commit/push changes</li>
</ol>

<p><strong>Scenario:</strong> Promote an application from prod-eu to prod-us along with the extra configuration. Here we also copy our setting file(s).</p>

<ol>
<li>cp envs/prod-eu/version.yml  envs/prod-us/version.yml</li>
<li>cp envs/prod-eu/settings.yml  envs/prod-us/settings.yml</li>
<li>commit/push changes</li>
</ol>

<p><strong>Scenario:</strong> Make sure that QA has the same replica count as staging-asia</p>

<ol>
<li>cp envs/staging-asia/replicas.yml envs/qa/replicas.yml</li>
<li>commit/push changes</li>
</ol>

<p><strong>Scenario:</strong> Backport all settings from qa to integration testing (non-gpu variant)</p>

<ol>
<li>cp envs/qa/settings.yml envs/integration-non-gpu/settings.yml</li>
<li>commit/push changes</li>
</ol>

<p><strong>Scenario:</strong> Make a global change to all non-prod environments at once (but see also next section for some discussion on this operation)</p>

<ol>
<li>Make your change in variants/non-prod/non-prod.yml </li>
<li>commit/push changes</li>
</ol>

<p><strong>Scenario:</strong> Add a new configuration file to all US environments (both production and staging).</p>

<ol>
<li>Add the new manifest in the variants/us folder</li>
<li>Modify the variants/us/kustomization.yml file to include the new manifest</li>
<li>commit/push changes</li>
</ol>

<p>In general, all promotions are just copy operations. Unlike the environment-per-branch approach, you are now free to promote anything from any environment to any other environment without any fear of taking the wrong changes. Especially when it comes to back-porting configuration, environment-per-folder really shines as you can simply move configuration both “upwards” and “backwards” even between unrelated environments.</p>

<p>Note that I am using cp operations just for illustration purposes. In a real application, this operation would be performed automatically by your CI system or other orchestration tool. And depending on the environment, you might want to create a Pull Request first instead of directly editing the folder in the main branch.</p>

<h2>
  <a name="making-changes-to-multiple-environments-at-once" href="#making-changes-to-multiple-environments-at-once">
  </a>
  Making changes to multiple environments at once
</h2>

<p>Several people have asked in the comments of the <a href="https://codefresh.io/about-gitops/branches-gitops-environments/">first article</a> about the use-case of changing multiple environments at once and how to achieve and/or prevent this scenario.</p>

<p>First of all, we need to define what exactly we mean by “multiple” environments. We can assume the following 2 cases.</p>

<ol>
<li>Changing multiple environments at once that are on the same “level.” As an example, you want to make a change that affects prod-us, prod-eu and prod-asia at the same time</li>
<li>Changing multiple environments at once that are <strong>NOT</strong> on the same level. As an example, you want to make a change to “integration” and “staging-eu” at the same time</li>
</ol>

<p>The first case is a valid scenario, and we will cover this below. However, I consider the second scenario an anti-pattern. The whole point of having different environments is to be able to release things in a gradual way and promote a change from one environment to the next. So if you find yourself deploying the same change in environments of different importance, ask yourself if this is really needed and why.</p>

<p>For the valid scenario of deploying a single change to multiple “similar” environments, there are two strategies:</p>

<ol>
<li>If you are absolutely certain that the change is “safe” and you want it to reach all environments at once, you can make that change in the appropriate variant (or respective folders). For example, if you commit/push a change in the variants/non-prod folder then all non-production environments will get this change at the same time. I am personally <strong>against</strong> this approach because several changes look “safe” in theory but can be problematic in practice</li>
<li>The preferable approach is to apply the change to each individual folder and then move it to the “parent” variant when it is live on all environments.</li>
</ol>

<p>Let’s take an example. We want to make a change that affects all EU environments (e.g. a GDPR feature). The naive way would be to commit/push the configuration change directly to variants/eu folder. This would indeed affect all EU environments (prod-eu and staging-eu). However this is a bit risky, because if the deployment fails, you have just brought down a production environment.</p>

<p>The suggested approach is the following:</p>

<ol>
<li>Make the change to envs/staging-eu first</li>
<li>Then make the same change to envs/prod-eu</li>
<li>Finally, delete the change from both environments and add it in variants/eu (in a single commit/push action).</li>
</ol>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--mWt2fn1G--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aidbyxfyiw4e5zq80wh6.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--mWt2fn1G--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aidbyxfyiw4e5zq80wh6.png" alt="Gradual GitOps promotion" loading="lazy" width="880" height="585"></a></p>

<p>You might recognize this pattern from gradual <a href="https://databaserefactoring.com/">database refactorings</a>. The final commit is “transitional” in the sense that it doesn’t really affect any environments in any way. Kustomize will create the exact same definition in both cases. Your GitOps controller shouldn’t find any differences at all.</p>

<p>The advantages of this approach are of course the easy way to rollback/revert the change as you move it through environments. The disadvantage is the increased effort (and commits) you need to promote the change to all environments, but I believe that the effort outweighs the risks.</p>

<p>If you adopt this approach, it means that you <strong>never</strong> apply new changes to the base folder directly. If you want a change to happen to all environments, you first apply the change to individual environments and/or variants and then backport it to the base folder while simultaneously removing it from all downstream folders.</p>

<h2>
  <a name="the-advantages-of-the-environmentperfolder-approach" href="#the-advantages-of-the-environmentperfolder-approach">
  </a>
  The advantages of the “environment-per-folder” approach
</h2>

<p>Now that we have analyzed all the inner workings of the “environment-per-folder” approach, it is time to explain why it is better than the “environment-per-branch” approach. If you have been paying attention to the previous sections, you should already understand how the “environment-per-folder” approach directly avoids all the problems analyzed in the <a href="https://codefresh.io/about-gitops/branches-gitops-environments/">previous article</a>. </p>

<p>The most glaring issues with environment branches is the order of commits and the danger of bringing unwanted changes when you merge from one environment to another. With the folder approach, this problem is completely eliminated:</p>

<ol>
<li>The order of commits on the repo is now irrelevant. When you copy a file from one folder to the next, you don’t care about its commit history, just its content</li>
<li>By only copying files around, you only take exactly what you need and nothing else. When you copy envs/qa/version.yml to envs/staging-asia/version.yml you can be certain that you only promote the container image and nothing else. If somebody else has changed the replicas in the QA environment in the meantime, it doesn’t affect your promotion action.</li>
<li>You don’t need to use git cherry-picks or any other advanced git method to promote releases. You only copy files around and have access to the mature ecosystem of utilities for file processing.</li>
<li>You are free to take any change from any environment to either an upstream or downstream environment without any constraints about the correct “order” of environments. If for example you want to backport your settings from production US to staging US, you can do a simple copy operation of envs/prod-us/settings.yml to envs/staging-us/settings.yml without the fear that you might take inadvertently unrelated hotfixes that were supposed to be only in production.</li>
<li>You can easily use file diff operations to understand what is different between environments in all directions (both from source and target environments and vice versa)</li>
</ol>

<p>I consider these advantages very important for any non-trivial application, and I bet that several “failed deployments” in big organizations could be directly or indirectly attributed to the problematic environment-per-branch model.</p>

<p>The second problem mentioned in the previous article was the presence of configuration drift when you merge a branch to the next environment. The reason for this is that when you do a “git merge,” git only notifies you about the changes it will bring, and it doesn’t say anything about what changes are already in the target branch.</p>

<p>Again this problem is completely eliminated with folders. As we said already, file diff operations have no concept of “direction.” You can copy any setting from any environment either upwards or downwards, and if you do a diff operation on the files, you will see all changes between environments regardless of their upstream/downstream position.</p>

<p>The last point about environment branches was the linear complexity of branches as the number of environments grows. With 5 environments, you need to juggle changes between 5 branches, and with 20 environments, you need to have 20 branches. Moving a release correctly between a large number of branches is a cumbersome process, and in the case of production environments, it is a recipe for disaster.</p>

<p>With the folder approach, the number of branches is not only static but it is exactly 1. If you have 5 environments you manage them all with your “main” branch, and if you need more environments, you only add extra folders. If you have 20 environments, you still need a single Git branch. Getting a centralized view on what is deployed where is trivial when you have a single branch.</p>

<h2>
  <a name="using-helm-with-gitops-environments" href="#using-helm-with-gitops-environments">
  </a>
  Using Helm with GitOps environments
</h2>

<p>If you don’t use Kustomize but prefer Helm instead, it is also possible to create a hierarchy of folders with “common” stuff for all environments, specific features/mixins/components, and final folders specific to each environment.</p>

<p>Here is how the folder structure would look like<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight plaintext"><code>chart/
  [...chart files here..]
common/
  values-common.yml
variants/
  prod/
     values-prod.yml
  non-prod/
    Values-non-prod.yml
  [...other variants…]
 envs/
     prod-eu/
           values-env-default.yaml
           values-replicas.yaml
           values-version.yaml
           values-settings.yaml
   [..other environments…]
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>Again you need to spend some time to examine your application properties and decide how to split them into different value files for optimal promotion speed.</p>

<p>Other than this, most of the processes are the same when it comes to environment promotion.</p>

<p><strong>Scenario:</strong> Promote application version from  QA to staging environment in the US:</p>

<ol>
<li>cp envs/qa/values-version.yml envs/staging-us/values-version.yml</li>
<li>commit/push changes</li>
</ol>

<p><strong>Scenario:</strong> Promote application version from integration testing (GPU) to load testing (GPU) and then to QA. This is a 2 step process</p>

<ol>
<li>cp envs/integration-gpu/values-version.yml  envs/load-gpu/values-version.yml</li>
<li>commit/push changes</li>
<li>cp envs/load-gpu/values-version.yml  envs/qa/values-version.yml</li>
<li>commit/push changes</li>
</ol>

<p><strong>Scenario:</strong> Promote an application from prod-eu to prod-us along with the extra configuration. Here we also copy our setting file(s).</p>

<ol>
<li>cp envs/prod-eu/values-version.yml  envs/prod-us/values-version.yml</li>
<li>cp envs/prod-eu/values-settings.yml  envs/prod-us/values-settings.yml</li>
<li>commit/push changes</li>
</ol>

<p>It is also critical to understand how Helm (or your GitOps agent which handles Helm) works with multiple value files and the order in which they override each other.</p>

<p>If you want to preview one of your environments, instead of “kustomize build” you can use the following command<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight shell"><code>helm template chart/ <span class="nt">--values</span> common/values-common.yaml <span class="nt">--values</span> variants/prod/values-prod.yaml –values envs/prod-eu/values-env-default.yml –values envs/prod-eu/values-replicas.yml –values envs/prod-eu/values-version.yml –values envs/prod-eu/values-settings.yml
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>You can see that Helm is a bit more cumbersome than Kustomize, if you have a large number of variants or files in each environment folder.</p>

<h2>
  <a name="the-environmentpergitrepo-approach" href="#the-environmentpergitrepo-approach">
  </a>
  The “environment-per-git-repo” approach
</h2>

<p>When I talk with big organizations about the folder approach, one of the first objections I see is that people (especially security teams) don’t like to see a single branch in a single Git repository that contains both prod and non-prod environments.</p>

<p>This is an understandable objection and arguably can be the single weak point of the folder approach against the “environment-per-branch” paradigm. After all, it is much easier to secure individual branches in a Git repository instead of folders in a single branch.</p>

<p>This problem can be easily solved with automation, validation checks, or even manual approvals if you think it is critical for your organization. I want to stress again that I only use “cp” in the file operations for promoting releases just for illustration purposes. It doesn't mean that an actual human should run cp manually in an interactive terminal when a promotion happens.</p>

<p>Ideally you should have an automated system that copies files around and commits/pushes them. This can be your Continuous Integration (CI) system or other platform that deals with your software lifecycle. And if you still have humans that make the changes themselves, they should never commit to “main” directly. They should open a Pull Request instead. Then you should have a proper workflow that checks that Pull Request before merging.</p>

<p>I realize however that some organizations are particularly sensitive to security issues and they prefer a bulletproof approach when it comes to Git protection. For these organizations, you can employ 2 Git repositories. One has the base configuration, all prod variants, and all prod environments (and everything else related to production) while the second Git repository has all non-production stuff.</p>

<p>This approach makes promotions a bit harder, as now you need to checkout 2 git repositories before doing any promotion. On the other hand, it allows your security team to place extra security constraints to the “production” Git repository, and you still have a static number of Git repositories (exactly 2) regardless of the amount of environments you deploy to.</p>

<p>I personally consider this approach an overkill that, at least to me, shows a lack of trust against developers and operators. The discussion on whether or not people should have direct access to production environments is a complex one and probably deserves a blog post on its own.</p>

<h2>
  <a name="embrace-folders-and-forget-branches" href="#embrace-folders-and-forget-branches">
  </a>
  Embrace folders and forget branches
</h2>

<p>We hope that with this blog post we addressed all the questions that arose from the “don’t use branches for environments” article and you now have a good understanding about the benefits of the folder approach and why you should use it.</p>

<p>If you have other interesting use cases or have extra questions on the subject of organizing your GitOps environments, please ask in the comments section.</p>

<p>Happy GitOps deployments!</p>

</div></article> <div class="aside-username-wrapper" data-v-10d06ee8><aside class="aside-username-block" data-v-37984f8c data-v-10d06ee8><div class="username-heading loading" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-heading" data-v-37984f8c><div class="vue-content-placeholders-heading__img"></div> <div class="vue-content-placeholders-heading__content"><div class="vue-content-placeholders-heading__title"></div> <div class="vue-content-placeholders-heading__subtitle"></div></div></div></div></div> <div class="info" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-text" data-v-37984f8c><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div></div></div></div></aside></div></div> <div class="comments-block" data-v-8c4375bc data-v-10d06ee8><!----> <a href="https://dev.to/kostiscodefresh/how-to-model-your-gitops-environments-and-promote-releases-between-them-1p6i" target="_blank" rel="nofollow noopener noreferer" class="add-comment" data-v-8c4375bc>
    Add comment
  </a></div></div> <footer data-v-22cb8fd0><span data-v-22cb8fd0>Built with</span> <a href="https://nuxtjs.org" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="nuxt-icon" data-v-22cb8fd0 data-v-22cb8fd0><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a> <span data-v-22cb8fd0>&</span> <a href="https://docs.dev.to/api" rel="nofollow noopener" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-22cb8fd0 data-v-22cb8fd0><path d="M1.5726 5.13748C1.42945 5.20622 1.2411 5.36661 1.15822 5.48117C1 5.69503 1 5.74849 1 11.8739C1 17.9993 1 18.0528 1.15822 18.2667C1.2411 18.3812 1.42945 18.5416 1.5726 18.6104C1.8137 18.7402 2.46164 18.7478 12 18.7478C21.5384 18.7478 22.1863 18.7402 22.4274 18.6104C22.5706 18.5416 22.7589 18.3812 22.8418 18.2667C23 18.0528 23 17.9993 23 11.8739C23 5.74849 23 5.69503 22.8418 5.48117C22.7589 5.36661 22.5706 5.20622 22.4274 5.13748C22.1863 5.00764 21.5384 5 12 5C2.46164 5 1.8137 5.00764 1.5726 5.13748ZM7.7055 8.2613C8.0822 8.45989 8.59454 9.0098 8.77536 9.40694C8.89589 9.66664 8.91095 9.94922 8.91095 12.0649C8.91095 14.3104 8.90344 14.4478 8.75275 14.7839C8.51919 15.288 8.16506 15.6546 7.68288 15.899C7.26096 16.1052 7.22328 16.1128 5.7315 16.1358L4.20206 16.1663V12.1031V8.04744L5.80684 8.07035C7.27602 8.09327 7.42672 8.10854 7.7055 8.2613ZM13.6952 8.89521V9.73538H12.4521H11.2089V10.4991V11.2629H11.9623H12.7158V12.1031V12.9432H11.9623H11.2089V13.707V14.4708H12.4521H13.6952V15.3109V16.151H12C10.1315 16.151 10.0411 16.1358 9.67191 15.6928L9.47603 15.4484V12.1336C9.47603 8.46752 9.46851 8.49807 9.95069 8.20783C10.1692 8.07035 10.3425 8.05508 11.9473 8.05508H13.6952V8.89521ZM16.5658 10.3769C16.8897 11.6295 17.1685 12.6912 17.176 12.7293C17.1911 12.7675 17.4699 11.7441 17.8014 10.461C18.1254 9.17017 18.4343 8.1009 18.4795 8.08563C18.5247 8.06271 18.9541 8.06271 19.4288 8.07035L20.3028 8.09327L19.376 11.6219C18.8713 13.5542 18.4117 15.2269 18.3664 15.3261C18.0123 16.0135 17.274 16.3343 16.7164 16.0441C16.4528 15.899 16.0911 15.4865 15.9705 15.1887C15.9254 15.0665 15.4884 13.4549 15.0062 11.6142C14.524 9.76593 14.1171 8.20783 14.0945 8.15437C14.0644 8.07035 14.2301 8.05508 15.0212 8.07035L15.9856 8.09327L16.5658 10.3769Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M5.93491 12.103V14.4707H6.27394C6.66574 14.4707 7.01983 14.3103 7.1404 14.0965C7.18559 14.0048 7.21575 13.2105 7.21575 12.0648V10.1783L6.99725 9.95683C6.80133 9.76591 6.71847 9.73535 6.35683 9.73535H5.93491V12.103Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a></footer></div></div></div><script>window.__NUXT__=function(e,n,t,a){return t.type_of="article",t.id=1031871,t.title="How to Model Your Gitops Environments and Promote Releases between Them",t.description="Two of the most important questions that people ask themselves on day 2 after adopting GitOps...",t.readable_publish_date="Mar 23",t.slug="how-to-model-your-gitops-environments-and-promote-releases-between-them-1p6i",t.path="/codefreshio/how-to-model-your-gitops-environments-and-promote-releases-between-them-1p6i",t.url="https://dev.to/codefreshio/how-to-model-your-gitops-environments-and-promote-releases-between-them-1p6i",t.comments_count=0,t.public_reactions_count=6,t.collection_id=e,t.published_timestamp=n,t.positive_reactions_count=6,t.cover_image="https://res.cloudinary.com/practicaldev/image/fetch/s--uroeqGhT--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/85gjq7hxrxxckb57vj5z.png",t.social_image="https://res.cloudinary.com/practicaldev/image/fetch/s--nxWJQj8n--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/85gjq7hxrxxckb57vj5z.png",t.canonical_url="https://codefresh.io/about-gitops/how-to-model-your-gitops-environments-and-promote-releases-between-them/",t.created_at="2022-03-23T11:28:26Z",t.edited_at=e,t.crossposted_at=e,t.published_at=n,t.last_comment_at=n,t.reading_time_minutes=17,t.tag_list="kubernetes, gitops, cloud, devops",t.tags=["kubernetes","gitops","cloud","devops"],t.body_html='<p>Two of the most important questions that people ask themselves on day 2 after adopting GitOps are:</p>\n\n<ol>\n<li>How should I represent different environments on Git?</li>\n<li>How should I handle promoting releases between environments?</li>\n</ol>\n\n<p>In <a href="https://codefresh.io/about-gitops/branches-gitops-environments/">the previous article of the series</a>, I focused on what NOT to do and explained why using Git branches for different environments is a bad idea. I also hinted that the “environment-per-folder” approach is a better idea. This article has proved hugely popular and several people wanted to see all the details about the suggested structure for environments when folders are used.</p>\n\n<p>In this article, I am going to explain how to model your GitOps environments using different folders on the same Git branch, and as an added bonus, how to handle environment promotion (both simple and complex) with simple file copy operations.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Z1Aoaz7K--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6xd34ou4vc1lwvnm71vc.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Z1Aoaz7K--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6xd34ou4vc1lwvnm71vc.png" alt="GitOps promotion" loading="lazy" width="851" height="218"></a></p>\n\n<p>Hopefully this article will help with the endless stream of <a href="https://github.com/argoproj/argocd-example-apps/issues/57">questions</a> and <a href="https://github.com/argoproj/argo-cd/discussions/5667">discussions</a> on this hot topic.</p>\n\n<h2>\n  <a name="learn-your-application-first" href="#learn-your-application-first">\n  </a>\n  Learn your application first\n</h2>\n\n<p>Before creating your folder structure you need to do some research first and understand the “settings” of your application. Even though several people talk about application configuration in a generic manner, in reality not all configuration settings are equally important.</p>\n\n<p>In the context of a Kubernetes application, we have the following categories of “environment configuration”:</p>\n\n<ol>\n<li>The <strong>application version</strong> in the form of the container tag used. This is probably the most important setting in a Kubernetes manifest (as far as environment promotions are concerned). Depending on your use case, you might get away with simply changing the version of the container image. However, several times a new change in the source code also requires a new change in the deployment environment</li>\n<li>\n<strong>Kubernetes specific settings</strong> for your application. This includes the replicas of the application and other Kubernetes related information such as resource limits, health checks, persistent volumes, affinity rules, etc.</li>\n<li>Mostly <strong>static business settings</strong>. This is the set of settings that are unrelated to Kubernetes but have to do with the business of your application. It might be external URLs, internal queue sizes, UI defaults, authentication profiles, etc. By “mostly static,” I mean settings that are defined once for each environment and then never change afterwards. For example, you always want your production environment to use production.paypal.com and your non-production environments to use staging.paypal.com. This is a setting that you never want to promote between environments</li>\n<li>\n<strong>Non-static business settings</strong>. This is the same thing as the previous point, but it includes settings that you DO want to promote between environments. This could be a global VAT setting, your recommendation engine parameters, the available bitrate encodings, and any other setting that is specific to your business.</li>\n</ol>\n\n<p>It is imperative that you understand what all the different settings are and, more importantly, which of them belong to category 4 as these are the ones that you also want to promote along with your application version.</p>\n\n<p>This way you can cover all possible promotion scenarios:</p>\n\n<ol>\n<li>Your application moves from version 1.34 to 1.35 in QA. This is a simple source code change. Therefore you only need to change the container image property in your QA environment.</li>\n<li>Your application moves from version 3.23 to 3.24 in Staging. This is not a simple source code change. You need to update the container image property and also bring the new setting “recommender.batch_size” from QA to staging.</li>\n</ol>\n\n<p>I see too many teams that don’t understand the distinction between different configuration parameters and have a single configuration file (or mechanism) with values from different areas (i.e. both runtime and application business settings).</p>\n\n<p>Once you have the list of your settings and which area they belong to, you are ready to create your environment structure and optimize the file copy operations for the settings that change a lot and need to be moved between environments.</p>\n\n<h2>\n  <a name="example-with-5-gitops-environments-and-variations-between-them" href="#example-with-5-gitops-environments-and-variations-between-them">\n  </a>\n  Example with 5 GitOps environments and variations between them\n</h2>\n\n<p>Let’s see an actual example. I thought about doing the classic QA/Staging/Production trilogy, but this is rather boring so let’s dive into a more realistic example. </p>\n\n<p>We are going to model the environment situation mentioned in the first article of the series. The company that we will examine has 5 distinct environments:</p>\n\n<ul>\n<li>Load Testing</li>\n<li>Integration Testing</li>\n<li>QA</li>\n<li>Staging</li>\n<li>Production</li>\n</ul>\n\n<p>Then let’s assume that the last 2 environments are also deployed to EU, US, and Asia while the first 2 also have GPU and Non-GPU variations. This means that the company has a total of 11 environments. </p>\n\n<p>You can find the suggested folder structure at  <a href="https://github.com/kostis-codefresh/gitops-environment-promotion">https://github.com/kostis-codefresh/gitops-environment-promotion</a>. All environments are different folders in the same branch. There are NO branches for the different environments. If you want to know what is deployed in an environment, you simply look at envs/ in the main branch of the repo.</p>\n\n<p>Before we explain the structure, here are some disclaimers: </p>\n\n<p><strong>Disclaimer 1:</strong> Writing this article took a long time because I wasn’t sure if I should cover <a href="https://kustomize.io/">Kustomize</a> or <a href="https://helm.sh/">Helm</a> or plain manifests. I chose Kustomize as it makes things a bit easier (and I also mention Helm at the end of the article). Note however that the Kustomize templates in the example repo are simply for illustration purposes. The present article is NOT a Kustomize tutorial. In a real application, you might have <a href="https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/configmapgenerator/">Configmap generators</a>, <a href="https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesstrategicmerge/">custom patches</a> and adopt a completely different “component” structure than the one I am showing here. If you are not familiar with Kustomize, spend some time understanding its capabilities first and then come back to this article.</p>\n\n<p><strong>Disclaimer 2:</strong> The <a href="https://github.com/kostis-codefresh/gitops-promotion-source-code">application I use</a> for the promotions is completely dummy, and its configuration misses several best practices mainly for brevity and simplicity reasons. For example, some deployments are missing <a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">health checks</a>, and all of them are missing <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/">resource limits</a>. Again, this article is NOT about how to create Kubernetes deployments. You should already know how proper deployment manifests look. If you want to learn more about production-grade best practices, then see my other article at <a href="https://codefresh.io/kubernetes-tutorial/kubernetes-antipatterns-1/">https://codefresh.io/kubernetes-tutorial/kubernetes-antipatterns-1/</a></p>\n\n<p>With the disclaimers out of the way, here is the repository structure:</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--NmdZpVhJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7kluawshadkmduowh8wa.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--NmdZpVhJ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7kluawshadkmduowh8wa.jpg" alt="GitOps folder structure" loading="lazy" width="566" height="627"></a> </p>\n\n<p>The base directory holds configuration which is common to all environments. It is not expected to change often. If you want to do changes to multiple environments at the same time, it is best to use the “variants” folder.</p>\n\n<p>The variants folder (a.k.a mixins, a.k.a. components) holds common characteristics between environments. It is up to you to define what exactly you think is “common” between your environments after researching your application as discussed in the previous section.</p>\n\n<p>In the example application, we have variants for all prod and non-prod environments and also the regions. Here is an example of the <a href="https://raw.githubusercontent.com/kostis-codefresh/gitops-environment-promotion/main/variants/prod/prod.yml">prod variant</a> that applies to ALL production environments.<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight yaml"><code><span class="nn">---</span>\n<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>\n<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>\n<span class="na">metadata</span><span class="pi">:</span>\n  <span class="na">name</span><span class="pi">:</span> <span class="s">simple-deployment</span>\n<span class="na">spec</span><span class="pi">:</span>\n  <span class="na">template</span><span class="pi">:</span>\n    <span class="na">spec</span><span class="pi">:</span>\n      <span class="na">containers</span><span class="pi">:</span>\n      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">webserver-simple</span>\n        <span class="na">env</span><span class="pi">:</span>\n        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">ENV_TYPE</span>\n          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">production"</span>\n        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">PAYPAL_URL</span>\n          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">production.paypal.com"</span>   \n        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">DB_USER</span>\n          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">prod_username"</span>\n        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">DB_PASSWORD</span>\n          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">prod_password"</span>                     \n        <span class="na">livenessProbe</span><span class="pi">:</span>\n          <span class="na">httpGet</span><span class="pi">:</span>\n            <span class="na">path</span><span class="pi">:</span> <span class="s">/health</span>\n            <span class="na">port</span><span class="pi">:</span> <span class="m">8080</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>In the example above, we make sure that all production environments are using the production DB credentials, the production payment gateway, and a liveness probe (this is a contrived example, please see disclaimer 2 at the start of this section). These settings belong to the set of configuration that we don’t expect to promote between environments, but we assume that they will be static across the application lifecycle.</p>\n\n<p>With the base and variants ready, we can now define every final environment with a combination of those properties.</p>\n\n<p>Here is an example of the <a href="https://github.com/kostis-codefresh/gitops-environment-promotion/tree/main/envs/staging-asia">staging ASIA environment</a>:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight yaml"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">kustomize.config.k8s.io/v1beta1</span>\n<span class="na">kind</span><span class="pi">:</span> <span class="s">Kustomization</span>\n\n<span class="na">namespace</span><span class="pi">:</span> <span class="s">staging</span>\n<span class="na">namePrefix</span><span class="pi">:</span> <span class="s">staging-asia-</span>\n\n<span class="na">resources</span><span class="pi">:</span>\n<span class="pi">-</span> <span class="s">../../base</span>\n\n<span class="na">components</span><span class="pi">:</span>\n  <span class="pi">-</span> <span class="s">../../variants/non-prod</span>\n  <span class="pi">-</span> <span class="s">../../variants/asia</span>\n\n<span class="na">patchesStrategicMerge</span><span class="pi">:</span>\n<span class="pi">-</span> <span class="s">deployment.yml</span>\n<span class="pi">-</span> <span class="s">version.yml</span>\n<span class="pi">-</span> <span class="s">replicas.yml</span>\n<span class="pi">-</span> <span class="s">settings.yml</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>First we define some common properties. We inherit all configuration from base, from non-prod environments, and for all environments in Asia.</p>\n\n<p>The key point here is the patches that we apply. The <a href="https://github.com/kostis-codefresh/gitops-environment-promotion/blob/main/envs/staging-asia/version.yml">version.yml</a> and <a href="https://github.com/kostis-codefresh/gitops-environment-promotion/blob/main/envs/staging-asia/replicas.yml">replicas.yml</a> are self-explanatory. They only define the image and replicas on their own and nothing else.</p>\n\n<p>The version.yml file (which is the most important thing to promote between environments) defines only the image of the application and nothing else.<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight yaml"><code><span class="nn">---</span>\n<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>\n<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>\n<span class="na">metadata</span><span class="pi">:</span>\n  <span class="na">name</span><span class="pi">:</span> <span class="s">simple-deployment</span>\n<span class="na">spec</span><span class="pi">:</span>\n  <span class="na">template</span><span class="pi">:</span>\n    <span class="na">spec</span><span class="pi">:</span>\n      <span class="na">containers</span><span class="pi">:</span>\n      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">webserver-simple</span>\n        <span class="na">image</span><span class="pi">:</span> <span class="s">docker.io/kostiscodefresh/simple-env-app:2.0</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>The associated settings for each release that we <strong>DO</strong> expect to promote between environments are also defined in <a href="https://github.com/kostis-codefresh/gitops-environment-promotion/blob/main/envs/staging-asia/settings.yml">settings.yml</a><br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight yaml"><code><span class="nn">---</span>\n<span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>\n<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>\n<span class="na">metadata</span><span class="pi">:</span>\n  <span class="na">name</span><span class="pi">:</span> <span class="s">simple-deployment</span>\n<span class="na">spec</span><span class="pi">:</span>\n  <span class="na">template</span><span class="pi">:</span>\n    <span class="na">spec</span><span class="pi">:</span>\n      <span class="na">containers</span><span class="pi">:</span>\n      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">webserver-simple</span>\n        <span class="na">env</span><span class="pi">:</span>\n        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">UI_THEME</span>\n          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">dark"</span>\n        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">CACHE_SIZE</span>\n          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1024kb"</span>\n        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">PAGE_LIMIT</span>\n          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">25"</span>\n        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">SORTING</span>\n          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">ascending"</span>    \n        <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">N_BUCKETS</span>\n          <span class="na">value</span><span class="pi">:</span> <span class="s2">"</span><span class="s">42"</span>         \n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>Feel free to look at the <a href="https://github.com/kostis-codefresh/gitops-environment-promotion">whole repository</a> to understand the way all kustomizations are formed.</p>\n\n<h2>\n  <a name="performing-the-initial-deployment-via-gitops" href="#performing-the-initial-deployment-via-gitops">\n  </a>\n  Performing the initial deployment via GitOps\n</h2>\n\n<p>To deploy an application to its associated environment, just point your GitOps controller to the respective “env” folder and kustomize will create the complete hierarchy of settings and values.</p>\n\n<p>Here is the <a href="https://github.com/kostis-codefresh/gitops-promotion-source-code">example application</a> as it runs in Staging/Asia.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Xh2Td7RF--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jthmsbi5qg1hsfhf46wq.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Xh2Td7RF--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jthmsbi5qg1hsfhf46wq.jpg" alt="GitOps application example" loading="lazy" width="537" height="360"></a></p>\n\n<p>You can also use Kustomize on the command line to preview what is going to be deployed for each environment. Examples:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight shell"><code>kustomize build envs/staging-asia\nkustomize build envs/qa\nkustomize build envs/integration-gpu\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>You can of course pipe the output to kubectl to deploy each environment, but in the context of GitOps, you should always let your GitOps controller deploy your environments and avoid manual kubectl operations.</p>\n\n<h2>\n  <a name="comparing-the-configuration-of-two-environments" href="#comparing-the-configuration-of-two-environments">\n  </a>\n  Comparing the configuration of two environments\n</h2>\n\n<p>A very common need for a software team is to understand what is different between two environments. I have seen several teams who have the misconception that only with branches you can easily find differences between environments.</p>\n\n<p>This could not be further from the truth. You can easily use mature file-diffing utilities to find what is different between environments just by comparing files and folders.</p>\n\n<p>The simplest way is to diff only the settings that are critical to the app.<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight shell"><code>vimdiff envs/integration-gpu/settings.yml envs/integration-non-gpu/settings.yml\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--wLakkrDX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8xsimyy6qbq5920lqkf6.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--wLakkrDX--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8xsimyy6qbq5920lqkf6.jpg" alt="GitOps settings diff" loading="lazy" width="880" height="480"></a></p>\n\n<p>And with the help of kustomize, you can compare any number of whole environments for the full picture:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight shell"><code>kustomize build envs/qa/&gt; /tmp/qa.yml\nkustomize build envs/staging-us/ <span class="o">&gt;</span> /tmp/staging-us.yml\nkustomize build envs/prod-us/ <span class="o">&gt;</span> /tmp/prod-us.yml\nvimdiff /tmp/staging-us.yml /tmp/qa.yml /tmp/prod-us.yml\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--5wSVXrSB--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mjwjvvgiu2i9vgokr0n3.jpg" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--5wSVXrSB--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mjwjvvgiu2i9vgokr0n3.jpg" alt="GitOps environment diff" loading="lazy" width="880" height="447"></a></p>\n\n<p>I personally don’t see any disadvantage between this method and performing “git diff” between environment branches.</p>\n\n<h2>\n  <a name="how-to-perform-promotions-between-gitops-environments" href="#how-to-perform-promotions-between-gitops-environments">\n  </a>\n  How to perform promotions between GitOps environments\n</h2>\n\n<p>Now that the file structure is clear, we can finally answer the age-old question “how do I promote releases with GitOps”?</p>\n\n<p>Let’s see some promotion scenarios. If you have been paying attention to the file structure, you should already understand how all promotions resolve to simple file copy operations.</p>\n\n<p><strong>Scenario:</strong> Promote application version from QA to staging environment in the US:</p>\n\n<ol>\n<li>cp envs/qa/version.yml envs/staging-us/version.yml</li>\n<li>commit/push changes</li>\n</ol>\n\n<p><strong>Scenario:</strong> Promote application version from integration testing (GPU) to load testing (GPU) and then to QA. This is a 2 step process</p>\n\n<ol>\n<li>cp envs/integration-gpu/version.yml  envs/load-gpu/version.yml</li>\n<li>commit/push changes</li>\n<li>cp envs/load-gpu/version.yml  envs/qa/version.yml</li>\n<li>commit/push changes</li>\n</ol>\n\n<p><strong>Scenario:</strong> Promote an application from prod-eu to prod-us along with the extra configuration. Here we also copy our setting file(s).</p>\n\n<ol>\n<li>cp envs/prod-eu/version.yml  envs/prod-us/version.yml</li>\n<li>cp envs/prod-eu/settings.yml  envs/prod-us/settings.yml</li>\n<li>commit/push changes</li>\n</ol>\n\n<p><strong>Scenario:</strong> Make sure that QA has the same replica count as staging-asia</p>\n\n<ol>\n<li>cp envs/staging-asia/replicas.yml envs/qa/replicas.yml</li>\n<li>commit/push changes</li>\n</ol>\n\n<p><strong>Scenario:</strong> Backport all settings from qa to integration testing (non-gpu variant)</p>\n\n<ol>\n<li>cp envs/qa/settings.yml envs/integration-non-gpu/settings.yml</li>\n<li>commit/push changes</li>\n</ol>\n\n<p><strong>Scenario:</strong> Make a global change to all non-prod environments at once (but see also next section for some discussion on this operation)</p>\n\n<ol>\n<li>Make your change in variants/non-prod/non-prod.yml </li>\n<li>commit/push changes</li>\n</ol>\n\n<p><strong>Scenario:</strong> Add a new configuration file to all US environments (both production and staging).</p>\n\n<ol>\n<li>Add the new manifest in the variants/us folder</li>\n<li>Modify the variants/us/kustomization.yml file to include the new manifest</li>\n<li>commit/push changes</li>\n</ol>\n\n<p>In general, all promotions are just copy operations. Unlike the environment-per-branch approach, you are now free to promote anything from any environment to any other environment without any fear of taking the wrong changes. Especially when it comes to back-porting configuration, environment-per-folder really shines as you can simply move configuration both “upwards” and “backwards” even between unrelated environments.</p>\n\n<p>Note that I am using cp operations just for illustration purposes. In a real application, this operation would be performed automatically by your CI system or other orchestration tool. And depending on the environment, you might want to create a Pull Request first instead of directly editing the folder in the main branch.</p>\n\n<h2>\n  <a name="making-changes-to-multiple-environments-at-once" href="#making-changes-to-multiple-environments-at-once">\n  </a>\n  Making changes to multiple environments at once\n</h2>\n\n<p>Several people have asked in the comments of the <a href="https://codefresh.io/about-gitops/branches-gitops-environments/">first article</a> about the use-case of changing multiple environments at once and how to achieve and/or prevent this scenario.</p>\n\n<p>First of all, we need to define what exactly we mean by “multiple” environments. We can assume the following 2 cases.</p>\n\n<ol>\n<li>Changing multiple environments at once that are on the same “level.” As an example, you want to make a change that affects prod-us, prod-eu and prod-asia at the same time</li>\n<li>Changing multiple environments at once that are <strong>NOT</strong> on the same level. As an example, you want to make a change to “integration” and “staging-eu” at the same time</li>\n</ol>\n\n<p>The first case is a valid scenario, and we will cover this below. However, I consider the second scenario an anti-pattern. The whole point of having different environments is to be able to release things in a gradual way and promote a change from one environment to the next. So if you find yourself deploying the same change in environments of different importance, ask yourself if this is really needed and why.</p>\n\n<p>For the valid scenario of deploying a single change to multiple “similar” environments, there are two strategies:</p>\n\n<ol>\n<li>If you are absolutely certain that the change is “safe” and you want it to reach all environments at once, you can make that change in the appropriate variant (or respective folders). For example, if you commit/push a change in the variants/non-prod folder then all non-production environments will get this change at the same time. I am personally <strong>against</strong> this approach because several changes look “safe” in theory but can be problematic in practice</li>\n<li>The preferable approach is to apply the change to each individual folder and then move it to the “parent” variant when it is live on all environments.</li>\n</ol>\n\n<p>Let’s take an example. We want to make a change that affects all EU environments (e.g. a GDPR feature). The naive way would be to commit/push the configuration change directly to variants/eu folder. This would indeed affect all EU environments (prod-eu and staging-eu). However this is a bit risky, because if the deployment fails, you have just brought down a production environment.</p>\n\n<p>The suggested approach is the following:</p>\n\n<ol>\n<li>Make the change to envs/staging-eu first</li>\n<li>Then make the same change to envs/prod-eu</li>\n<li>Finally, delete the change from both environments and add it in variants/eu (in a single commit/push action).</li>\n</ol>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--mWt2fn1G--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aidbyxfyiw4e5zq80wh6.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--mWt2fn1G--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aidbyxfyiw4e5zq80wh6.png" alt="Gradual GitOps promotion" loading="lazy" width="880" height="585"></a></p>\n\n<p>You might recognize this pattern from gradual <a href="https://databaserefactoring.com/">database refactorings</a>. The final commit is “transitional” in the sense that it doesn’t really affect any environments in any way. Kustomize will create the exact same definition in both cases. Your GitOps controller shouldn’t find any differences at all.</p>\n\n<p>The advantages of this approach are of course the easy way to rollback/revert the change as you move it through environments. The disadvantage is the increased effort (and commits) you need to promote the change to all environments, but I believe that the effort outweighs the risks.</p>\n\n<p>If you adopt this approach, it means that you <strong>never</strong> apply new changes to the base folder directly. If you want a change to happen to all environments, you first apply the change to individual environments and/or variants and then backport it to the base folder while simultaneously removing it from all downstream folders.</p>\n\n<h2>\n  <a name="the-advantages-of-the-environmentperfolder-approach" href="#the-advantages-of-the-environmentperfolder-approach">\n  </a>\n  The advantages of the “environment-per-folder” approach\n</h2>\n\n<p>Now that we have analyzed all the inner workings of the “environment-per-folder” approach, it is time to explain why it is better than the “environment-per-branch” approach. If you have been paying attention to the previous sections, you should already understand how the “environment-per-folder” approach directly avoids all the problems analyzed in the <a href="https://codefresh.io/about-gitops/branches-gitops-environments/">previous article</a>. </p>\n\n<p>The most glaring issues with environment branches is the order of commits and the danger of bringing unwanted changes when you merge from one environment to another. With the folder approach, this problem is completely eliminated:</p>\n\n<ol>\n<li>The order of commits on the repo is now irrelevant. When you copy a file from one folder to the next, you don’t care about its commit history, just its content</li>\n<li>By only copying files around, you only take exactly what you need and nothing else. When you copy envs/qa/version.yml to envs/staging-asia/version.yml you can be certain that you only promote the container image and nothing else. If somebody else has changed the replicas in the QA environment in the meantime, it doesn’t affect your promotion action.</li>\n<li>You don’t need to use git cherry-picks or any other advanced git method to promote releases. You only copy files around and have access to the mature ecosystem of utilities for file processing.</li>\n<li>You are free to take any change from any environment to either an upstream or downstream environment without any constraints about the correct “order” of environments. If for example you want to backport your settings from production US to staging US, you can do a simple copy operation of envs/prod-us/settings.yml to envs/staging-us/settings.yml without the fear that you might take inadvertently unrelated hotfixes that were supposed to be only in production.</li>\n<li>You can easily use file diff operations to understand what is different between environments in all directions (both from source and target environments and vice versa)</li>\n</ol>\n\n<p>I consider these advantages very important for any non-trivial application, and I bet that several “failed deployments” in big organizations could be directly or indirectly attributed to the problematic environment-per-branch model.</p>\n\n<p>The second problem mentioned in the previous article was the presence of configuration drift when you merge a branch to the next environment. The reason for this is that when you do a “git merge,” git only notifies you about the changes it will bring, and it doesn’t say anything about what changes are already in the target branch.</p>\n\n<p>Again this problem is completely eliminated with folders. As we said already, file diff operations have no concept of “direction.” You can copy any setting from any environment either upwards or downwards, and if you do a diff operation on the files, you will see all changes between environments regardless of their upstream/downstream position.</p>\n\n<p>The last point about environment branches was the linear complexity of branches as the number of environments grows. With 5 environments, you need to juggle changes between 5 branches, and with 20 environments, you need to have 20 branches. Moving a release correctly between a large number of branches is a cumbersome process, and in the case of production environments, it is a recipe for disaster.</p>\n\n<p>With the folder approach, the number of branches is not only static but it is exactly 1. If you have 5 environments you manage them all with your “main” branch, and if you need more environments, you only add extra folders. If you have 20 environments, you still need a single Git branch. Getting a centralized view on what is deployed where is trivial when you have a single branch.</p>\n\n<h2>\n  <a name="using-helm-with-gitops-environments" href="#using-helm-with-gitops-environments">\n  </a>\n  Using Helm with GitOps environments\n</h2>\n\n<p>If you don’t use Kustomize but prefer Helm instead, it is also possible to create a hierarchy of folders with “common” stuff for all environments, specific features/mixins/components, and final folders specific to each environment.</p>\n\n<p>Here is how the folder structure would look like<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight plaintext"><code>chart/\n  [...chart files here..]\ncommon/\n  values-common.yml\nvariants/\n  prod/\n     values-prod.yml\n  non-prod/\n    Values-non-prod.yml\n  [...other variants…]\n envs/\n     prod-eu/\n           values-env-default.yaml\n           values-replicas.yaml\n           values-version.yaml\n           values-settings.yaml\n   [..other environments…]\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>Again you need to spend some time to examine your application properties and decide how to split them into different value files for optimal promotion speed.</p>\n\n<p>Other than this, most of the processes are the same when it comes to environment promotion.</p>\n\n<p><strong>Scenario:</strong> Promote application version from  QA to staging environment in the US:</p>\n\n<ol>\n<li>cp envs/qa/values-version.yml envs/staging-us/values-version.yml</li>\n<li>commit/push changes</li>\n</ol>\n\n<p><strong>Scenario:</strong> Promote application version from integration testing (GPU) to load testing (GPU) and then to QA. This is a 2 step process</p>\n\n<ol>\n<li>cp envs/integration-gpu/values-version.yml  envs/load-gpu/values-version.yml</li>\n<li>commit/push changes</li>\n<li>cp envs/load-gpu/values-version.yml  envs/qa/values-version.yml</li>\n<li>commit/push changes</li>\n</ol>\n\n<p><strong>Scenario:</strong> Promote an application from prod-eu to prod-us along with the extra configuration. Here we also copy our setting file(s).</p>\n\n<ol>\n<li>cp envs/prod-eu/values-version.yml  envs/prod-us/values-version.yml</li>\n<li>cp envs/prod-eu/values-settings.yml  envs/prod-us/values-settings.yml</li>\n<li>commit/push changes</li>\n</ol>\n\n<p>It is also critical to understand how Helm (or your GitOps agent which handles Helm) works with multiple value files and the order in which they override each other.</p>\n\n<p>If you want to preview one of your environments, instead of “kustomize build” you can use the following command<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight shell"><code>helm template chart/ <span class="nt">--values</span> common/values-common.yaml <span class="nt">--values</span> variants/prod/values-prod.yaml –values envs/prod-eu/values-env-default.yml –values envs/prod-eu/values-replicas.yml –values envs/prod-eu/values-version.yml –values envs/prod-eu/values-settings.yml\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>You can see that Helm is a bit more cumbersome than Kustomize, if you have a large number of variants or files in each environment folder.</p>\n\n<h2>\n  <a name="the-environmentpergitrepo-approach" href="#the-environmentpergitrepo-approach">\n  </a>\n  The “environment-per-git-repo” approach\n</h2>\n\n<p>When I talk with big organizations about the folder approach, one of the first objections I see is that people (especially security teams) don’t like to see a single branch in a single Git repository that contains both prod and non-prod environments.</p>\n\n<p>This is an understandable objection and arguably can be the single weak point of the folder approach against the “environment-per-branch” paradigm. After all, it is much easier to secure individual branches in a Git repository instead of folders in a single branch.</p>\n\n<p>This problem can be easily solved with automation, validation checks, or even manual approvals if you think it is critical for your organization. I want to stress again that I only use “cp” in the file operations for promoting releases just for illustration purposes. It doesn\'t mean that an actual human should run cp manually in an interactive terminal when a promotion happens.</p>\n\n<p>Ideally you should have an automated system that copies files around and commits/pushes them. This can be your Continuous Integration (CI) system or other platform that deals with your software lifecycle. And if you still have humans that make the changes themselves, they should never commit to “main” directly. They should open a Pull Request instead. Then you should have a proper workflow that checks that Pull Request before merging.</p>\n\n<p>I realize however that some organizations are particularly sensitive to security issues and they prefer a bulletproof approach when it comes to Git protection. For these organizations, you can employ 2 Git repositories. One has the base configuration, all prod variants, and all prod environments (and everything else related to production) while the second Git repository has all non-production stuff.</p>\n\n<p>This approach makes promotions a bit harder, as now you need to checkout 2 git repositories before doing any promotion. On the other hand, it allows your security team to place extra security constraints to the “production” Git repository, and you still have a static number of Git repositories (exactly 2) regardless of the amount of environments you deploy to.</p>\n\n<p>I personally consider this approach an overkill that, at least to me, shows a lack of trust against developers and operators. The discussion on whether or not people should have direct access to production environments is a complex one and probably deserves a blog post on its own.</p>\n\n<h2>\n  <a name="embrace-folders-and-forget-branches" href="#embrace-folders-and-forget-branches">\n  </a>\n  Embrace folders and forget branches\n</h2>\n\n<p>We hope that with this blog post we addressed all the questions that arose from the “don’t use branches for environments” article and you now have a good understanding about the benefits of the folder approach and why you should use it.</p>\n\n<p>If you have other interesting use cases or have extra questions on the subject of organizing your GitOps environments, please ask in the comments section.</p>\n\n<p>Happy GitOps deployments!</p>\n\n',t.body_markdown='Two of the most important questions that people ask themselves on day 2 after adopting GitOps are:\n\n1. How should I represent different environments on Git?\n1. How should I handle promoting releases between environments?\n\nIn [the previous article of the series](https://codefresh.io/about-gitops/branches-gitops-environments/), I focused on what NOT to do and explained why using Git branches for different environments is a bad idea. I also hinted that the “environment-per-folder” approach is a better idea. This article has proved hugely popular and several people wanted to see all the details about the suggested structure for environments when folders are used.\n\nIn this article, I am going to explain how to model your GitOps environments using different folders on the same Git branch, and as an added bonus, how to handle environment promotion (both simple and complex) with simple file copy operations.\n\n\n![GitOps promotion](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6xd34ou4vc1lwvnm71vc.png)\n\nHopefully this article will help with the endless stream of [questions](https://github.com/argoproj/argocd-example-apps/issues/57) and [discussions](https://github.com/argoproj/argo-cd/discussions/5667) on this hot topic.\n\n## Learn your application first\n\nBefore creating your folder structure you need to do some research first and understand the “settings” of your application. Even though several people talk about application configuration in a generic manner, in reality not all configuration settings are equally important.\n\nIn the context of a Kubernetes application, we have the following categories of “environment configuration”:\n\n1. The **application version** in the form of the container tag used. This is probably the most important setting in a Kubernetes manifest (as far as environment promotions are concerned). Depending on your use case, you might get away with simply changing the version of the container image. However, several times a new change in the source code also requires a new change in the deployment environment\n1. **Kubernetes specific settings** for your application. This includes the replicas of the application and other Kubernetes related information such as resource limits, health checks, persistent volumes, affinity rules, etc.\n1. Mostly **static business settings**. This is the set of settings that are unrelated to Kubernetes but have to do with the business of your application. It might be external URLs, internal queue sizes, UI defaults, authentication profiles, etc. By “mostly static,” I mean settings that are defined once for each environment and then never change afterwards. For example, you always want your production environment to use production.paypal.com and your non-production environments to use staging.paypal.com. This is a setting that you never want to promote between environments\n1. **Non-static business settings**. This is the same thing as the previous point, but it includes settings that you DO want to promote between environments. This could be a global VAT setting, your recommendation engine parameters, the available bitrate encodings, and any other setting that is specific to your business.\n\nIt is imperative that you understand what all the different settings are and, more importantly, which of them belong to category 4 as these are the ones that you also want to promote along with your application version.\n\nThis way you can cover all possible promotion scenarios:\n\n1. Your application moves from version 1.34 to 1.35 in QA. This is a simple source code change. Therefore you only need to change the container image property in your QA environment.\n1. Your application moves from version 3.23 to 3.24 in Staging. This is not a simple source code change. You need to update the container image property and also bring the new setting “recommender.batch_size” from QA to staging.\n\nI see too many teams that don’t understand the distinction between different configuration parameters and have a single configuration file (or mechanism) with values from different areas (i.e. both runtime and application business settings).\n\nOnce you have the list of your settings and which area they belong to, you are ready to create your environment structure and optimize the file copy operations for the settings that change a lot and need to be moved between environments.\n\n## Example with 5 GitOps environments and variations between them\n\nLet’s see an actual example. I thought about doing the classic QA/Staging/Production trilogy, but this is rather boring so let’s dive into a more realistic example. \n\nWe are going to model the environment situation mentioned in the first article of the series. The company that we will examine has 5 distinct environments:\n\n * Load Testing\n * Integration Testing\n * QA\n * Staging\n * Production\n\nThen let’s assume that the last 2 environments are also deployed to EU, US, and Asia while the first 2 also have GPU and Non-GPU variations. This means that the company has a total of 11 environments. \n\nYou can find the suggested folder structure at  [https://github.com/kostis-codefresh/gitops-environment-promotion](https://github.com/kostis-codefresh/gitops-environment-promotion). All environments are different folders in the same branch. There are NO branches for the different environments. If you want to know what is deployed in an environment, you simply look at envs/<environment-name> in the main branch of the repo.\n\nBefore we explain the structure, here are some disclaimers: \n\n**Disclaimer 1:** Writing this article took a long time because I wasn’t sure if I should cover [Kustomize](https://kustomize.io/) or [Helm](https://helm.sh/) or plain manifests. I chose Kustomize as it makes things a bit easier (and I also mention Helm at the end of the article). Note however that the Kustomize templates in the example repo are simply for illustration purposes. The present article is NOT a Kustomize tutorial. In a real application, you might have [Configmap generators](https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/configmapgenerator/), [custom patches](https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/patchesstrategicmerge/) and adopt a completely different “component” structure than the one I am showing here. If you are not familiar with Kustomize, spend some time understanding its capabilities first and then come back to this article.\n\n**Disclaimer 2:** The [application I use](https://github.com/kostis-codefresh/gitops-promotion-source-code) for the promotions is completely dummy, and its configuration misses several best practices mainly for brevity and simplicity reasons. For example, some deployments are missing [health checks](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/), and all of them are missing [resource limits](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/). Again, this article is NOT about how to create Kubernetes deployments. You should already know how proper deployment manifests look. If you want to learn more about production-grade best practices, then see my other article at [https://codefresh.io/kubernetes-tutorial/kubernetes-antipatterns-1/](https://codefresh.io/kubernetes-tutorial/kubernetes-antipatterns-1/ )\n\nWith the disclaimers out of the way, here is the repository structure:\n\n\n![GitOps folder structure](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7kluawshadkmduowh8wa.jpg) \n\nThe base directory holds configuration which is common to all environments. It is not expected to change often. If you want to do changes to multiple environments at the same time, it is best to use the “variants” folder.\n\nThe variants folder (a.k.a mixins, a.k.a. components) holds common characteristics between environments. It is up to you to define what exactly you think is “common” between your environments after researching your application as discussed in the previous section.\n\nIn the example application, we have variants for all prod and non-prod environments and also the regions. Here is an example of the [prod variant](https://raw.githubusercontent.com/kostis-codefresh/gitops-environment-promotion/main/variants/prod/prod.yml) that applies to ALL production environments.\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: simple-deployment\nspec:\n  template:\n    spec:\n      containers:\n      - name: webserver-simple\n        env:\n        - name: ENV_TYPE\n          value: "production"\n        - name: PAYPAL_URL\n          value: "production.paypal.com"   \n        - name: DB_USER\n          value: "prod_username"\n        - name: DB_PASSWORD\n          value: "prod_password"                     \n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n```\n\nIn the example above, we make sure that all production environments are using the production DB credentials, the production payment gateway, and a liveness probe (this is a contrived example, please see disclaimer 2 at the start of this section). These settings belong to the set of configuration that we don’t expect to promote between environments, but we assume that they will be static across the application lifecycle.\n\nWith the base and variants ready, we can now define every final environment with a combination of those properties.\n\nHere is an example of the [staging ASIA environment](https://github.com/kostis-codefresh/gitops-environment-promotion/tree/main/envs/staging-asia):\n\n```yaml\napiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\n\nnamespace: staging\nnamePrefix: staging-asia-\n\nresources:\n- ../../base\n\ncomponents:\n  - ../../variants/non-prod\n  - ../../variants/asia\n\npatchesStrategicMerge:\n- deployment.yml\n- version.yml\n- replicas.yml\n- settings.yml\n```\n\nFirst we define some common properties. We inherit all configuration from base, from non-prod environments, and for all environments in Asia.\n\nThe key point here is the patches that we apply. The [version.yml](https://github.com/kostis-codefresh/gitops-environment-promotion/blob/main/envs/staging-asia/version.yml) and [replicas.yml](https://github.com/kostis-codefresh/gitops-environment-promotion/blob/main/envs/staging-asia/replicas.yml) are self-explanatory. They only define the image and replicas on their own and nothing else.\n\nThe version.yml file (which is the most important thing to promote between environments) defines only the image of the application and nothing else.\n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: simple-deployment\nspec:\n  template:\n    spec:\n      containers:\n      - name: webserver-simple\n        image: docker.io/kostiscodefresh/simple-env-app:2.0\n```\n\nThe associated settings for each release that we **DO** expect to promote between environments are also defined in [settings.yml](https://github.com/kostis-codefresh/gitops-environment-promotion/blob/main/envs/staging-asia/settings.yml) \n\n```yaml\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: simple-deployment\nspec:\n  template:\n    spec:\n      containers:\n      - name: webserver-simple\n        env:\n        - name: UI_THEME\n          value: "dark"\n        - name: CACHE_SIZE\n          value: "1024kb"\n        - name: PAGE_LIMIT\n          value: "25"\n        - name: SORTING\n          value: "ascending"    \n        - name: N_BUCKETS\n          value: "42"         \n```\n\nFeel free to look at the [whole repository](https://github.com/kostis-codefresh/gitops-environment-promotion) to understand the way all kustomizations are formed.\n\n## Performing the initial deployment via GitOps\n\nTo deploy an application to its associated environment, just point your GitOps controller to the respective “env” folder and kustomize will create the complete hierarchy of settings and values.\n\nHere is the [example application](https://github.com/kostis-codefresh/gitops-promotion-source-code) as it runs in Staging/Asia.\n\n\n![GitOps application example](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/jthmsbi5qg1hsfhf46wq.jpg)\n\n\nYou can also use Kustomize on the command line to preview what is going to be deployed for each environment. Examples:\n\n\n```shell\nkustomize build envs/staging-asia\nkustomize build envs/qa\nkustomize build envs/integration-gpu\n```\n\nYou can of course pipe the output to kubectl to deploy each environment, but in the context of GitOps, you should always let your GitOps controller deploy your environments and avoid manual kubectl operations.\n\n## Comparing the configuration of two environments\n\nA very common need for a software team is to understand what is different between two environments. I have seen several teams who have the misconception that only with branches you can easily find differences between environments.\n\nThis could not be further from the truth. You can easily use mature file-diffing utilities to find what is different between environments just by comparing files and folders.\n\nThe simplest way is to diff only the settings that are critical to the app.\n\n```shell\nvimdiff envs/integration-gpu/settings.yml envs/integration-non-gpu/settings.yml\n```\n\n\n![GitOps settings diff](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/8xsimyy6qbq5920lqkf6.jpg)\n\nAnd with the help of kustomize, you can compare any number of whole environments for the full picture:\n\n```shell\nkustomize build envs/qa/> /tmp/qa.yml\nkustomize build envs/staging-us/ > /tmp/staging-us.yml\nkustomize build envs/prod-us/ > /tmp/prod-us.yml\nvimdiff /tmp/staging-us.yml /tmp/qa.yml /tmp/prod-us.yml\n```\n\n\n![GitOps environment diff](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mjwjvvgiu2i9vgokr0n3.jpg)\n\nI personally don’t see any disadvantage between this method and performing “git diff” between environment branches.\n\n##How to perform promotions between GitOps environments\n\nNow that the file structure is clear, we can finally answer the age-old question “how do I promote releases with GitOps”?\n\nLet’s see some promotion scenarios. If you have been paying attention to the file structure, you should already understand how all promotions resolve to simple file copy operations.\n\n**Scenario:** Promote application version from QA to staging environment in the US:\n1. cp envs/qa/version.yml envs/staging-us/version.yml\n1. commit/push changes\n\n**Scenario:** Promote application version from integration testing (GPU) to load testing (GPU) and then to QA. This is a 2 step process\n1. cp envs/integration-gpu/version.yml  envs/load-gpu/version.yml\n1. commit/push changes\n1. cp envs/load-gpu/version.yml  envs/qa/version.yml\n1. commit/push changes\n\n**Scenario:** Promote an application from prod-eu to prod-us along with the extra configuration. Here we also copy our setting file(s).\n1. cp envs/prod-eu/version.yml  envs/prod-us/version.yml\n1. cp envs/prod-eu/settings.yml  envs/prod-us/settings.yml\n1. commit/push changes\n\n**Scenario:** Make sure that QA has the same replica count as staging-asia\n1. cp envs/staging-asia/replicas.yml envs/qa/replicas.yml\n1. commit/push changes\n\n**Scenario:** Backport all settings from qa to integration testing (non-gpu variant)\n1. cp envs/qa/settings.yml envs/integration-non-gpu/settings.yml\n1. commit/push changes\n\n**Scenario:** Make a global change to all non-prod environments at once (but see also next section for some discussion on this operation)\n1. Make your change in variants/non-prod/non-prod.yml \n1. commit/push changes\n\n**Scenario:** Add a new configuration file to all US environments (both production and staging).\n1. Add the new manifest in the variants/us folder\n1. Modify the variants/us/kustomization.yml file to include the new manifest\n1. commit/push changes\n\nIn general, all promotions are just copy operations. Unlike the environment-per-branch approach, you are now free to promote anything from any environment to any other environment without any fear of taking the wrong changes. Especially when it comes to back-porting configuration, environment-per-folder really shines as you can simply move configuration both “upwards” and “backwards” even between unrelated environments.\n\nNote that I am using cp operations just for illustration purposes. In a real application, this operation would be performed automatically by your CI system or other orchestration tool. And depending on the environment, you might want to create a Pull Request first instead of directly editing the folder in the main branch.\n\n## Making changes to multiple environments at once\n\nSeveral people have asked in the comments of the [first article](https://codefresh.io/about-gitops/branches-gitops-environments/) about the use-case of changing multiple environments at once and how to achieve and/or prevent this scenario.\n\nFirst of all, we need to define what exactly we mean by “multiple” environments. We can assume the following 2 cases.\n\n1. Changing multiple environments at once that are on the same “level.” As an example, you want to make a change that affects prod-us, prod-eu and prod-asia at the same time\n1. Changing multiple environments at once that are **NOT** on the same level. As an example, you want to make a change to “integration” and “staging-eu” at the same time\n\nThe first case is a valid scenario, and we will cover this below. However, I consider the second scenario an anti-pattern. The whole point of having different environments is to be able to release things in a gradual way and promote a change from one environment to the next. So if you find yourself deploying the same change in environments of different importance, ask yourself if this is really needed and why.\n\nFor the valid scenario of deploying a single change to multiple “similar” environments, there are two strategies:\n\n1. If you are absolutely certain that the change is “safe” and you want it to reach all environments at once, you can make that change in the appropriate variant (or respective folders). For example, if you commit/push a change in the variants/non-prod folder then all non-production environments will get this change at the same time. I am personally **against** this approach because several changes look “safe” in theory but can be problematic in practice\n1. The preferable approach is to apply the change to each individual folder and then move it to the “parent” variant when it is live on all environments.\n\nLet’s take an example. We want to make a change that affects all EU environments (e.g. a GDPR feature). The naive way would be to commit/push the configuration change directly to variants/eu folder. This would indeed affect all EU environments (prod-eu and staging-eu). However this is a bit risky, because if the deployment fails, you have just brought down a production environment.\n\nThe suggested approach is the following:\n\n1. Make the change to envs/staging-eu first\n1. Then make the same change to envs/prod-eu\n1. Finally, delete the change from both environments and add it in variants/eu (in a single commit/push action).\n\n\n![Gradual GitOps promotion](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aidbyxfyiw4e5zq80wh6.png)\n\nYou might recognize this pattern from gradual [database refactorings](https://databaserefactoring.com/). The final commit is “transitional” in the sense that it doesn’t really affect any environments in any way. Kustomize will create the exact same definition in both cases. Your GitOps controller shouldn’t find any differences at all.\n\nThe advantages of this approach are of course the easy way to rollback/revert the change as you move it through environments. The disadvantage is the increased effort (and commits) you need to promote the change to all environments, but I believe that the effort outweighs the risks.\n\nIf you adopt this approach, it means that you **never** apply new changes to the base folder directly. If you want a change to happen to all environments, you first apply the change to individual environments and/or variants and then backport it to the base folder while simultaneously removing it from all downstream folders.\n\n## The advantages of the “environment-per-folder” approach\n\nNow that we have analyzed all the inner workings of the “environment-per-folder” approach, it is time to explain why it is better than the “environment-per-branch” approach. If you have been paying attention to the previous sections, you should already understand how the “environment-per-folder” approach directly avoids all the problems analyzed in the [previous article](https://codefresh.io/about-gitops/branches-gitops-environments/). \n\nThe most glaring issues with environment branches is the order of commits and the danger of bringing unwanted changes when you merge from one environment to another. With the folder approach, this problem is completely eliminated:\n\n1. The order of commits on the repo is now irrelevant. When you copy a file from one folder to the next, you don’t care about its commit history, just its content\n1. By only copying files around, you only take exactly what you need and nothing else. When you copy envs/qa/version.yml to envs/staging-asia/version.yml you can be certain that you only promote the container image and nothing else. If somebody else has changed the replicas in the QA environment in the meantime, it doesn’t affect your promotion action.\n1. You don’t need to use git cherry-picks or any other advanced git method to promote releases. You only copy files around and have access to the mature ecosystem of utilities for file processing.\n1. You are free to take any change from any environment to either an upstream or downstream environment without any constraints about the correct “order” of environments. If for example you want to backport your settings from production US to staging US, you can do a simple copy operation of envs/prod-us/settings.yml to envs/staging-us/settings.yml without the fear that you might take inadvertently unrelated hotfixes that were supposed to be only in production.\n1. You can easily use file diff operations to understand what is different between environments in all directions (both from source and target environments and vice versa)\n\nI consider these advantages very important for any non-trivial application, and I bet that several “failed deployments” in big organizations could be directly or indirectly attributed to the problematic environment-per-branch model.\n\nThe second problem mentioned in the previous article was the presence of configuration drift when you merge a branch to the next environment. The reason for this is that when you do a “git merge,” git only notifies you about the changes it will bring, and it doesn’t say anything about what changes are already in the target branch.\n\nAgain this problem is completely eliminated with folders. As we said already, file diff operations have no concept of “direction.” You can copy any setting from any environment either upwards or downwards, and if you do a diff operation on the files, you will see all changes between environments regardless of their upstream/downstream position.\n\nThe last point about environment branches was the linear complexity of branches as the number of environments grows. With 5 environments, you need to juggle changes between 5 branches, and with 20 environments, you need to have 20 branches. Moving a release correctly between a large number of branches is a cumbersome process, and in the case of production environments, it is a recipe for disaster.\n\nWith the folder approach, the number of branches is not only static but it is exactly 1. If you have 5 environments you manage them all with your “main” branch, and if you need more environments, you only add extra folders. If you have 20 environments, you still need a single Git branch. Getting a centralized view on what is deployed where is trivial when you have a single branch.\n\n## Using Helm with GitOps environments\n\nIf you don’t use Kustomize but prefer Helm instead, it is also possible to create a hierarchy of folders with “common” stuff for all environments, specific features/mixins/components, and final folders specific to each environment.\n\nHere is how the folder structure would look like\n\n```\nchart/\n  [...chart files here..]\ncommon/\n  values-common.yml\nvariants/\n  prod/\n     values-prod.yml\n  non-prod/\n    Values-non-prod.yml\n  [...other variants…]\n envs/\n     prod-eu/\n           values-env-default.yaml\n           values-replicas.yaml\n           values-version.yaml\n           values-settings.yaml\n   [..other environments…]\n```\n\nAgain you need to spend some time to examine your application properties and decide how to split them into different value files for optimal promotion speed.\n\nOther than this, most of the processes are the same when it comes to environment promotion.\n\n**Scenario:** Promote application version from  QA to staging environment in the US:\n1. cp envs/qa/values-version.yml envs/staging-us/values-version.yml\n1. commit/push changes\n\n**Scenario:** Promote application version from integration testing (GPU) to load testing (GPU) and then to QA. This is a 2 step process\n1. cp envs/integration-gpu/values-version.yml  envs/load-gpu/values-version.yml\n1. commit/push changes\n1. cp envs/load-gpu/values-version.yml  envs/qa/values-version.yml\n1. commit/push changes\n\n**Scenario:** Promote an application from prod-eu to prod-us along with the extra configuration. Here we also copy our setting file(s).\n1. cp envs/prod-eu/values-version.yml  envs/prod-us/values-version.yml\n1. cp envs/prod-eu/values-settings.yml  envs/prod-us/values-settings.yml\n1. commit/push changes\n\n\nIt is also critical to understand how Helm (or your GitOps agent which handles Helm) works with multiple value files and the order in which they override each other.\n\nIf you want to preview one of your environments, instead of “kustomize build” you can use the following command \n\n```shell\nhelm template chart/ --values common/values-common.yaml --values variants/prod/values-prod.yaml –values envs/prod-eu/values-env-default.yml –values envs/prod-eu/values-replicas.yml –values envs/prod-eu/values-version.yml –values envs/prod-eu/values-settings.yml\n```\n\nYou can see that Helm is a bit more cumbersome than Kustomize, if you have a large number of variants or files in each environment folder.\n\n## The “environment-per-git-repo” approach\n\nWhen I talk with big organizations about the folder approach, one of the first objections I see is that people (especially security teams) don’t like to see a single branch in a single Git repository that contains both prod and non-prod environments.\n\nThis is an understandable objection and arguably can be the single weak point of the folder approach against the “environment-per-branch” paradigm. After all, it is much easier to secure individual branches in a Git repository instead of folders in a single branch.\n\nThis problem can be easily solved with automation, validation checks, or even manual approvals if you think it is critical for your organization. I want to stress again that I only use “cp” in the file operations for promoting releases just for illustration purposes. It doesn\'t mean that an actual human should run cp manually in an interactive terminal when a promotion happens.\n\nIdeally you should have an automated system that copies files around and commits/pushes them. This can be your Continuous Integration (CI) system or other platform that deals with your software lifecycle. And if you still have humans that make the changes themselves, they should never commit to “main” directly. They should open a Pull Request instead. Then you should have a proper workflow that checks that Pull Request before merging.\n\nI realize however that some organizations are particularly sensitive to security issues and they prefer a bulletproof approach when it comes to Git protection. For these organizations, you can employ 2 Git repositories. One has the base configuration, all prod variants, and all prod environments (and everything else related to production) while the second Git repository has all non-production stuff.\n\nThis approach makes promotions a bit harder, as now you need to checkout 2 git repositories before doing any promotion. On the other hand, it allows your security team to place extra security constraints to the “production” Git repository, and you still have a static number of Git repositories (exactly 2) regardless of the amount of environments you deploy to.\n\nI personally consider this approach an overkill that, at least to me, shows a lack of trust against developers and operators. The discussion on whether or not people should have direct access to production environments is a complex one and probably deserves a blog post on its own.\n\n## Embrace folders and forget branches\n\nWe hope that with this blog post we addressed all the questions that arose from the “don’t use branches for environments” article and you now have a good understanding about the benefits of the folder approach and why you should use it.\n\nIf you have other interesting use cases or have extra questions on the subject of organizing your GitOps environments, please ask in the comments section.\n\nHappy GitOps deployments!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n',t.user={name:"Kostis Kapelonis",username:"kostiscodefresh",twitter_username:e,github_username:"kostis-codefresh",website_url:"https://codefresh.io/",profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s--NAvfio9P--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/437938/7b372728-0ca1-4d45-961a-b170001a220d.png",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--PeaKTpE1--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/437938/7b372728-0ca1-4d45-961a-b170001a220d.png"},t.organization={name:"Codefresh",username:a,slug:a,profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s--eVMCUH5x--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/3138/a894848c-dd79-44fd-b477-3af28338d874.jpg",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--iHuWL-6D--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/3138/a894848c-dd79-44fd-b477-3af28338d874.jpg"},{layout:"default",data:[{}],fetch:{"data-v-70afb46a:0":{article:t}},error:e,state:{currentArticle:t},serverRendered:!0,routePath:"/kostiscodefresh/1031871",config:{_app:{basePath:"/nuxtstop/",assetsPath:"/nuxtstop/_nuxt/",cdnURL:e}}}}(null,"2022-03-23T11:49:56Z",{},"codefreshio")</script><script src="/nuxtstop/_nuxt/f6e87fb.js" defer></script><script src="/nuxtstop/_nuxt/dc9ce94.js" defer></script><script src="/nuxtstop/_nuxt/6474719.js" defer></script><script src="/nuxtstop/_nuxt/9b75090.js" defer></script><script src="/nuxtstop/_nuxt/18df600.js" defer></script>
  </body>
</html>
