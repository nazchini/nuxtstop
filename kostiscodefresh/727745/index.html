<!doctype html>
<html data-n-head-ssr lang="en" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Enterprise CI/CD Best Practices – Part 1</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content="Using Nuxt.js fetch() hook to build dev.to with a new look"><meta data-n-head="ssr" name="format-detection" content="telephone=no"><base href="/nuxtstop/"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:400,500,600&display=swap"><link rel="preload" href="/nuxtstop/_nuxt/f6e87fb.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/6474719.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/9b75090.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/18df600.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/dc9ce94.js" as="script"><style data-vue-ssr-id="c650fd98:0 af4684f0:0 a9c71758:0 dcafa518:0 4b9cec49:0 b093d766:0 9d98bcb4:0 6b6a11ea:0 0248ed80:0 ea8e4264:0">html{box-sizing:border-box;font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}*,:after,:before{box-sizing:inherit}html{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,:after,:before{border:0 solid #e0e0e0}blockquote,body,dd,dl,figure,h1,h2,h3,h4,h5,h6,p,pre{margin:0}button{background:0 0;padding:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset,ol,ul{margin:0;padding:0}ol,ul{list-style:none}hr{border-width:1px}img{border-style:solid}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:inherit;opacity:.5}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:inherit;opacity:.5}input::placeholder,textarea::placeholder{color:inherit;opacity:.5}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit;font-family:sans-serif}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit;font-family:inherit;font-size:100%}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;overflow:auto;word-break:break-word;white-space:normal}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}html{height:100%;font-size:18px;-ms-overflow-style:scrollbar;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none}@media(min-width:640px){html{font-size:20px}}body{height:100%;min-width:320px;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:400;line-height:1.5;color:#000;background-color:#eff4f7;-webkit-text-rendering:optimizeLegibility;text-rendering:optimizeLegibility;font-synthesis:none;font-kerning:normal;font-feature-settings:"normal","kern";-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-overflow-scrolling:touch;overflow-x:hidden;overflow-y:scroll}h1,h2,h3,h4,h5,h6{color:#000;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:600;font-feature-settings:"normal";line-height:1.2}pre{background:#29292e;border-radius:2px;overflow:auto;padding:1rem;color:#eff1f9;line-height:1.42em;font-size:13px}@media screen and (min-width:380px){pre{font-size:15px}}pre code{background:#29292e;color:#eff0f9;white-space:pre}div.highlight pre.highlight code{font-size:inherit;padding:0}div.inner-comment div.body div.highlight pre.highlight{background:#29292e}div.inner-comment div.body div.highlight pre.highlight code{font-size:inherit;white-space:inherit;background:inherit;color:inherit}.highlight .hll{background-color:#49483e}.highlight{background:#29292e;color:#f8f8f2}.highlight .c{color:grey}.highlight .err{text-shadow:0 0 7px #f9690e}.highlight .k{color:#f39c12}.highlight .l{color:plum}.highlight .n{color:#f8f8f2}.highlight .o{color:#f9690e}.highlight .p{color:#f8f8f2}.highlight .c1,.highlight .ch,.highlight .cm,.highlight .cp,.highlight .cpf,.highlight .cs{color:grey}.highlight .gd{color:#f9690e}.highlight .ge{font-style:italic}.highlight .gi{color:#7ed07e}.highlight .gs{font-weight:700}.highlight .gu{color:grey}.highlight .kc,.highlight .kd{color:#f39c12}.highlight .kn{color:#f9690e}.highlight .kp,.highlight .kr,.highlight .kt{color:#f39c12}.highlight .ld{color:#f2ca27}.highlight .m{color:plum}.highlight .s{color:#f2ca27}.highlight .na{color:#7ed07e}.highlight .nb{color:#f8f8f2}.highlight .nc{color:#7ed07e}.highlight .no{color:#f39c12}.highlight .nd{color:#7ed07e}.highlight .ni{color:#f8f8f2}.highlight .ne,.highlight .nf{color:#7ed07e}.highlight .nl,.highlight .nn{color:#f8f8f2}.highlight .nx{color:#7ed07e}.highlight .py{color:#f8f8f2}.highlight .nt{color:#f9690e}.highlight .nv{color:#f8f8f2}.highlight .ow{color:#f9690e}.highlight .w{color:#f8f8f2}.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo{color:plum}.highlight .dl,.highlight .s2,.highlight .sa,.highlight .sb,.highlight .sc,.highlight .sd{color:#f2ca27}.highlight .se{color:plum}.highlight .s1,.highlight .sh,.highlight .si,.highlight .sr,.highlight .ss,.highlight .sx{color:#f2ca27}.highlight .bp{color:#f8f8f2}.highlight .fm{color:#7ed07e}.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#f8f8f2}.highlight .il{color:plum}.vue-content-placeholders-heading__img,.vue-content-placeholders-heading__subtitle,.vue-content-placeholders-heading__title,.vue-content-placeholders-img,.vue-content-placeholders-text__line{background:#bfcdec!important}.vue-content-placeholders-is-animated .vue-content-placeholders-heading__img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__subtitle:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__title:before,.vue-content-placeholders-is-animated .vue-content-placeholders-img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-text__line:before{background:linear-gradient(90deg,transparent 0,#d3ddf9 15%,transparent 30%)!important}header[data-v-27046cca]{max-width:1280px;margin:auto;padding:1rem;height:6rem;border-bottom:1px solid rgba(0,0,0,.2)}header .logo-wrapper[data-v-27046cca],header[data-v-27046cca]{display:flex;align-items:center;justify-content:space-between}header .logo-wrapper[data-v-27046cca]{margin:0 .5rem}header .logo-wrapper svg[data-v-27046cca]{width:3rem;height:100%}header .logo-wrapper .name-wrapper[data-v-27046cca]{margin-left:.6em}header .logo-wrapper .name-wrapper .subtitle[data-v-27046cca]{font-size:1rem}header .logo-wrapper .name-wrapper .app-name[data-v-27046cca]{font-weight:700;font-size:2.25rem;line-height:1.25}header nav[data-v-27046cca]{letter-spacing:-.025rem;font-weight:600;text-transform:uppercase}header nav ul[data-v-27046cca]{display:flex}header nav ul li[data-v-27046cca]{margin:0 .5rem}header nav ul li a[data-v-27046cca]{box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;padding:.25rem 1rem;border-radius:.5rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}header nav ul li a[data-v-27046cca]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header nav ul li a.nuxt-link-exact-active[data-v-27046cca]{cursor:default}header nav ul li a.nuxt-link-exact-active[data-v-27046cca],header nav ul li a[data-v-27046cca]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}.page-wrapper[data-v-10d06ee8]{max-width:1280px;margin:auto;padding:1rem}.article-content-wrapper[data-v-10d06ee8]{display:flex;flex-direction:column;align-items:center;margin:auto auto 2rem}@media(min-width:1024px){.article-content-wrapper[data-v-10d06ee8]{align-items:normal;flex-direction:row}}.article-content-wrapper .article-block[data-v-10d06ee8]{width:100%;max-width:880px}@media(min-width:1024px){.article-content-wrapper .article-block[data-v-10d06ee8]{margin-right:1rem;width:66.66666%;margin-bottom:2rem}}.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{max-width:880px;width:100%;position:relative}@media(min-width:1024px){.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{display:block;width:33.33333%}}.article-content-wrapper .aside-username-wrapper .aside-username-block[data-v-10d06ee8]{position:-webkit-sticky;position:sticky;top:1rem}@media(min-width:1280px){.comments-block[data-v-10d06ee8]{margin:.5rem}}article[data-v-70afb46a]{padding:.5rem;border-radius:1rem}header h1[data-v-70afb46a],header[data-v-70afb46a]{margin-bottom:1rem}header h1[data-v-70afb46a]{font-size:2.25rem;letter-spacing:-.025rem}header .tags[data-v-70afb46a]{display:flex;flex-wrap:wrap;margin-bottom:1.5rem}header .tags .tag[data-v-70afb46a]{font-weight:500;line-height:1;padding:.5rem;margin:0 .5rem .5rem 0;border-radius:.25rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db}header .tags .tag[data-v-70afb46a]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header .tags .tag[data-v-70afb46a]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}header .image-wrapper[data-v-70afb46a]{position:relative;padding-bottom:56.25%;background-color:#d4dfe8;margin-bottom:1.5rem;border-radius:.5rem;overflow:hidden}@media(min-width:834px){header .image-wrapper[data-v-70afb46a]{margin-bottom:1.5rem}}header .image-wrapper img[data-v-70afb46a]{position:absolute;top:0;left:0;width:100%;height:100%;-o-object-fit:cover;object-fit:cover}header .meta[data-v-70afb46a]{line-height:1;font-size:.875rem;text-transform:uppercase;font-weight:500;letter-spacing:-.025rem;display:flex;align-items:center;justify-content:space-between}header .meta .scl[data-v-70afb46a]{display:flex}header .meta .scl span[data-v-70afb46a]{display:flex;align-items:center;margin-right:1rem}header .meta .scl span svg[data-v-70afb46a]{margin-right:.25rem}header .meta .scl .comments[data-v-70afb46a]{cursor:pointer}[data-v-70afb46a] .content .ltag__user{display:none}[data-v-70afb46a] .content iframe{max-width:100%}[data-v-70afb46a] .content h1{font-size:1.875rem}[data-v-70afb46a] .content h1,[data-v-70afb46a] .content h2{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h2{font-size:1.5rem}[data-v-70afb46a] .content h3{font-size:1.25rem}[data-v-70afb46a] .content h3,[data-v-70afb46a] .content h4{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h4{font-size:1rem}[data-v-70afb46a] .content a{color:#6e87d2}[data-v-70afb46a] .content p{margin-bottom:1rem;line-height:1.4}[data-v-70afb46a] .content p code{background-color:#d2f3e1;border-radius:.25rem;padding:.25rem}[data-v-70afb46a] .content img{width:100%;border-radius:.5rem}[data-v-70afb46a] .content .highlight{margin-bottom:1rem;border-radius:.5rem}[data-v-70afb46a] .content ul{list-style:numeral;margin-bottom:1rem}[data-v-70afb46a] .content ul li p{margin-bottom:0}[data-v-70afb46a] .content ol{margin-bottom:1rem}aside[data-v-37984f8c]{padding:1rem;background-color:#dfe8ef;border-radius:1rem}aside .username-heading[data-v-37984f8c]{display:flex;margin-bottom:1rem}aside .username-heading[data-v-37984f8c]:hover{color:#6e87d2}aside .username-heading img[data-v-37984f8c]{width:3rem;height:3rem;border-radius:50%;margin-right:1rem}aside .username-heading .text[data-v-37984f8c]{display:flex;flex-direction:column;justify-content:center}aside .username-heading .text a[data-v-37984f8c]{line-height:1}aside .username-heading .text a[data-v-37984f8c]:first-child{font-size:1.25rem;font-weight:500;letter-spacing:-.025rem;margin-bottom:.25rem}aside .username-heading .text a[data-v-37984f8c]:last-child{color:#999;font-size:.875rem}aside .username-heading.loading[data-v-37984f8c]{display:block}aside .f-button[data-v-37984f8c]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}aside .f-button[data-v-37984f8c]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}aside .f-button[data-v-37984f8c]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}aside .info>div[data-v-37984f8c]{margin-bottom:.5rem}aside .info .title[data-v-37984f8c]{font-size:.666666rem;letter-spacing:-.0125rem;font-weight:500;color:#999;text-transform:uppercase;margin-bottom:.1rem}aside .info .content[data-v-37984f8c]{font-size:.875rem;line-height:1.4}.add-comment[data-v-8c4375bc]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}.add-comment[data-v-8c4375bc]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}.add-comment[data-v-8c4375bc]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}footer[data-v-22cb8fd0]{padding:2rem;text-align:center;display:flex;align-items:center;justify-content:center}footer span[data-v-22cb8fd0]{display:inline-block;line-height:1;text-transform:uppercase;letter-spacing:-.025rem;font-size:.75rem;font-weight:500}footer a svg[data-v-22cb8fd0]{width:3rem;height:3rem;margin:0 .5rem}footer a .nuxt-icon[data-v-22cb8fd0]{width:2.5rem;height:2.5rem;margin:0 .25rem}</style>
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><div id="__layout"><div><header data-v-27046cca><a href="/nuxtstop/" class="logo-wrapper nuxt-link-active" data-v-27046cca><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-27046cca><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-27046cca></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-27046cca></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-27046cca></path></svg> <div class="name-wrapper" data-v-27046cca><span class="app-name" data-v-27046cca>Nuxtstop</span> <p class="subtitle" data-v-27046cca>For all things nuxt.js</p></div></a> <nav data-v-27046cca><ul data-v-27046cca><li data-v-27046cca><a href="/nuxtstop/" class="nuxt-link-active" data-v-27046cca>
          New
        </a></li><li data-v-27046cca><a href="/nuxtstop/top" data-v-27046cca>
          Top
        </a></li></ul></nav></header> <div class="page-wrapper" data-v-10d06ee8><div class="article-content-wrapper" data-v-10d06ee8><article data-fetch-key="data-v-70afb46a:0" class="article-block" data-v-70afb46a data-v-10d06ee8><header data-v-70afb46a><h1 data-v-70afb46a>Enterprise CI/CD Best Practices – Part 1</h1> <div class="tags" data-v-70afb46a><a href="/nuxtstop/t/devops" class="tag" data-v-70afb46a>
          #devops
        </a><a href="/nuxtstop/t/cloudnative" class="tag" data-v-70afb46a>
          #cloudnative
        </a><a href="/nuxtstop/t/ci" class="tag" data-v-70afb46a>
          #ci
        </a><a href="/nuxtstop/t/cd" class="tag" data-v-70afb46a>
          #cd
        </a></div> <div class="image-wrapper" data-v-70afb46a><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--JQMYSRNT--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/kz9kmeqzn524fkzlwafk.jpg" alt="Enterprise CI/CD Best Practices – Part 1" data-v-70afb46a></div> <div class="meta" data-v-70afb46a><div class="scl" data-v-70afb46a><span data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M16.4444 3C14.6733 3 13.0333 3.94162 12 5.34C10.9667 3.94162 9.32667 3 7.55556 3C4.49222 3 2 5.52338 2 8.625C2 14.8024 11.0267 20.586 11.4122 20.829C11.5922 20.9426 11.7956 21 12 21C12.2044 21 12.4078 20.9426 12.5878 20.829C12.9733 20.586 22 14.8024 22 8.625C22 5.52338 19.5078 3 16.4444 3Z" fill="#FF0000" data-v-70afb46a data-v-70afb46a></path></svg>
            44
          </span> <span class="comments" data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M6.11765 22H4.94118L5.64706 21.05C6.11765 20.3969 6.41176 19.5656 6.58824 18.5563C3.64706 17.1906 2 14.6375 2 11.3125C2 6.20625 5.82353 3 12 3C18.1765 3 22 6.20625 22 11.3125C22 16.5375 18.2353 19.625 12 19.625H11.5882C10.6471 20.7531 9 22 6.11765 22ZM12 4.1875C6.47059 4.1875 3.17647 6.85937 3.17647 11.3125C3.17647 15.1125 5.47059 16.8938 7.41177 17.6656L7.82353 17.8437L7.76471 18.3187C7.64706 19.2687 7.47059 20.1 7.11765 20.8125C9.05882 20.575 10.1765 19.5656 10.8235 18.7344L11 18.4969H12C19.9412 18.4969 20.8235 13.5094 20.8235 11.3719C20.8235 6.85938 17.5294 4.1875 12 4.1875Z" fill="black" data-v-70afb46a data-v-70afb46a></path></svg>
            0
          </span></div> <time data-v-70afb46a>Jun 14 '21</time></div></header> <div class="content" data-v-70afb46a><p>If you are trying to learn your way around Continuous Integration/Delivery/Deployment, you might notice that there are mostly two categories of resources:</p>

<ol>
<li>High-level overviews of <a href="https://codefresh.io/continuous-deployment/heck-continuous-integration-ci-delivery-cd-deployment-cdp/">what CI/CD is and why you need it</a>. These are great for when you are getting started but do not cover anything about day two operations or how to optimize an existing process.</li>
<li>Detailed tutorials that cover only a specific aspect of CI/CD (e.g., just unit testing or just deployment) using specific programming languages and tools.
We believe that there is a gap between those two extremes. We are missing a proper guide that sits between those two categories by talking about best practices, but not in an abstract way. If you always wanted to read a guide about CI/CD that explains not just the “why” but also the “how” to apply best practices, then this guide is for you.</li>
</ol>

<p>We will describe all the basic foundations of effective CI/CD workflows, but instead of talking only in generic terms, we will explain all the technicalities behind each best practice and more importantly, how it can affect you if you don’t adopt it.</p>

<h2>
  <a name="setting-priorities" href="#setting-priorities">
  </a>
  Setting Priorities
</h2>

<p>Several companies try to jump on the DevOps bandwagon without having mastered the basics first. You will soon realize that several problems which appear during the CI/CD process are usually pre-existing process problems that only became visible when that company tried to follow best practices in CI/CD pipelines.</p>

<p>The table below summarizes the requirements discussed in the rest of the guide. We also split the requirements according to priority:</p>

<p><strong>Critical</strong> requirements are essential to have before adopting DevOps or picking a solution for CI/CD. You should address them first. If you don’t, then they will block the process later down the road.<br>
Requirements with <strong>High</strong> priority are still important to address, but you can fix them while you are adopting a CI/CD platform<br>
Requirements with <strong>Medium</strong> priority can be addressed in the long run. Even though they will improve your deployment process, you can work around them until you find a proper solution.</p>

<div class="table-wrapper-paragraph"><table>
<thead>
<tr>
<th>Number</th>
<th>Best practice</th>
<th>Category</th>
<th>Importance</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>All project assets are in source control</td>
<td>Artifacts</td>
<td>Critical</td>
</tr>
<tr>
<td>2</td>
<td>A single artifact is produced for all environments</td>
<td>Artifacts</td>
<td>High</td>
</tr>
<tr>
<td>3</td>
<td>Artifacts move within pipelines (and not source revisions)</td>
<td>Artifacts</td>
<td>High</td>
</tr>
<tr>
<td>4</td>
<td>Development happens with short-lived branches (one per feature)</td>
<td>Build</td>
<td>High</td>
</tr>
<tr>
<td>5</td>
<td>Builds can be performed in a single step</td>
<td>Build</td>
<td>High</td>
</tr>
<tr>
<td>6</td>
<td>Builds are fast (less than 5 minutes)</td>
<td>Build</td>
<td>Medium</td>
</tr>
<tr>
<td>7</td>
<td>Store your dependencies</td>
<td>Build</td>
<td>High</td>
</tr>
<tr>
<td>8</td>
<td>Tests are automated</td>
<td>Testing</td>
<td>High</td>
</tr>
<tr>
<td>9</td>
<td>Tests are fast</td>
<td>Testing</td>
<td>High</td>
</tr>
<tr>
<td>10</td>
<td>Tests auto clean their side effects</td>
<td>Testing</td>
<td>High</td>
</tr>
<tr>
<td>11</td>
<td>Multiple test suites exist</td>
<td>Testing</td>
<td>Medium</td>
</tr>
<tr>
<td>12</td>
<td>Test environments on demand</td>
<td>Testing</td>
<td>Medium</td>
</tr>
<tr>
<td>13</td>
<td>Running test suites concurrently</td>
<td>Testing</td>
<td>Medium</td>
</tr>
<tr>
<td>14</td>
<td>Security scanning is part of the process</td>
<td>Quality and Audit</td>
<td>High</td>
</tr>
<tr>
<td>15</td>
<td>Quality scanning/Code reviews are part of the process</td>
<td>Quality and Audit</td>
<td>Medium</td>
</tr>
<tr>
<td>16</td>
<td>Database updates have their lifecycle</td>
<td>Databases</td>
<td>High</td>
</tr>
<tr>
<td>17</td>
<td>Database updates are automated</td>
<td>Databases</td>
<td>High</td>
</tr>
<tr>
<td>18</td>
<td>Database updates are forward and backward compatible</td>
<td>Databases</td>
<td>High</td>
</tr>
<tr>
<td>19</td>
<td>Deployments happen via a single path (CI/CD server)</td>
<td>Deployments</td>
<td>Critical</td>
</tr>
<tr>
<td>20</td>
<td>Deployments happen gradually in stages</td>
<td>Deployments</td>
<td>High</td>
</tr>
<tr>
<td>21</td>
<td>Metrics and logs can detect a bad deployment</td>
<td>Deployments</td>
<td>High</td>
</tr>
<tr>
<td>22</td>
<td>Automatic rollbacks are in place</td>
<td>Deployments</td>
<td>Medium</td>
</tr>
<tr>
<td>23</td>
<td>Staging matches production</td>
<td>Deployments</td>
<td>Medium</td>
</tr>
</tbody>
</table></div>

<h2>
  <a name="best-practice-1-place-everything-under-source-control" href="#best-practice-1-place-everything-under-source-control">
  </a>
  Best Practice 1 – Place Everything Under Source Control
</h2>

<p>Artifact management is perhaps the most important characteristic of a pipeline. At its most basic level, a pipeline creates binary/package artifacts from source code and deploys them to the appropriate infrastructure that powers the application that is being deployed.</p>

<p>The single most important rule to follow regarding assets and source code is the following:</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--l8P4HULT--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2ihhlrw3qi8764gz739c.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--l8P4HULT--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2ihhlrw3qi8764gz739c.png" alt="Everything in Git" loading="lazy"></a></p>

<p><strong>All files that constitute an application should be managed using source control.</strong></p>

<p>Unfortunately, even though this rule seems pretty basic, there are a lot of organizations out there that fail to follow it. Traditionally, developers are using version control systems only for the source code of an application but leave out other supporting files such as installation scripts, configuration values, or test data.</p>

<p>Everything that takes part in the application lifecycle should be checked into source control. This includes but is not limited to:</p>

<ol>
<li>Source code</li>
<li>Build scripts</li>
<li>Pipeline definition</li>
<li>Configuration values</li>
<li>Tests and test data</li>
<li>Database schemas</li>
<li>Database update scripts</li>
<li>Infrastructure definition scripts</li>
<li>Cleanup/installation/purging scripts</li>
<li>Associated documentation</li>
</ol>

<p>The end goal is that anybody can check out everything that relates to an application and can recreate it locally or in any other alternative environment.</p>

<p>A common anti-pattern we see is deployments happening with a special script that is available only on a specific machine or on the workstation of a specific team member, or even an attachment in a wiki page, and so on.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--HeqZ85qi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aie8bbgehy26fvp4hyes.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--HeqZ85qi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aie8bbgehy26fvp4hyes.png" alt="Resources all over the place" loading="lazy"></a></p>

<p>Version control also means that all these resources are audited and have a detailed history of all changes. If you want to see how the application looked 6 months ago, you can easily use the facilities of your version control system to obtain that information.</p>

<p>Note that even though all these resources should be versioned control, it doesn’t have to be in the same repository. Whether you use multiple repositories or a single one, is a decision that needs careful consideration and has not a definitive answer. The important part however is to make sure that everything is indeed version controlled.</p>

<p>Even though GitOps is the emerging practice of using Git operations for promotions and deployments, you don’t need to follow GitOps specifically to follow this best practice. Having historical and auditing information for your project assets is always a good thing, regardless of the actual software paradigm that you follow.</p>

<h2>
  <a name="best-practice-2-create-a-single-packagebinarycontainer-for-all-environments" href="#best-practice-2-create-a-single-packagebinarycontainer-for-all-environments">
  </a>
  Best Practice 2 – Create a Single package/binary/container for All Environments
</h2>

<p>One of the main functionalities of a CI/CD pipeline is to verify that a new feature is fit for deployment to production. This happens gradually as every step in a pipeline is essentially performing additional checks for that feature.</p>

<p>For this paradigm to work, however, you need to make sure that what is being tested and prodded within a pipeline is also the same thing that gets deployed. In practice, this means that a feature/release should be packaged once and be deployed to all successive environments in the same manner.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--U5VgJLOQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r0dui53e5ck24zon31ig.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--U5VgJLOQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r0dui53e5ck24zon31ig.png" alt="Same artifact" loading="lazy"></a></p>

<p>Unfortunately, a lot of organizations fall into the common trap of creating different artifacts for dev/staging/prod environments because they haven’t mastered yet a common infrastructure for configuration. This implies that they deploy a slightly different version of what was tested during the pipeline. Configuration discrepancies and last-minute changes are some of the biggest culprits when it comes to failed deployments, and having a different package per environment exacerbates this problem.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Ivwt5mJM--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mbypvdawbnndosrkntx5.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Ivwt5mJM--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mbypvdawbnndosrkntx5.png" alt="Different artifacts" loading="lazy"></a></p>

<p>Instead of creating multiple versions per environment, the accepted practice is to have a single artifact that only changes configuration between different environments. With the appearance of containers and the ability to create a self-sufficient package of an application in the form of Docker images, there is no excuse for not following this practice.</p>

<p>Regarding configuration there are two approaches:</p>

<ol>
<li>The binary artifact/container has all configurations embedded inside it and changes the active one according to the running environment (easy to start, but not very flexible. We don’t recommend this approach)</li>
<li>The container has no configuration at all. It fetches needed configuration during runtime on demand using a discovery mechanism such as a key/value database, a filesystem volume, a service discovery mechanism, etc. (the recommended approach)</li>
</ol>

<p>The result is the guarantee where the exact binary/package that is deployed in production is also the one that was tested in the pipeline.</p>

<h2>
  <a name="best-practice-3-artifacts-not-git-commits-should-travel-within-a-pipeline" href="#best-practice-3-artifacts-not-git-commits-should-travel-within-a-pipeline">
  </a>
  Best Practice 3 – Artifacts, not Git Commits, should travel within a Pipeline
</h2>

<p>A corollary to the previous point (the same artifact/package should be deployed in all environments) is the fact that a deployment artifact <strong>should be built only once</strong>.</p>

<p>The whole concept around containers (and VM images in the past) is to have <strong>immutable</strong> artifacts. An application is built only once with the latest feature or features that will soon be released.</p>

<p>Once that artifact is built, it should move from each pipeline step to the next as an unchanged entity. Containers are the perfect vehicle for this immutability as they allow you to create an image only once (at the beginning of the pipeline) and promote it towards production with each successive pipeline step.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--yoMqs9uZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/u0vqsbhf3vw58cr6qkd8.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--yoMqs9uZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/u0vqsbhf3vw58cr6qkd8.png" alt="Promote artifact" loading="lazy"></a></p>

<p>Unfortunately, the common anti-pattern seen here is companies promoting commits instead of container images. A source code commit is traveling in the pipeline stages and each step is being rebuilt by checking out the source code again and again.</p>

<p>This is a bad practice for two main reasons. First of all, it makes the pipeline very slow as packaging and compiling software is a very lengthy process and repeating it at each step is a waste of time and resources.</p>

<p>Secondly, it breaks the previous rule. Recompiling a code commit at every pipeline step leaves the window open for resulting in a different artifact than before. You lose the guarantee that what is deploying in production is the same thing that was tested in the pipeline.</p>

<h2>
  <a name="best-practice-4-use-shortlived-branches-for-each-feature" href="#best-practice-4-use-shortlived-branches-for-each-feature">
  </a>
  Best Practice 4 – Use short-lived Branches for each feature
</h2>

<p>A sound pipeline has several quality gates (such as unit tests or security scans) that test the quality of a feature and its applicability to production deployments. In a development environment with a high velocity (and a big development team), not all features are expected to reach production right away. Some features may even clash with each other at their initial deployment version.</p>

<p>To allow for fine-grained quality gating between features, a pipeline should have the power to veto individual features and be able to select only a subset of them for production deployment. The easiest way to obtain this guarantee is following the feature-per-branch methodology where short-lived features (i.e. that can fit within a single development sprint) correspond to individual source control branches.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--o7mNaenC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r8tv1zpa814vaqtv3fwg.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--o7mNaenC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r8tv1zpa814vaqtv3fwg.png" alt="Short lived branches" loading="lazy"></a></p>

<p>This makes the pipeline design very simple as everything revolves around individual features. Running test suites against a code branch tests only the new feature. Security scanning of a branch reveals problems with a new feature.</p>

<p>Project stakeholders are then able to deploy and rollback individual features or block complete branches from even being merged into the mainline code.</p>

<p>Unfortunately, there are still companies that have long-lived feature branches that collect multiple and unrelated features in a single batch. This not only makes merging a pain but also becomes problematic in case a single feature is found to have issues (as it is difficult to revert it individually).</p>

<p>The evolution of short-lived branches is to follow <a href="https://trunkbaseddevelopment.com/">trunk-based development</a> and feature toggles. This can be your endgame but only if you have mastered short-lived branches first.</p>

<h2>
  <a name="best-practice-5-a-basic-build-should-take-a-single-step" href="#best-practice-5-a-basic-build-should-take-a-single-step">
  </a>
  Best Practice 5 – A basic build should take a single step
</h2>

<p>CI/CD pipelines are all about automation. It is very easy to automate something that already was very easy to run in the first place.</p>

<p>Ideally, a simple build of a project should be a single command. That command usually calls the build system or a script (e.g., bash, PowerShell) that is responsible for taking the source code, running some basic tests, and packaging the final artifact/container.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--_4uKdbs9--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ocwptaneg1951yjlemam.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--_4uKdbs9--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ocwptaneg1951yjlemam.png" alt="Simple build" loading="lazy"></a></p>

<p>It is ok if more advanced checks (such as load testing) need additional steps. The basic build, however (that results in a deployable artifact) should only involve a single command. A new developer should be able to check out a brand new copy of the source code, execute this single command and get immediately a deployable artifact.</p>

<p>The same approach is true for deployments (deployments should happen with a single command)<br>
Then if you need to create any pipeline you can simply insert that single step in any part of the pipeline.</p>

<p>Unfortunately, there are still companies that suffer from many manual steps to get a basic build running. Downloading extra files, changing properties, and in general having big checklists that need to be followed are steps that should be automated within that very same script.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--6cKeEoWd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iqha5t1au71oozi8y0q9.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--6cKeEoWd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iqha5t1au71oozi8y0q9.png" alt="Many build steps" loading="lazy"></a></p>

<p>If a new hire in your development team needs more than 15 minutes for the basic build (after checking out the code in their workstation) then you almost certainly suffer from this problem.</p>

<p>A well-built CI/CD pipeline just repeats what is already possible on the local workstation. The basic build and deploy process should be already well oiled before being moved into a CI/CD platform.</p>

<h2>
  <a name="best-practice-6-basic-builds-are-fast-5-10-minutes" href="#best-practice-6-basic-builds-are-fast-5-10-minutes">
  </a>
  Best Practice 6 – Basic Builds are Fast (5 – 10 minutes)
</h2>

<p>Having a fast build is a big advantage for both developers and operators/sysadmins.</p>

<p>Developers are happy when the feedback loop between a commit and its side effects is as short as possible. It is very easy to fix a bug in the code that you just committed as it is very fresh on your mind. Having to wait for one hour before developers can detect failed builds is a very frustrating experience.</p>

<p>Builds should be fast both in the CI platform and in the local station. At any given point in time, multiple features are trying to enter the code mainline. The CI server can be easily overwhelmed if building them takes a lot of time.</p>

<p>Operators also gain huge benefits from fast builds. Pushing hot fixes in production or rolling back to previous releases is always a stressful experience. The shorter this experience is the better. Rollbacks that take 30 minutes are much more difficult to work with than those that take three minutes.</p>

<p>In summary, a basic build should be really fast. Ideally less than five minutes. If it takes more than 10 minutes, your team should investigate the causes and shorten that time. Modern build systems have great caching mechanisms.</p>

<ul>
<li>Library dependencies should be fetched from an internal proxy repository instead of the internet</li>
<li>Avoid the use of code generators unless otherwise needed</li>
<li>Split your unit (fast) and integration tests (slow) and only use unit tests for the basic build</li>
<li>Fine-tune your container images to take full advantage of the Docker layer caching</li>
</ul>

<p>Getting faster builds is also one of the reasons that you should explore if you are moving to microservices.</p>

<h2>
  <a name="best-practice-7-storecache-your-dependencies" href="#best-practice-7-storecache-your-dependencies">
  </a>
  Best Practice 7 – Store/Cache Your Dependencies
</h2>

<p>It’s all over the news. The <a href="https://www.theregister.com/2016/03/23/npm_left_pad_chaos/">left-pad incident</a>. The <a href="https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610">dependency confusion hack</a>. While both incidents have great security implications, the truth is that storing your dependencies is also a very important tenet that is fundamental to the stability of your builds.</p>

<p>Every considerable piece of code uses external dependencies in the form of libraries or associated tools. Your code should of course be always stored in Git. But all external libraries should be also stored by you in some sort of artifact repository.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--s2Z65ZA2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/egyaauig4d4wgkbqedi9.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--s2Z65ZA2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/egyaauig4d4wgkbqedi9.png" alt="Store your own dependencies" loading="lazy"></a></p>

<p>Spend some time to collect our dependencies and understand where they are coming from. Apart from code libraries, other not-so-obvious moving parts are needed by a complete build as your base docker images or any command-line utilities that are needed for your builds.</p>

<p>The best way to test your build for stability is to completely cut off internet access in your build servers (essentially simulating an air-gapped environment). Try to kick off a pipeline build where all your internal services (git, databases, artifact storage, container registry) are available, but nothing else from the public internet is accessible, and see what happens.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--u_M45pDr--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7hvrkyvp4nsfvpzgjrum.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--u_M45pDr--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7hvrkyvp4nsfvpzgjrum.png" alt="Straight from the internet" loading="lazy"></a>.</p>

<p>If your build complains about a missing dependency, imagine that the same thing will happen in a real incident if that particular external resource is also down.</p>

<p>Continued on <a href="https://dev.to/codefreshio/enterprise-ci-cd-best-practices-part-2-3o24">part2</a>. </p>

<p>Cover photo by <a href="https://unsplash.com/photos/jHZ70nRk7Ns">Unsplash</a>.</p>

</div></article> <div class="aside-username-wrapper" data-v-10d06ee8><aside class="aside-username-block" data-v-37984f8c data-v-10d06ee8><div class="username-heading loading" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-heading" data-v-37984f8c><div class="vue-content-placeholders-heading__img"></div> <div class="vue-content-placeholders-heading__content"><div class="vue-content-placeholders-heading__title"></div> <div class="vue-content-placeholders-heading__subtitle"></div></div></div></div></div> <div class="info" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-text" data-v-37984f8c><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div></div></div></div></aside></div></div> <div class="comments-block" data-v-8c4375bc data-v-10d06ee8><!----> <a href="https://dev.to/kostiscodefresh/enterprise-ci-cd-best-practices-part-1-2n5m" target="_blank" rel="nofollow noopener noreferer" class="add-comment" data-v-8c4375bc>
    Add comment
  </a></div></div> <footer data-v-22cb8fd0><span data-v-22cb8fd0>Built with</span> <a href="https://nuxtjs.org" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="nuxt-icon" data-v-22cb8fd0 data-v-22cb8fd0><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a> <span data-v-22cb8fd0>&</span> <a href="https://docs.dev.to/api" rel="nofollow noopener" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-22cb8fd0 data-v-22cb8fd0><path d="M1.5726 5.13748C1.42945 5.20622 1.2411 5.36661 1.15822 5.48117C1 5.69503 1 5.74849 1 11.8739C1 17.9993 1 18.0528 1.15822 18.2667C1.2411 18.3812 1.42945 18.5416 1.5726 18.6104C1.8137 18.7402 2.46164 18.7478 12 18.7478C21.5384 18.7478 22.1863 18.7402 22.4274 18.6104C22.5706 18.5416 22.7589 18.3812 22.8418 18.2667C23 18.0528 23 17.9993 23 11.8739C23 5.74849 23 5.69503 22.8418 5.48117C22.7589 5.36661 22.5706 5.20622 22.4274 5.13748C22.1863 5.00764 21.5384 5 12 5C2.46164 5 1.8137 5.00764 1.5726 5.13748ZM7.7055 8.2613C8.0822 8.45989 8.59454 9.0098 8.77536 9.40694C8.89589 9.66664 8.91095 9.94922 8.91095 12.0649C8.91095 14.3104 8.90344 14.4478 8.75275 14.7839C8.51919 15.288 8.16506 15.6546 7.68288 15.899C7.26096 16.1052 7.22328 16.1128 5.7315 16.1358L4.20206 16.1663V12.1031V8.04744L5.80684 8.07035C7.27602 8.09327 7.42672 8.10854 7.7055 8.2613ZM13.6952 8.89521V9.73538H12.4521H11.2089V10.4991V11.2629H11.9623H12.7158V12.1031V12.9432H11.9623H11.2089V13.707V14.4708H12.4521H13.6952V15.3109V16.151H12C10.1315 16.151 10.0411 16.1358 9.67191 15.6928L9.47603 15.4484V12.1336C9.47603 8.46752 9.46851 8.49807 9.95069 8.20783C10.1692 8.07035 10.3425 8.05508 11.9473 8.05508H13.6952V8.89521ZM16.5658 10.3769C16.8897 11.6295 17.1685 12.6912 17.176 12.7293C17.1911 12.7675 17.4699 11.7441 17.8014 10.461C18.1254 9.17017 18.4343 8.1009 18.4795 8.08563C18.5247 8.06271 18.9541 8.06271 19.4288 8.07035L20.3028 8.09327L19.376 11.6219C18.8713 13.5542 18.4117 15.2269 18.3664 15.3261C18.0123 16.0135 17.274 16.3343 16.7164 16.0441C16.4528 15.899 16.0911 15.4865 15.9705 15.1887C15.9254 15.0665 15.4884 13.4549 15.0062 11.6142C14.524 9.76593 14.1171 8.20783 14.0945 8.15437C14.0644 8.07035 14.2301 8.05508 15.0212 8.07035L15.9856 8.09327L16.5658 10.3769Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M5.93491 12.103V14.4707H6.27394C6.66574 14.4707 7.01983 14.3103 7.1404 14.0965C7.18559 14.0048 7.21575 13.2105 7.21575 12.0648V10.1783L6.99725 9.95683C6.80133 9.76591 6.71847 9.73535 6.35683 9.73535H5.93491V12.103Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a></footer></div></div></div><script>window.__NUXT__=function(e,t,a,n){return a.type_of="article",a.id=727745,a.title="Enterprise CI/CD Best Practices – Part 1",a.description="If you are trying to learn your way around Continuous Integration/Delivery/Deployment, you might...",a.readable_publish_date="Jun 14 '21",a.slug="enterprise-ci-cd-best-practices-part-1-2n5m",a.path="/codefreshio/enterprise-ci-cd-best-practices-part-1-2n5m",a.url="https://dev.to/codefreshio/enterprise-ci-cd-best-practices-part-1-2n5m",a.comments_count=0,a.public_reactions_count=44,a.collection_id=13231,a.published_timestamp=t,a.positive_reactions_count=44,a.cover_image="https://res.cloudinary.com/practicaldev/image/fetch/s--JQMYSRNT--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/kz9kmeqzn524fkzlwafk.jpg",a.social_image="https://res.cloudinary.com/practicaldev/image/fetch/s--ye_bXKNN--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/kz9kmeqzn524fkzlwafk.jpg",a.canonical_url="https://codefresh.io/devops/enterprise-ci-cd-best-practices-part-1/",a.created_at="2021-06-14T08:52:30Z",a.edited_at="2021-06-14T10:31:49Z",a.crossposted_at=e,a.published_at=t,a.last_comment_at=t,a.reading_time_minutes=11,a.tag_list="devops, cloudnative, ci, cd",a.tags=["devops","cloudnative","ci","cd"],a.body_html='<p>If you are trying to learn your way around Continuous Integration/Delivery/Deployment, you might notice that there are mostly two categories of resources:</p>\n\n<ol>\n<li>High-level overviews of <a href="https://codefresh.io/continuous-deployment/heck-continuous-integration-ci-delivery-cd-deployment-cdp/">what CI/CD is and why you need it</a>. These are great for when you are getting started but do not cover anything about day two operations or how to optimize an existing process.</li>\n<li>Detailed tutorials that cover only a specific aspect of CI/CD (e.g., just unit testing or just deployment) using specific programming languages and tools.\nWe believe that there is a gap between those two extremes. We are missing a proper guide that sits between those two categories by talking about best practices, but not in an abstract way. If you always wanted to read a guide about CI/CD that explains not just the “why” but also the “how” to apply best practices, then this guide is for you.</li>\n</ol>\n\n<p>We will describe all the basic foundations of effective CI/CD workflows, but instead of talking only in generic terms, we will explain all the technicalities behind each best practice and more importantly, how it can affect you if you don’t adopt it.</p>\n\n<h2>\n  <a name="setting-priorities" href="#setting-priorities">\n  </a>\n  Setting Priorities\n</h2>\n\n<p>Several companies try to jump on the DevOps bandwagon without having mastered the basics first. You will soon realize that several problems which appear during the CI/CD process are usually pre-existing process problems that only became visible when that company tried to follow best practices in CI/CD pipelines.</p>\n\n<p>The table below summarizes the requirements discussed in the rest of the guide. We also split the requirements according to priority:</p>\n\n<p><strong>Critical</strong> requirements are essential to have before adopting DevOps or picking a solution for CI/CD. You should address them first. If you don’t, then they will block the process later down the road.<br>\nRequirements with <strong>High</strong> priority are still important to address, but you can fix them while you are adopting a CI/CD platform<br>\nRequirements with <strong>Medium</strong> priority can be addressed in the long run. Even though they will improve your deployment process, you can work around them until you find a proper solution.</p>\n\n<div class="table-wrapper-paragraph"><table>\n<thead>\n<tr>\n<th>Number</th>\n<th>Best practice</th>\n<th>Category</th>\n<th>Importance</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>All project assets are in source control</td>\n<td>Artifacts</td>\n<td>Critical</td>\n</tr>\n<tr>\n<td>2</td>\n<td>A single artifact is produced for all environments</td>\n<td>Artifacts</td>\n<td>High</td>\n</tr>\n<tr>\n<td>3</td>\n<td>Artifacts move within pipelines (and not source revisions)</td>\n<td>Artifacts</td>\n<td>High</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Development happens with short-lived branches (one per feature)</td>\n<td>Build</td>\n<td>High</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Builds can be performed in a single step</td>\n<td>Build</td>\n<td>High</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Builds are fast (less than 5 minutes)</td>\n<td>Build</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Store your dependencies</td>\n<td>Build</td>\n<td>High</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Tests are automated</td>\n<td>Testing</td>\n<td>High</td>\n</tr>\n<tr>\n<td>9</td>\n<td>Tests are fast</td>\n<td>Testing</td>\n<td>High</td>\n</tr>\n<tr>\n<td>10</td>\n<td>Tests auto clean their side effects</td>\n<td>Testing</td>\n<td>High</td>\n</tr>\n<tr>\n<td>11</td>\n<td>Multiple test suites exist</td>\n<td>Testing</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>12</td>\n<td>Test environments on demand</td>\n<td>Testing</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>13</td>\n<td>Running test suites concurrently</td>\n<td>Testing</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>14</td>\n<td>Security scanning is part of the process</td>\n<td>Quality and Audit</td>\n<td>High</td>\n</tr>\n<tr>\n<td>15</td>\n<td>Quality scanning/Code reviews are part of the process</td>\n<td>Quality and Audit</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>16</td>\n<td>Database updates have their lifecycle</td>\n<td>Databases</td>\n<td>High</td>\n</tr>\n<tr>\n<td>17</td>\n<td>Database updates are automated</td>\n<td>Databases</td>\n<td>High</td>\n</tr>\n<tr>\n<td>18</td>\n<td>Database updates are forward and backward compatible</td>\n<td>Databases</td>\n<td>High</td>\n</tr>\n<tr>\n<td>19</td>\n<td>Deployments happen via a single path (CI/CD server)</td>\n<td>Deployments</td>\n<td>Critical</td>\n</tr>\n<tr>\n<td>20</td>\n<td>Deployments happen gradually in stages</td>\n<td>Deployments</td>\n<td>High</td>\n</tr>\n<tr>\n<td>21</td>\n<td>Metrics and logs can detect a bad deployment</td>\n<td>Deployments</td>\n<td>High</td>\n</tr>\n<tr>\n<td>22</td>\n<td>Automatic rollbacks are in place</td>\n<td>Deployments</td>\n<td>Medium</td>\n</tr>\n<tr>\n<td>23</td>\n<td>Staging matches production</td>\n<td>Deployments</td>\n<td>Medium</td>\n</tr>\n</tbody>\n</table></div>\n\n<h2>\n  <a name="best-practice-1-place-everything-under-source-control" href="#best-practice-1-place-everything-under-source-control">\n  </a>\n  Best Practice 1 – Place Everything Under Source Control\n</h2>\n\n<p>Artifact management is perhaps the most important characteristic of a pipeline. At its most basic level, a pipeline creates binary/package artifacts from source code and deploys them to the appropriate infrastructure that powers the application that is being deployed.</p>\n\n<p>The single most important rule to follow regarding assets and source code is the following:</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--l8P4HULT--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2ihhlrw3qi8764gz739c.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--l8P4HULT--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2ihhlrw3qi8764gz739c.png" alt="Everything in Git" loading="lazy"></a></p>\n\n<p><strong>All files that constitute an application should be managed using source control.</strong></p>\n\n<p>Unfortunately, even though this rule seems pretty basic, there are a lot of organizations out there that fail to follow it. Traditionally, developers are using version control systems only for the source code of an application but leave out other supporting files such as installation scripts, configuration values, or test data.</p>\n\n<p>Everything that takes part in the application lifecycle should be checked into source control. This includes but is not limited to:</p>\n\n<ol>\n<li>Source code</li>\n<li>Build scripts</li>\n<li>Pipeline definition</li>\n<li>Configuration values</li>\n<li>Tests and test data</li>\n<li>Database schemas</li>\n<li>Database update scripts</li>\n<li>Infrastructure definition scripts</li>\n<li>Cleanup/installation/purging scripts</li>\n<li>Associated documentation</li>\n</ol>\n\n<p>The end goal is that anybody can check out everything that relates to an application and can recreate it locally or in any other alternative environment.</p>\n\n<p>A common anti-pattern we see is deployments happening with a special script that is available only on a specific machine or on the workstation of a specific team member, or even an attachment in a wiki page, and so on.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--HeqZ85qi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aie8bbgehy26fvp4hyes.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--HeqZ85qi--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aie8bbgehy26fvp4hyes.png" alt="Resources all over the place" loading="lazy"></a></p>\n\n<p>Version control also means that all these resources are audited and have a detailed history of all changes. If you want to see how the application looked 6 months ago, you can easily use the facilities of your version control system to obtain that information.</p>\n\n<p>Note that even though all these resources should be versioned control, it doesn’t have to be in the same repository. Whether you use multiple repositories or a single one, is a decision that needs careful consideration and has not a definitive answer. The important part however is to make sure that everything is indeed version controlled.</p>\n\n<p>Even though GitOps is the emerging practice of using Git operations for promotions and deployments, you don’t need to follow GitOps specifically to follow this best practice. Having historical and auditing information for your project assets is always a good thing, regardless of the actual software paradigm that you follow.</p>\n\n<h2>\n  <a name="best-practice-2-create-a-single-packagebinarycontainer-for-all-environments" href="#best-practice-2-create-a-single-packagebinarycontainer-for-all-environments">\n  </a>\n  Best Practice 2 – Create a Single package/binary/container for All Environments\n</h2>\n\n<p>One of the main functionalities of a CI/CD pipeline is to verify that a new feature is fit for deployment to production. This happens gradually as every step in a pipeline is essentially performing additional checks for that feature.</p>\n\n<p>For this paradigm to work, however, you need to make sure that what is being tested and prodded within a pipeline is also the same thing that gets deployed. In practice, this means that a feature/release should be packaged once and be deployed to all successive environments in the same manner.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--U5VgJLOQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r0dui53e5ck24zon31ig.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--U5VgJLOQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r0dui53e5ck24zon31ig.png" alt="Same artifact" loading="lazy"></a></p>\n\n<p>Unfortunately, a lot of organizations fall into the common trap of creating different artifacts for dev/staging/prod environments because they haven’t mastered yet a common infrastructure for configuration. This implies that they deploy a slightly different version of what was tested during the pipeline. Configuration discrepancies and last-minute changes are some of the biggest culprits when it comes to failed deployments, and having a different package per environment exacerbates this problem.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Ivwt5mJM--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mbypvdawbnndosrkntx5.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Ivwt5mJM--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mbypvdawbnndosrkntx5.png" alt="Different artifacts" loading="lazy"></a></p>\n\n<p>Instead of creating multiple versions per environment, the accepted practice is to have a single artifact that only changes configuration between different environments. With the appearance of containers and the ability to create a self-sufficient package of an application in the form of Docker images, there is no excuse for not following this practice.</p>\n\n<p>Regarding configuration there are two approaches:</p>\n\n<ol>\n<li>The binary artifact/container has all configurations embedded inside it and changes the active one according to the running environment (easy to start, but not very flexible. We don’t recommend this approach)</li>\n<li>The container has no configuration at all. It fetches needed configuration during runtime on demand using a discovery mechanism such as a key/value database, a filesystem volume, a service discovery mechanism, etc. (the recommended approach)</li>\n</ol>\n\n<p>The result is the guarantee where the exact binary/package that is deployed in production is also the one that was tested in the pipeline.</p>\n\n<h2>\n  <a name="best-practice-3-artifacts-not-git-commits-should-travel-within-a-pipeline" href="#best-practice-3-artifacts-not-git-commits-should-travel-within-a-pipeline">\n  </a>\n  Best Practice 3 – Artifacts, not Git Commits, should travel within a Pipeline\n</h2>\n\n<p>A corollary to the previous point (the same artifact/package should be deployed in all environments) is the fact that a deployment artifact <strong>should be built only once</strong>.</p>\n\n<p>The whole concept around containers (and VM images in the past) is to have <strong>immutable</strong> artifacts. An application is built only once with the latest feature or features that will soon be released.</p>\n\n<p>Once that artifact is built, it should move from each pipeline step to the next as an unchanged entity. Containers are the perfect vehicle for this immutability as they allow you to create an image only once (at the beginning of the pipeline) and promote it towards production with each successive pipeline step.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--yoMqs9uZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/u0vqsbhf3vw58cr6qkd8.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--yoMqs9uZ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/u0vqsbhf3vw58cr6qkd8.png" alt="Promote artifact" loading="lazy"></a></p>\n\n<p>Unfortunately, the common anti-pattern seen here is companies promoting commits instead of container images. A source code commit is traveling in the pipeline stages and each step is being rebuilt by checking out the source code again and again.</p>\n\n<p>This is a bad practice for two main reasons. First of all, it makes the pipeline very slow as packaging and compiling software is a very lengthy process and repeating it at each step is a waste of time and resources.</p>\n\n<p>Secondly, it breaks the previous rule. Recompiling a code commit at every pipeline step leaves the window open for resulting in a different artifact than before. You lose the guarantee that what is deploying in production is the same thing that was tested in the pipeline.</p>\n\n<h2>\n  <a name="best-practice-4-use-shortlived-branches-for-each-feature" href="#best-practice-4-use-shortlived-branches-for-each-feature">\n  </a>\n  Best Practice 4 – Use short-lived Branches for each feature\n</h2>\n\n<p>A sound pipeline has several quality gates (such as unit tests or security scans) that test the quality of a feature and its applicability to production deployments. In a development environment with a high velocity (and a big development team), not all features are expected to reach production right away. Some features may even clash with each other at their initial deployment version.</p>\n\n<p>To allow for fine-grained quality gating between features, a pipeline should have the power to veto individual features and be able to select only a subset of them for production deployment. The easiest way to obtain this guarantee is following the feature-per-branch methodology where short-lived features (i.e. that can fit within a single development sprint) correspond to individual source control branches.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--o7mNaenC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r8tv1zpa814vaqtv3fwg.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--o7mNaenC--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r8tv1zpa814vaqtv3fwg.png" alt="Short lived branches" loading="lazy"></a></p>\n\n<p>This makes the pipeline design very simple as everything revolves around individual features. Running test suites against a code branch tests only the new feature. Security scanning of a branch reveals problems with a new feature.</p>\n\n<p>Project stakeholders are then able to deploy and rollback individual features or block complete branches from even being merged into the mainline code.</p>\n\n<p>Unfortunately, there are still companies that have long-lived feature branches that collect multiple and unrelated features in a single batch. This not only makes merging a pain but also becomes problematic in case a single feature is found to have issues (as it is difficult to revert it individually).</p>\n\n<p>The evolution of short-lived branches is to follow <a href="https://trunkbaseddevelopment.com/">trunk-based development</a> and feature toggles. This can be your endgame but only if you have mastered short-lived branches first.</p>\n\n<h2>\n  <a name="best-practice-5-a-basic-build-should-take-a-single-step" href="#best-practice-5-a-basic-build-should-take-a-single-step">\n  </a>\n  Best Practice 5 – A basic build should take a single step\n</h2>\n\n<p>CI/CD pipelines are all about automation. It is very easy to automate something that already was very easy to run in the first place.</p>\n\n<p>Ideally, a simple build of a project should be a single command. That command usually calls the build system or a script (e.g., bash, PowerShell) that is responsible for taking the source code, running some basic tests, and packaging the final artifact/container.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--_4uKdbs9--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ocwptaneg1951yjlemam.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--_4uKdbs9--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ocwptaneg1951yjlemam.png" alt="Simple build" loading="lazy"></a></p>\n\n<p>It is ok if more advanced checks (such as load testing) need additional steps. The basic build, however (that results in a deployable artifact) should only involve a single command. A new developer should be able to check out a brand new copy of the source code, execute this single command and get immediately a deployable artifact.</p>\n\n<p>The same approach is true for deployments (deployments should happen with a single command)<br>\nThen if you need to create any pipeline you can simply insert that single step in any part of the pipeline.</p>\n\n<p>Unfortunately, there are still companies that suffer from many manual steps to get a basic build running. Downloading extra files, changing properties, and in general having big checklists that need to be followed are steps that should be automated within that very same script.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--6cKeEoWd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iqha5t1au71oozi8y0q9.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--6cKeEoWd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iqha5t1au71oozi8y0q9.png" alt="Many build steps" loading="lazy"></a></p>\n\n<p>If a new hire in your development team needs more than 15 minutes for the basic build (after checking out the code in their workstation) then you almost certainly suffer from this problem.</p>\n\n<p>A well-built CI/CD pipeline just repeats what is already possible on the local workstation. The basic build and deploy process should be already well oiled before being moved into a CI/CD platform.</p>\n\n<h2>\n  <a name="best-practice-6-basic-builds-are-fast-5-10-minutes" href="#best-practice-6-basic-builds-are-fast-5-10-minutes">\n  </a>\n  Best Practice 6 – Basic Builds are Fast (5 – 10 minutes)\n</h2>\n\n<p>Having a fast build is a big advantage for both developers and operators/sysadmins.</p>\n\n<p>Developers are happy when the feedback loop between a commit and its side effects is as short as possible. It is very easy to fix a bug in the code that you just committed as it is very fresh on your mind. Having to wait for one hour before developers can detect failed builds is a very frustrating experience.</p>\n\n<p>Builds should be fast both in the CI platform and in the local station. At any given point in time, multiple features are trying to enter the code mainline. The CI server can be easily overwhelmed if building them takes a lot of time.</p>\n\n<p>Operators also gain huge benefits from fast builds. Pushing hot fixes in production or rolling back to previous releases is always a stressful experience. The shorter this experience is the better. Rollbacks that take 30 minutes are much more difficult to work with than those that take three minutes.</p>\n\n<p>In summary, a basic build should be really fast. Ideally less than five minutes. If it takes more than 10 minutes, your team should investigate the causes and shorten that time. Modern build systems have great caching mechanisms.</p>\n\n<ul>\n<li>Library dependencies should be fetched from an internal proxy repository instead of the internet</li>\n<li>Avoid the use of code generators unless otherwise needed</li>\n<li>Split your unit (fast) and integration tests (slow) and only use unit tests for the basic build</li>\n<li>Fine-tune your container images to take full advantage of the Docker layer caching</li>\n</ul>\n\n<p>Getting faster builds is also one of the reasons that you should explore if you are moving to microservices.</p>\n\n<h2>\n  <a name="best-practice-7-storecache-your-dependencies" href="#best-practice-7-storecache-your-dependencies">\n  </a>\n  Best Practice 7 – Store/Cache Your Dependencies\n</h2>\n\n<p>It’s all over the news. The <a href="https://www.theregister.com/2016/03/23/npm_left_pad_chaos/">left-pad incident</a>. The <a href="https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610">dependency confusion hack</a>. While both incidents have great security implications, the truth is that storing your dependencies is also a very important tenet that is fundamental to the stability of your builds.</p>\n\n<p>Every considerable piece of code uses external dependencies in the form of libraries or associated tools. Your code should of course be always stored in Git. But all external libraries should be also stored by you in some sort of artifact repository.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--s2Z65ZA2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/egyaauig4d4wgkbqedi9.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--s2Z65ZA2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/egyaauig4d4wgkbqedi9.png" alt="Store your own dependencies" loading="lazy"></a></p>\n\n<p>Spend some time to collect our dependencies and understand where they are coming from. Apart from code libraries, other not-so-obvious moving parts are needed by a complete build as your base docker images or any command-line utilities that are needed for your builds.</p>\n\n<p>The best way to test your build for stability is to completely cut off internet access in your build servers (essentially simulating an air-gapped environment). Try to kick off a pipeline build where all your internal services (git, databases, artifact storage, container registry) are available, but nothing else from the public internet is accessible, and see what happens.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--u_M45pDr--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7hvrkyvp4nsfvpzgjrum.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--u_M45pDr--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7hvrkyvp4nsfvpzgjrum.png" alt="Straight from the internet" loading="lazy"></a>.</p>\n\n<p>If your build complains about a missing dependency, imagine that the same thing will happen in a real incident if that particular external resource is also down.</p>\n\n<p>Continued on <a href="https://dev.to/codefreshio/enterprise-ci-cd-best-practices-part-2-3o24">part2</a>. </p>\n\n<p>Cover photo by <a href="https://unsplash.com/photos/jHZ70nRk7Ns">Unsplash</a>.</p>\n\n',a.body_markdown="If you are trying to learn your way around Continuous Integration/Delivery/Deployment, you might notice that there are mostly two categories of resources:\n\n1. High-level overviews of [what CI/CD is and why you need it](https://codefresh.io/continuous-deployment/heck-continuous-integration-ci-delivery-cd-deployment-cdp/). These are great for when you are getting started but do not cover anything about day two operations or how to optimize an existing process.\n1. Detailed tutorials that cover only a specific aspect of CI/CD (e.g., just unit testing or just deployment) using specific programming languages and tools.\nWe believe that there is a gap between those two extremes. We are missing a proper guide that sits between those two categories by talking about best practices, but not in an abstract way. If you always wanted to read a guide about CI/CD that explains not just the “why” but also the “how” to apply best practices, then this guide is for you.\n\nWe will describe all the basic foundations of effective CI/CD workflows, but instead of talking only in generic terms, we will explain all the technicalities behind each best practice and more importantly, how it can affect you if you don’t adopt it.\n\n##Setting Priorities\n\nSeveral companies try to jump on the DevOps bandwagon without having mastered the basics first. You will soon realize that several problems which appear during the CI/CD process are usually pre-existing process problems that only became visible when that company tried to follow best practices in CI/CD pipelines.\n\nThe table below summarizes the requirements discussed in the rest of the guide. We also split the requirements according to priority:\n\n**Critical** requirements are essential to have before adopting DevOps or picking a solution for CI/CD. You should address them first. If you don’t, then they will block the process later down the road.\nRequirements with **High** priority are still important to address, but you can fix them while you are adopting a CI/CD platform\nRequirements with **Medium** priority can be addressed in the long run. Even though they will improve your deployment process, you can work around them until you find a proper solution.\n\n|Number | Best practice | Category | Importance |\n| --------- |---------| -------| -------|\n|1\t|All project assets are in source control\t|Artifacts\t|Critical|\n|2\t|A single artifact is produced for all environments\t|Artifacts\t|High|\n|3\t|Artifacts move within pipelines (and not source revisions)\t|Artifacts\t|High|\n|4\t|Development happens with short-lived branches (one per feature)\t|Build\t|High|\n|5\t|Builds can be performed in a single step\t|Build\t|High|\n|6\t|Builds are fast (less than 5 minutes)\t|Build\t|Medium|\n|7\t|Store your dependencies\t|Build\t|High|\n|8\t|Tests are automated\t|Testing\t|High|\n|9\t|Tests are fast\t|Testing\t|High|\n|10\t|Tests auto clean their side effects\t|Testing\t|High|\n|11\t|Multiple test suites exist\t|Testing\t|Medium\n|12\t|Test environments on demand\t|Testing\t|Medium|\n|13\t|Running test suites concurrently\t|Testing\t|Medium|\n|14\t|Security scanning is part of the process\t|Quality and Audit\t|High|\n|15\t|Quality scanning/Code reviews are part of the process\t|Quality and Audit\t|Medium|\n|16\t|Database updates have their lifecycle\t|Databases\t|High|\n|17\t|Database updates are automated\t|Databases\t|High|\n|18\t|Database updates are forward and backward compatible\t|Databases\t|High|\n|19\t|Deployments happen via a single path (CI/CD server)\t|Deployments\t|Critical|\n|20\t|Deployments happen gradually in stages\t|Deployments\t|High|\n|21\t|Metrics and logs can detect a bad deployment\t|Deployments\t|High|\n|22\t|Automatic rollbacks are in place\t|Deployments\t|Medium|\n|23\t|Staging matches production |Deployments\t|Medium|\n\n\n## Best Practice 1 – Place Everything Under Source Control\n\nArtifact management is perhaps the most important characteristic of a pipeline. At its most basic level, a pipeline creates binary/package artifacts from source code and deploys them to the appropriate infrastructure that powers the application that is being deployed.\n\nThe single most important rule to follow regarding assets and source code is the following:\n\n![Everything in Git](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/2ihhlrw3qi8764gz739c.png)\n\n**All files that constitute an application should be managed using source control.**\n\nUnfortunately, even though this rule seems pretty basic, there are a lot of organizations out there that fail to follow it. Traditionally, developers are using version control systems only for the source code of an application but leave out other supporting files such as installation scripts, configuration values, or test data.\n\nEverything that takes part in the application lifecycle should be checked into source control. This includes but is not limited to:\n\n1. Source code\n1. Build scripts\n1. Pipeline definition\n1. Configuration values\n1. Tests and test data\n1. Database schemas\n1. Database update scripts\n1. Infrastructure definition scripts\n1. Cleanup/installation/purging scripts\n1. Associated documentation\n\nThe end goal is that anybody can check out everything that relates to an application and can recreate it locally or in any other alternative environment.\n\nA common anti-pattern we see is deployments happening with a special script that is available only on a specific machine or on the workstation of a specific team member, or even an attachment in a wiki page, and so on.\n\n![Resources all over the place](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/aie8bbgehy26fvp4hyes.png)\n\nVersion control also means that all these resources are audited and have a detailed history of all changes. If you want to see how the application looked 6 months ago, you can easily use the facilities of your version control system to obtain that information.\n\nNote that even though all these resources should be versioned control, it doesn’t have to be in the same repository. Whether you use multiple repositories or a single one, is a decision that needs careful consideration and has not a definitive answer. The important part however is to make sure that everything is indeed version controlled.\n\nEven though GitOps is the emerging practice of using Git operations for promotions and deployments, you don’t need to follow GitOps specifically to follow this best practice. Having historical and auditing information for your project assets is always a good thing, regardless of the actual software paradigm that you follow.\n\n## Best Practice 2 – Create a Single package/binary/container for All Environments\n\nOne of the main functionalities of a CI/CD pipeline is to verify that a new feature is fit for deployment to production. This happens gradually as every step in a pipeline is essentially performing additional checks for that feature.\n\nFor this paradigm to work, however, you need to make sure that what is being tested and prodded within a pipeline is also the same thing that gets deployed. In practice, this means that a feature/release should be packaged once and be deployed to all successive environments in the same manner.\n\n![Same artifact](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r0dui53e5ck24zon31ig.png)\n\nUnfortunately, a lot of organizations fall into the common trap of creating different artifacts for dev/staging/prod environments because they haven’t mastered yet a common infrastructure for configuration. This implies that they deploy a slightly different version of what was tested during the pipeline. Configuration discrepancies and last-minute changes are some of the biggest culprits when it comes to failed deployments, and having a different package per environment exacerbates this problem.\n\n![Different artifacts](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mbypvdawbnndosrkntx5.png)\n\nInstead of creating multiple versions per environment, the accepted practice is to have a single artifact that only changes configuration between different environments. With the appearance of containers and the ability to create a self-sufficient package of an application in the form of Docker images, there is no excuse for not following this practice.\n\nRegarding configuration there are two approaches:\n\n1. The binary artifact/container has all configurations embedded inside it and changes the active one according to the running environment (easy to start, but not very flexible. We don’t recommend this approach)\n1. The container has no configuration at all. It fetches needed configuration during runtime on demand using a discovery mechanism such as a key/value database, a filesystem volume, a service discovery mechanism, etc. (the recommended approach)\n\nThe result is the guarantee where the exact binary/package that is deployed in production is also the one that was tested in the pipeline.\n\n## Best Practice 3 – Artifacts, not Git Commits, should travel within a Pipeline\n\nA corollary to the previous point (the same artifact/package should be deployed in all environments) is the fact that a deployment artifact **should be built only once**.\n\nThe whole concept around containers (and VM images in the past) is to have **immutable** artifacts. An application is built only once with the latest feature or features that will soon be released.\n\nOnce that artifact is built, it should move from each pipeline step to the next as an unchanged entity. Containers are the perfect vehicle for this immutability as they allow you to create an image only once (at the beginning of the pipeline) and promote it towards production with each successive pipeline step.\n\n![Promote artifact](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/u0vqsbhf3vw58cr6qkd8.png)\n\nUnfortunately, the common anti-pattern seen here is companies promoting commits instead of container images. A source code commit is traveling in the pipeline stages and each step is being rebuilt by checking out the source code again and again.\n\nThis is a bad practice for two main reasons. First of all, it makes the pipeline very slow as packaging and compiling software is a very lengthy process and repeating it at each step is a waste of time and resources.\n\nSecondly, it breaks the previous rule. Recompiling a code commit at every pipeline step leaves the window open for resulting in a different artifact than before. You lose the guarantee that what is deploying in production is the same thing that was tested in the pipeline.\n\n## Best Practice 4 – Use short-lived Branches for each feature\n\nA sound pipeline has several quality gates (such as unit tests or security scans) that test the quality of a feature and its applicability to production deployments. In a development environment with a high velocity (and a big development team), not all features are expected to reach production right away. Some features may even clash with each other at their initial deployment version.\n\nTo allow for fine-grained quality gating between features, a pipeline should have the power to veto individual features and be able to select only a subset of them for production deployment. The easiest way to obtain this guarantee is following the feature-per-branch methodology where short-lived features (i.e. that can fit within a single development sprint) correspond to individual source control branches.\n\n![Short lived branches](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/r8tv1zpa814vaqtv3fwg.png)\n\nThis makes the pipeline design very simple as everything revolves around individual features. Running test suites against a code branch tests only the new feature. Security scanning of a branch reveals problems with a new feature.\n\nProject stakeholders are then able to deploy and rollback individual features or block complete branches from even being merged into the mainline code.\n\nUnfortunately, there are still companies that have long-lived feature branches that collect multiple and unrelated features in a single batch. This not only makes merging a pain but also becomes problematic in case a single feature is found to have issues (as it is difficult to revert it individually).\n\nThe evolution of short-lived branches is to follow [trunk-based development](https://trunkbaseddevelopment.com/) and feature toggles. This can be your endgame but only if you have mastered short-lived branches first.\n\n## Best Practice 5 – A basic build should take a single step\n\nCI/CD pipelines are all about automation. It is very easy to automate something that already was very easy to run in the first place.\n\nIdeally, a simple build of a project should be a single command. That command usually calls the build system or a script (e.g., bash, PowerShell) that is responsible for taking the source code, running some basic tests, and packaging the final artifact/container.\n\n![Simple build](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ocwptaneg1951yjlemam.png)\n\nIt is ok if more advanced checks (such as load testing) need additional steps. The basic build, however (that results in a deployable artifact) should only involve a single command. A new developer should be able to check out a brand new copy of the source code, execute this single command and get immediately a deployable artifact.\n\nThe same approach is true for deployments (deployments should happen with a single command)\nThen if you need to create any pipeline you can simply insert that single step in any part of the pipeline.\n\nUnfortunately, there are still companies that suffer from many manual steps to get a basic build running. Downloading extra files, changing properties, and in general having big checklists that need to be followed are steps that should be automated within that very same script.\n\n![Many build steps](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/iqha5t1au71oozi8y0q9.png)\n\nIf a new hire in your development team needs more than 15 minutes for the basic build (after checking out the code in their workstation) then you almost certainly suffer from this problem.\n\nA well-built CI/CD pipeline just repeats what is already possible on the local workstation. The basic build and deploy process should be already well oiled before being moved into a CI/CD platform.\n\n## Best Practice 6 – Basic Builds are Fast (5 – 10 minutes)\n\nHaving a fast build is a big advantage for both developers and operators/sysadmins.\n\nDevelopers are happy when the feedback loop between a commit and its side effects is as short as possible. It is very easy to fix a bug in the code that you just committed as it is very fresh on your mind. Having to wait for one hour before developers can detect failed builds is a very frustrating experience.\n\nBuilds should be fast both in the CI platform and in the local station. At any given point in time, multiple features are trying to enter the code mainline. The CI server can be easily overwhelmed if building them takes a lot of time.\n\nOperators also gain huge benefits from fast builds. Pushing hot fixes in production or rolling back to previous releases is always a stressful experience. The shorter this experience is the better. Rollbacks that take 30 minutes are much more difficult to work with than those that take three minutes.\n\nIn summary, a basic build should be really fast. Ideally less than five minutes. If it takes more than 10 minutes, your team should investigate the causes and shorten that time. Modern build systems have great caching mechanisms.\n\n* Library dependencies should be fetched from an internal proxy repository instead of the internet\n* Avoid the use of code generators unless otherwise needed\n* Split your unit (fast) and integration tests (slow) and only use unit tests for the basic build\n* Fine-tune your container images to take full advantage of the Docker layer caching\n\nGetting faster builds is also one of the reasons that you should explore if you are moving to microservices.\n\n## Best Practice 7 – Store/Cache Your Dependencies\n\nIt’s all over the news. The [left-pad incident](https://www.theregister.com/2016/03/23/npm_left_pad_chaos/). The [dependency confusion hack](https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610). While both incidents have great security implications, the truth is that storing your dependencies is also a very important tenet that is fundamental to the stability of your builds.\n\nEvery considerable piece of code uses external dependencies in the form of libraries or associated tools. Your code should of course be always stored in Git. But all external libraries should be also stored by you in some sort of artifact repository.\n\n![Store your own dependencies](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/egyaauig4d4wgkbqedi9.png)\n\nSpend some time to collect our dependencies and understand where they are coming from. Apart from code libraries, other not-so-obvious moving parts are needed by a complete build as your base docker images or any command-line utilities that are needed for your builds.\n\nThe best way to test your build for stability is to completely cut off internet access in your build servers (essentially simulating an air-gapped environment). Try to kick off a pipeline build where all your internal services (git, databases, artifact storage, container registry) are available, but nothing else from the public internet is accessible, and see what happens.\n\n![Straight from the internet](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7hvrkyvp4nsfvpzgjrum.png).\n\nIf your build complains about a missing dependency, imagine that the same thing will happen in a real incident if that particular external resource is also down.\n\nContinued on [part2](https://dev.to/codefreshio/enterprise-ci-cd-best-practices-part-2-3o24). \n\nCover photo by [Unsplash](https://unsplash.com/photos/jHZ70nRk7Ns).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",a.user={name:"Kostis Kapelonis",username:"kostiscodefresh",twitter_username:e,github_username:"kostis-codefresh",website_url:"https://codefresh.io/",profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s--NAvfio9P--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/437938/7b372728-0ca1-4d45-961a-b170001a220d.png",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--PeaKTpE1--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/437938/7b372728-0ca1-4d45-961a-b170001a220d.png"},a.organization={name:"Codefresh",username:n,slug:n,profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s--eVMCUH5x--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/3138/a894848c-dd79-44fd-b477-3af28338d874.jpg",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--iHuWL-6D--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/3138/a894848c-dd79-44fd-b477-3af28338d874.jpg"},{layout:"default",data:[{}],fetch:{"data-v-70afb46a:0":{article:a}},error:e,state:{currentArticle:a},serverRendered:!0,routePath:"/kostiscodefresh/727745",config:{_app:{basePath:"/nuxtstop/",assetsPath:"/nuxtstop/_nuxt/",cdnURL:e}}}}(null,"2021-06-14T10:29:22Z",{},"codefreshio")</script><script src="/nuxtstop/_nuxt/f6e87fb.js" defer></script><script src="/nuxtstop/_nuxt/dc9ce94.js" defer></script><script src="/nuxtstop/_nuxt/6474719.js" defer></script><script src="/nuxtstop/_nuxt/9b75090.js" defer></script><script src="/nuxtstop/_nuxt/18df600.js" defer></script>
  </body>
</html>
