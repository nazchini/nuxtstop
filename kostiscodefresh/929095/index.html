<!doctype html>
<html data-n-head-ssr lang="en" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>Stop Using Branches for Deploying to Different GitOps Environments</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content="Using Nuxt.js fetch() hook to build dev.to with a new look"><meta data-n-head="ssr" name="format-detection" content="telephone=no"><base href="/nuxtstop/"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:400,500,600&display=swap"><link rel="preload" href="/nuxtstop/_nuxt/f6e87fb.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/6474719.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/9b75090.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/18df600.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/dc9ce94.js" as="script"><style data-vue-ssr-id="c650fd98:0 af4684f0:0 a9c71758:0 dcafa518:0 4b9cec49:0 b093d766:0 9d98bcb4:0 6b6a11ea:0 0248ed80:0 ea8e4264:0">html{box-sizing:border-box;font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}*,:after,:before{box-sizing:inherit}html{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,:after,:before{border:0 solid #e0e0e0}blockquote,body,dd,dl,figure,h1,h2,h3,h4,h5,h6,p,pre{margin:0}button{background:0 0;padding:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset,ol,ul{margin:0;padding:0}ol,ul{list-style:none}hr{border-width:1px}img{border-style:solid}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:inherit;opacity:.5}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:inherit;opacity:.5}input::placeholder,textarea::placeholder{color:inherit;opacity:.5}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit;font-family:sans-serif}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit;font-family:inherit;font-size:100%}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;overflow:auto;word-break:break-word;white-space:normal}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}html{height:100%;font-size:18px;-ms-overflow-style:scrollbar;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none}@media(min-width:640px){html{font-size:20px}}body{height:100%;min-width:320px;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:400;line-height:1.5;color:#000;background-color:#eff4f7;-webkit-text-rendering:optimizeLegibility;text-rendering:optimizeLegibility;font-synthesis:none;font-kerning:normal;font-feature-settings:"normal","kern";-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-overflow-scrolling:touch;overflow-x:hidden;overflow-y:scroll}h1,h2,h3,h4,h5,h6{color:#000;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:600;font-feature-settings:"normal";line-height:1.2}pre{background:#29292e;border-radius:2px;overflow:auto;padding:1rem;color:#eff1f9;line-height:1.42em;font-size:13px}@media screen and (min-width:380px){pre{font-size:15px}}pre code{background:#29292e;color:#eff0f9;white-space:pre}div.highlight pre.highlight code{font-size:inherit;padding:0}div.inner-comment div.body div.highlight pre.highlight{background:#29292e}div.inner-comment div.body div.highlight pre.highlight code{font-size:inherit;white-space:inherit;background:inherit;color:inherit}.highlight .hll{background-color:#49483e}.highlight{background:#29292e;color:#f8f8f2}.highlight .c{color:grey}.highlight .err{text-shadow:0 0 7px #f9690e}.highlight .k{color:#f39c12}.highlight .l{color:plum}.highlight .n{color:#f8f8f2}.highlight .o{color:#f9690e}.highlight .p{color:#f8f8f2}.highlight .c1,.highlight .ch,.highlight .cm,.highlight .cp,.highlight .cpf,.highlight .cs{color:grey}.highlight .gd{color:#f9690e}.highlight .ge{font-style:italic}.highlight .gi{color:#7ed07e}.highlight .gs{font-weight:700}.highlight .gu{color:grey}.highlight .kc,.highlight .kd{color:#f39c12}.highlight .kn{color:#f9690e}.highlight .kp,.highlight .kr,.highlight .kt{color:#f39c12}.highlight .ld{color:#f2ca27}.highlight .m{color:plum}.highlight .s{color:#f2ca27}.highlight .na{color:#7ed07e}.highlight .nb{color:#f8f8f2}.highlight .nc{color:#7ed07e}.highlight .no{color:#f39c12}.highlight .nd{color:#7ed07e}.highlight .ni{color:#f8f8f2}.highlight .ne,.highlight .nf{color:#7ed07e}.highlight .nl,.highlight .nn{color:#f8f8f2}.highlight .nx{color:#7ed07e}.highlight .py{color:#f8f8f2}.highlight .nt{color:#f9690e}.highlight .nv{color:#f8f8f2}.highlight .ow{color:#f9690e}.highlight .w{color:#f8f8f2}.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo{color:plum}.highlight .dl,.highlight .s2,.highlight .sa,.highlight .sb,.highlight .sc,.highlight .sd{color:#f2ca27}.highlight .se{color:plum}.highlight .s1,.highlight .sh,.highlight .si,.highlight .sr,.highlight .ss,.highlight .sx{color:#f2ca27}.highlight .bp{color:#f8f8f2}.highlight .fm{color:#7ed07e}.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#f8f8f2}.highlight .il{color:plum}.vue-content-placeholders-heading__img,.vue-content-placeholders-heading__subtitle,.vue-content-placeholders-heading__title,.vue-content-placeholders-img,.vue-content-placeholders-text__line{background:#bfcdec!important}.vue-content-placeholders-is-animated .vue-content-placeholders-heading__img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__subtitle:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__title:before,.vue-content-placeholders-is-animated .vue-content-placeholders-img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-text__line:before{background:linear-gradient(90deg,transparent 0,#d3ddf9 15%,transparent 30%)!important}header[data-v-27046cca]{max-width:1280px;margin:auto;padding:1rem;height:6rem;border-bottom:1px solid rgba(0,0,0,.2)}header .logo-wrapper[data-v-27046cca],header[data-v-27046cca]{display:flex;align-items:center;justify-content:space-between}header .logo-wrapper[data-v-27046cca]{margin:0 .5rem}header .logo-wrapper svg[data-v-27046cca]{width:3rem;height:100%}header .logo-wrapper .name-wrapper[data-v-27046cca]{margin-left:.6em}header .logo-wrapper .name-wrapper .subtitle[data-v-27046cca]{font-size:1rem}header .logo-wrapper .name-wrapper .app-name[data-v-27046cca]{font-weight:700;font-size:2.25rem;line-height:1.25}header nav[data-v-27046cca]{letter-spacing:-.025rem;font-weight:600;text-transform:uppercase}header nav ul[data-v-27046cca]{display:flex}header nav ul li[data-v-27046cca]{margin:0 .5rem}header nav ul li a[data-v-27046cca]{box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;padding:.25rem 1rem;border-radius:.5rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}header nav ul li a[data-v-27046cca]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header nav ul li a.nuxt-link-exact-active[data-v-27046cca]{cursor:default}header nav ul li a.nuxt-link-exact-active[data-v-27046cca],header nav ul li a[data-v-27046cca]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}.page-wrapper[data-v-10d06ee8]{max-width:1280px;margin:auto;padding:1rem}.article-content-wrapper[data-v-10d06ee8]{display:flex;flex-direction:column;align-items:center;margin:auto auto 2rem}@media(min-width:1024px){.article-content-wrapper[data-v-10d06ee8]{align-items:normal;flex-direction:row}}.article-content-wrapper .article-block[data-v-10d06ee8]{width:100%;max-width:880px}@media(min-width:1024px){.article-content-wrapper .article-block[data-v-10d06ee8]{margin-right:1rem;width:66.66666%;margin-bottom:2rem}}.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{max-width:880px;width:100%;position:relative}@media(min-width:1024px){.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{display:block;width:33.33333%}}.article-content-wrapper .aside-username-wrapper .aside-username-block[data-v-10d06ee8]{position:-webkit-sticky;position:sticky;top:1rem}@media(min-width:1280px){.comments-block[data-v-10d06ee8]{margin:.5rem}}article[data-v-70afb46a]{padding:.5rem;border-radius:1rem}header h1[data-v-70afb46a],header[data-v-70afb46a]{margin-bottom:1rem}header h1[data-v-70afb46a]{font-size:2.25rem;letter-spacing:-.025rem}header .tags[data-v-70afb46a]{display:flex;flex-wrap:wrap;margin-bottom:1.5rem}header .tags .tag[data-v-70afb46a]{font-weight:500;line-height:1;padding:.5rem;margin:0 .5rem .5rem 0;border-radius:.25rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db}header .tags .tag[data-v-70afb46a]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header .tags .tag[data-v-70afb46a]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}header .image-wrapper[data-v-70afb46a]{position:relative;padding-bottom:56.25%;background-color:#d4dfe8;margin-bottom:1.5rem;border-radius:.5rem;overflow:hidden}@media(min-width:834px){header .image-wrapper[data-v-70afb46a]{margin-bottom:1.5rem}}header .image-wrapper img[data-v-70afb46a]{position:absolute;top:0;left:0;width:100%;height:100%;-o-object-fit:cover;object-fit:cover}header .meta[data-v-70afb46a]{line-height:1;font-size:.875rem;text-transform:uppercase;font-weight:500;letter-spacing:-.025rem;display:flex;align-items:center;justify-content:space-between}header .meta .scl[data-v-70afb46a]{display:flex}header .meta .scl span[data-v-70afb46a]{display:flex;align-items:center;margin-right:1rem}header .meta .scl span svg[data-v-70afb46a]{margin-right:.25rem}header .meta .scl .comments[data-v-70afb46a]{cursor:pointer}[data-v-70afb46a] .content .ltag__user{display:none}[data-v-70afb46a] .content iframe{max-width:100%}[data-v-70afb46a] .content h1{font-size:1.875rem}[data-v-70afb46a] .content h1,[data-v-70afb46a] .content h2{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h2{font-size:1.5rem}[data-v-70afb46a] .content h3{font-size:1.25rem}[data-v-70afb46a] .content h3,[data-v-70afb46a] .content h4{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h4{font-size:1rem}[data-v-70afb46a] .content a{color:#6e87d2}[data-v-70afb46a] .content p{margin-bottom:1rem;line-height:1.4}[data-v-70afb46a] .content p code{background-color:#d2f3e1;border-radius:.25rem;padding:.25rem}[data-v-70afb46a] .content img{width:100%;border-radius:.5rem}[data-v-70afb46a] .content .highlight{margin-bottom:1rem;border-radius:.5rem}[data-v-70afb46a] .content ul{list-style:numeral;margin-bottom:1rem}[data-v-70afb46a] .content ul li p{margin-bottom:0}[data-v-70afb46a] .content ol{margin-bottom:1rem}aside[data-v-37984f8c]{padding:1rem;background-color:#dfe8ef;border-radius:1rem}aside .username-heading[data-v-37984f8c]{display:flex;margin-bottom:1rem}aside .username-heading[data-v-37984f8c]:hover{color:#6e87d2}aside .username-heading img[data-v-37984f8c]{width:3rem;height:3rem;border-radius:50%;margin-right:1rem}aside .username-heading .text[data-v-37984f8c]{display:flex;flex-direction:column;justify-content:center}aside .username-heading .text a[data-v-37984f8c]{line-height:1}aside .username-heading .text a[data-v-37984f8c]:first-child{font-size:1.25rem;font-weight:500;letter-spacing:-.025rem;margin-bottom:.25rem}aside .username-heading .text a[data-v-37984f8c]:last-child{color:#999;font-size:.875rem}aside .username-heading.loading[data-v-37984f8c]{display:block}aside .f-button[data-v-37984f8c]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}aside .f-button[data-v-37984f8c]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}aside .f-button[data-v-37984f8c]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}aside .info>div[data-v-37984f8c]{margin-bottom:.5rem}aside .info .title[data-v-37984f8c]{font-size:.666666rem;letter-spacing:-.0125rem;font-weight:500;color:#999;text-transform:uppercase;margin-bottom:.1rem}aside .info .content[data-v-37984f8c]{font-size:.875rem;line-height:1.4}.add-comment[data-v-8c4375bc]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}.add-comment[data-v-8c4375bc]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}.add-comment[data-v-8c4375bc]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}footer[data-v-22cb8fd0]{padding:2rem;text-align:center;display:flex;align-items:center;justify-content:center}footer span[data-v-22cb8fd0]{display:inline-block;line-height:1;text-transform:uppercase;letter-spacing:-.025rem;font-size:.75rem;font-weight:500}footer a svg[data-v-22cb8fd0]{width:3rem;height:3rem;margin:0 .5rem}footer a .nuxt-icon[data-v-22cb8fd0]{width:2.5rem;height:2.5rem;margin:0 .25rem}</style>
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><div id="__layout"><div><header data-v-27046cca><a href="/nuxtstop/" class="logo-wrapper nuxt-link-active" data-v-27046cca><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-27046cca><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-27046cca></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-27046cca></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-27046cca></path></svg> <div class="name-wrapper" data-v-27046cca><span class="app-name" data-v-27046cca>Nuxtstop</span> <p class="subtitle" data-v-27046cca>For all things nuxt.js</p></div></a> <nav data-v-27046cca><ul data-v-27046cca><li data-v-27046cca><a href="/nuxtstop/" class="nuxt-link-active" data-v-27046cca>
          New
        </a></li><li data-v-27046cca><a href="/nuxtstop/top" data-v-27046cca>
          Top
        </a></li></ul></nav></header> <div class="page-wrapper" data-v-10d06ee8><div class="article-content-wrapper" data-v-10d06ee8><article data-fetch-key="data-v-70afb46a:0" class="article-block" data-v-70afb46a data-v-10d06ee8><header data-v-70afb46a><h1 data-v-70afb46a>Stop Using Branches for Deploying to Different GitOps Environments</h1> <div class="tags" data-v-70afb46a><a href="/nuxtstop/t/devops" class="tag" data-v-70afb46a>
          #devops
        </a><a href="/nuxtstop/t/gitops" class="tag" data-v-70afb46a>
          #gitops
        </a><a href="/nuxtstop/t/kubernetes" class="tag" data-v-70afb46a>
          #kubernetes
        </a><a href="/nuxtstop/t/cloud" class="tag" data-v-70afb46a>
          #cloud
        </a></div> <div class="image-wrapper" data-v-70afb46a><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--QMfb_6Wm--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/igyepwk51t9rtwgh8qtf.png" alt="Stop Using Branches for Deploying to Different GitOps Environments" data-v-70afb46a></div> <div class="meta" data-v-70afb46a><div class="scl" data-v-70afb46a><span data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M16.4444 3C14.6733 3 13.0333 3.94162 12 5.34C10.9667 3.94162 9.32667 3 7.55556 3C4.49222 3 2 5.52338 2 8.625C2 14.8024 11.0267 20.586 11.4122 20.829C11.5922 20.9426 11.7956 21 12 21C12.2044 21 12.4078 20.9426 12.5878 20.829C12.9733 20.586 22 14.8024 22 8.625C22 5.52338 19.5078 3 16.4444 3Z" fill="#FF0000" data-v-70afb46a data-v-70afb46a></path></svg>
            6
          </span> <span class="comments" data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M6.11765 22H4.94118L5.64706 21.05C6.11765 20.3969 6.41176 19.5656 6.58824 18.5563C3.64706 17.1906 2 14.6375 2 11.3125C2 6.20625 5.82353 3 12 3C18.1765 3 22 6.20625 22 11.3125C22 16.5375 18.2353 19.625 12 19.625H11.5882C10.6471 20.7531 9 22 6.11765 22ZM12 4.1875C6.47059 4.1875 3.17647 6.85937 3.17647 11.3125C3.17647 15.1125 5.47059 16.8938 7.41177 17.6656L7.82353 17.8437L7.76471 18.3187C7.64706 19.2687 7.47059 20.1 7.11765 20.8125C9.05882 20.575 10.1765 19.5656 10.8235 18.7344L11 18.4969H12C19.9412 18.4969 20.8235 13.5094 20.8235 11.3719C20.8235 6.85938 17.5294 4.1875 12 4.1875Z" fill="black" data-v-70afb46a data-v-70afb46a></path></svg>
            1
          </span></div> <time data-v-70afb46a>Dec 17 '21</time></div></header> <div class="content" data-v-70afb46a><p>In our big guide <a href="https://codefresh.io/about-gitops/pains-gitops-1-0/">for GitOps problems</a>, we briefly explained (see points 3 and 4) how the current crop of GitOps tools don’t really cover the case of promotion between different environments or how even to model multi-cluster setups. </p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--RUD8aHf8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4hz1b2h79cvw9qk5ngpv.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--RUD8aHf8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4hz1b2h79cvw9qk5ngpv.png" alt="Image description" loading="lazy" width="851" height="218"></a></p>

<p>The question of “How do I promote a release to the next environment?” <a href="https://github.com/argoproj/argocd-example-apps/issues/57">is becoming increasingly popular</a> among organizations that want to adopt GitOps. And even though there are several possible answers, in this particular article I want to focus on what you should NOT do.</p>

<p>You should NOT use Git branches for modeling different environments. If the Git repository holding your configuration (manifests/templates in the case of Kubernetes) has branches named “staging”, “QA”, “Production” and so on, then you have fallen into a trap. </p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--TiC6mR9P--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4lq4pdn51s90e92evaq4.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--TiC6mR9P--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4lq4pdn51s90e92evaq4.png" alt="Branch for environment" loading="lazy" width="880" height="628"></a></p>

<p>Let me repeat that. Using Git branches for modeling different environments is an anti-pattern. Don’t do it!</p>

<p>We will explore the following points on why this practice is an anti-pattern:</p>

<ol>
<li>Using different Git branches for deployment environments is a relic of the past.</li>
<li>Pull requests and merges between different branches is problematic.</li>
<li>People are tempted to include environment specific code and create configuration drift.</li>
<li>As soon as you have a large number of environments, maintenance of all environments gets quickly out of hand.</li>
<li>The branch-per-environment model goes against the existing Kubernetes ecosystem.</li>
</ol>

<h2>
  <a name="using-branches-for-different-environments-should-only-be-applied-to-legacy-applications" href="#using-branches-for-different-environments-should-only-be-applied-to-legacy-applications">
  </a>
  Using branches for different environments should only be applied to legacy applications.
</h2>

<p>When I ask people why they chose to use Git branches for modelling different environments, almost always the answer is a variation of “we’ve always done it that way,” “it feels natural,” “this is what our developers know,” and so on.</p>

<p>And that is true. Most people are familiar with using branches for different environments. This practice was heavily popularized by the <a href="https://nvie.com/posts/a-successful-git-branching-model/">venerable Git-Flow model</a>. But since the introduction of this model, things have changed a lot. Even the original author has placed a huge warning at the top advising people <strong>against</strong> adopting this model without understanding the repercussions.</p>

<p>The fact is that the Git-flow model:</p>

<ul>
<li>Is focused on application source code and not environment configuration (let alone Kubernetes manifests).</li>
<li>Is best used when you need to support multiple versions of your application in production. This happens, but is not usually the case.</li>
</ul>

<p>I am not going to talk too much about Git-flow here and its disadvantages because the present article is about GitOps environments and not application source code, but in summary, you should follow <a href="https://trunkbaseddevelopment.com/">trunk-based development</a> and use <a href="https://trunkbaseddevelopment.com/feature-flags/">feature-flags</a> if you need to support different features for different environments.</p>

<p>In the context of GitOps, the application source code and your configuration should also be in different Git repositories (one repository with just application code and one repository with Kubernetes manifests/templates). This means that your choice of branching for the application source code should not affect how branches are used in the environment repository that defines your environments.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--nafL65i8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/76yb7to3r790jvn7nl52.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--nafL65i8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/76yb7to3r790jvn7nl52.png" alt="Different Git repos" loading="lazy" width="880" height="496"></a></p>

<p>When you adopt GitOps for your next project, you should start with a clean slate.  Application developers can choose whatever branching strategy they want for the application source code (and even use Git-flow), but the configuration Git repository (that has all the Kubernetes manifests/templates) should NOT follow the branch-per-environment model. </p>

<h2>
  <a name="promotion-is-never-a-simple-git-merge" href="#promotion-is-never-a-simple-git-merge">
  </a>
  Promotion is never a simple Git merge
</h2>

<p>Now that we know the history of using a branch-per-environment approach for deployments, we can talk about the actual disadvantages.</p>

<p>The main advantage of this approach is the argument that “Promotion is a simple git merge.” In theory, if you want to promote a release from QA to staging, you simply merge your QA branch into the staging branch. And when you are ready for production, you again merge the staging branch into the production branch, and you can be certain that all changes from staging have reached production. </p>

<p>Do you want to see what is different between production and staging? Just do a standard <a href="https://git-scm.com/docs/git-diff">git diff</a> between the two branches. Do you want to backport a configuration change from staging to QA? Again, a simple Git merge from the staging branch to qa will do the trick.</p>

<p>And if you want to place extra restrictions on promotions, you can use Pull Requests. So even though anybody could merge from qa to staging, if you want to merge something in the production branch, you can use a Pull Request and demand manual approval from all critical stakeholders.</p>

<p>This all sounds great in theory, and some trivial scenarios can actually work like this. But in practice, this is never the case. Promoting a release via a Git merge can suffer from merge conflicts, unwanted changes, and even the wrong order of changes.</p>

<p>As a simple example, let’s take this Kubernetes deployment that is currently sitting in the staging branch:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight yaml"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">example-deployment</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">15</span>
  <span class="na">template</span><span class="pi">:</span>
    <span class="na">metadata</span><span class="pi">:</span>
      <span class="na">labels</span><span class="pi">:</span>
        <span class="na">app</span><span class="pi">:</span> <span class="s">my-app</span>
    <span class="na">spec</span><span class="pi">:</span>
      <span class="na">containers</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">backend</span>
        <span class="na">image</span><span class="pi">:</span> <span class="s">my-app:2.2</span>
        <span class="na">ports</span><span class="pi">:</span>
        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>Your QA team has informed you that version 2.3 (which is in the QA branch) looks good, and it is ready to be moved to staging. You merge the QA branch to the staging branch, promoting the application and think that everything is good.</p>

<p>What you didn’t know is that somebody also changed the number of replicas in the QA branch to 2 because of some resource limitations. With your Git merge, you not only deployed 2.3 to staging, but you also scaled the replicas to 2 (instead of 15), and that is probably something that you don’t want.</p>

<p>You might argue that it would be easy to look at the replica count before merging, but remember that in a real scenario you have a large number of applications with a big number of manifests that are almost always templated (via Helm or Kustomize). So understanding what changes you want to bring and what to leave behind is not a trivial task.</p>

<p>And even if you do find changes that should not be promoted, you need to manually choose the “good” parts using <a href="https://git-scm.com/docs/git-cherry-pick">git cherry-pick</a> or other non-standard methods which are a far cry from the original “simple” Git merge.</p>

<p>But even if you are aware of all the changes that can be promoted, there are several cases where the order of promotion is not the same as the order of committing. As an example, the following 4 changes happen to the QA environment.</p>

<ol>
<li>The <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">ingress of the application</a> is updated with an extra hostname.</li>
<li>Release 2.5 is promoted to the QA branch and all QA people start testing.</li>
<li>A problem is found with 2.5 and a Kubernetes configmap is fixed.</li>
<li>
<a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/">Resource limits</a> are fine-tuned and committed to QA.</li>
</ol>

<p>It is then decided that the ingress setting and the resource limits should move to the next environment (staging). But the QA team has not finished testing with the 2.5 release. </p>

<p>If you blindly merge the QA branch to the staging branch, you will get all 4 changes at once, including the promotion of 2.5.</p>

<p>To resolve this, again you need to use git cherry-pick or other manual methods.</p>

<p>There are even more complicated cases where the commits have dependencies between them, so even cherry-pick will not work.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--89WJ0co7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mixt5bdlgy02wrrux4pk.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--89WJ0co7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mixt5bdlgy02wrrux4pk.png" alt="Git dependencies" loading="lazy" width="880" height="686"></a></p>

<p>In the example above, release 1.24 must be promoted to production. The problem is that one of the commits (the hotfix) contains a multitude of changes where some of them depend on another commit (the ingress config change) which itself cannot be moved to production (as it only applies only to staging). So even with cherry-picks, it is impossible to bring only the required changes from staging to production.</p>

<p>The end result is that promotion is never a simple Git merge. Most organizations will also have a large number of applications that go on a large number of clusters, composed by a large number of manifests. Manually choosing commits is a losing battle.</p>

<h2>
  <a name="configuration-drift-can-be-easily-created-by-environmentspecific-changes" href="#configuration-drift-can-be-easily-created-by-environmentspecific-changes">
  </a>
  Configuration drift can be easily created by environment-specific changes
</h2>

<p>In theory, configuration drift should not be an issue with Git merges. If you make a change in staging and then merge that branch to production, then all your changes should transfer to the new environment.</p>

<p>In practice, however, things are different because most organizations only merge to one direction, and team members are easily tempted to change upstream environments and never back-port the changes to downstream environments.</p>

<p>In the classic example with 3 environments for QA, Staging, and Production, the direction of Git merges only goes to one direction. People merge the qa branch to staging and the staging branch to production. This means that changes only flow upwards.</p>

<p>QA -> Staging -> Production.</p>

<p>The classic scenario is that a quick configuration change is needed in production (a hotfix), and somebody applies the fix there. In the case of Kubernetes, this hotfix can be anything such as a change in an existing manifest or even a brand new manifest.</p>

<p>Now Production has a completely different configuration than staging. Next time a release is promoted from Staging to Production, Git will only notify you on what you will bring from Staging. The ad hoc change on production will never appear anywhere in the Pull Request.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--MOSfGR4A--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pnnywcgta49ahrbcwox8.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--MOSfGR4A--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pnnywcgta49ahrbcwox8.png" alt="One direction only" loading="lazy" width="880" height="647"></a></p>

<p>This means that all subsequent deployments can fail, as production now has an undocumented change that will never be detected by any subsequent promotions.</p>

<p>In theory, you could backport such changes and merge periodically all commits from production to staging (and staging to QA). In practice, this never happens due to the reasons outlined in the previous point.</p>

<p>You can imagine that a large number of environments (and not just 3) further increases the problem. </p>

<p>In summary, promoting releases by Git merges does not solve configuration drift and in fact makes it even more problematic as teams are tempted to make ad hoc changes that are never promoted in sequence.</p>

<h2>
  <a name="managing-different-git-branches-for-a-large-number-of-environments-is-a-losing-battle" href="#managing-different-git-branches-for-a-large-number-of-environments-is-a-losing-battle">
  </a>
  Managing different Git branches for a large number of environments is a losing battle
</h2>

<p>In all the previous examples, I only used 3 environments (qa-> staging-> production) to illustrate the disadvantages of branch-based environment promotion.</p>

<p>Depending on the size of your organization, you will have many more environments. If you factor in other dimensions such as geographical location, the number of environments can quickly skyrocket.</p>

<p>For example, let’s take a company that has 5 environments:</p>

<ol>
<li>Load Testing </li>
<li>Integration testing </li>
<li>QA</li>
<li>Staging</li>
<li>Production</li>
</ol>

<p>Then let’s assume that the last 3 environments are also deployed to EU, US, and Asia while the first 2 also have GPU and Non-GPU variations. This means that the company has a total of 13 environments. And this is for a single application.</p>

<p>If you follow a branch-based approach for your environments:</p>

<ul>
<li>You need to have 13 long living Git branches at all times.</li>
<li>You need 19 pull requests for promoting a single change across all environments.</li>
<li>You have a two dimensional promotion matrix with 5 steps upwards and 2-3 steps outwards.</li>
<li>The possibilities for wrong merges, configuration drift and ad-hoc changes is now non-trivial across all environment combinations.</li>
</ul>

<p>In the context of this example organization, all previous issues are now more prevalent. </p>

<h2>
  <a name="the-branchperenvironment-model-goes-against-helmkustomize" href="#the-branchperenvironment-model-goes-against-helmkustomize">
  </a>
  The branch-per-environment model goes against Helm/Kustomize
</h2>

<p>Two of the most popular Kubernetes tools for describing applications are Helm and Kustomize. Let’s see how these two tools recommend modeling different environments.</p>

<p>For Helm, you need to create a generic chart that itself accepts parameters in the form of a values.yaml file. If you want to have different environments, <a href="https://codefresh.io/helm-tutorial/helm-deployment-environments/">you need multiple values files</a>.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Z_x087J3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3z0yl4gtd03ukjrghdxt.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Z_x087J3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3z0yl4gtd03ukjrghdxt.png" alt="Helm environments" loading="lazy" width="397" height="344"></a></p>

<p>For Kustomize, you need to create a “base” configuration, and then each environment is modeled as <a href="https://codefresh.io/about-gitops/applied-gitops-with-kustomize/">an overlay that has its own folder</a>:</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--n1nnEX00--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7xtgokjcisalztqsy7t3.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--n1nnEX00--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7xtgokjcisalztqsy7t3.png" alt="Kustomize Overlays" loading="lazy" width="616" height="630"></a></p>

<p>In both cases, different environments are modeled with different folders/files. Helm and Kustomize know nothing about Git branches or Git merges or Pull Requests. They use just plain files.</p>

<p>Let me repeat that again: Both Helm and Kustomize use plain files for different environments and not Git branches. This should be a good hint on how to model different Kubernetes configurations using either of these tools.</p>

<p>If you introduce Git branches in the mix, you not only introduce extra complexity, but you also go against your own tooling.</p>

<h2>
  <a name="the-recommended-way-to-promote-releases-in-gitops-environments" href="#the-recommended-way-to-promote-releases-in-gitops-environments">
  </a>
  The recommended way to promote releases in GitOps environments
</h2>

<p>Modeling different Kubernetes environments and promoting a release between them is a very common issue for all teams that adopt GitOps. Even though a very popular method is to use Git branches for each environment and assume that a promotion is a “simple” Git merge, we have seen in this article that this is an anti-pattern.</p>

<p>In the next article, we will see a better approach to model your different environments and promote releases between your Kubernetes cluster. The last point of the article (regarding Helm/Kustomize) should already give you a hint on how this approach works.</p>

<p>Stay tuned!</p>

</div></article> <div class="aside-username-wrapper" data-v-10d06ee8><aside class="aside-username-block" data-v-37984f8c data-v-10d06ee8><div class="username-heading loading" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-heading" data-v-37984f8c><div class="vue-content-placeholders-heading__img"></div> <div class="vue-content-placeholders-heading__content"><div class="vue-content-placeholders-heading__title"></div> <div class="vue-content-placeholders-heading__subtitle"></div></div></div></div></div> <div class="info" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-text" data-v-37984f8c><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div></div></div></div></aside></div></div> <div class="comments-block" data-v-8c4375bc data-v-10d06ee8><!----> <a href="https://dev.to/kostiscodefresh/stop-using-branches-for-deploying-to-different-gitops-environments-5bmj" target="_blank" rel="nofollow noopener noreferer" class="add-comment" data-v-8c4375bc>
    Add comment
  </a></div></div> <footer data-v-22cb8fd0><span data-v-22cb8fd0>Built with</span> <a href="https://nuxtjs.org" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="nuxt-icon" data-v-22cb8fd0 data-v-22cb8fd0><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a> <span data-v-22cb8fd0>&</span> <a href="https://docs.dev.to/api" rel="nofollow noopener" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-22cb8fd0 data-v-22cb8fd0><path d="M1.5726 5.13748C1.42945 5.20622 1.2411 5.36661 1.15822 5.48117C1 5.69503 1 5.74849 1 11.8739C1 17.9993 1 18.0528 1.15822 18.2667C1.2411 18.3812 1.42945 18.5416 1.5726 18.6104C1.8137 18.7402 2.46164 18.7478 12 18.7478C21.5384 18.7478 22.1863 18.7402 22.4274 18.6104C22.5706 18.5416 22.7589 18.3812 22.8418 18.2667C23 18.0528 23 17.9993 23 11.8739C23 5.74849 23 5.69503 22.8418 5.48117C22.7589 5.36661 22.5706 5.20622 22.4274 5.13748C22.1863 5.00764 21.5384 5 12 5C2.46164 5 1.8137 5.00764 1.5726 5.13748ZM7.7055 8.2613C8.0822 8.45989 8.59454 9.0098 8.77536 9.40694C8.89589 9.66664 8.91095 9.94922 8.91095 12.0649C8.91095 14.3104 8.90344 14.4478 8.75275 14.7839C8.51919 15.288 8.16506 15.6546 7.68288 15.899C7.26096 16.1052 7.22328 16.1128 5.7315 16.1358L4.20206 16.1663V12.1031V8.04744L5.80684 8.07035C7.27602 8.09327 7.42672 8.10854 7.7055 8.2613ZM13.6952 8.89521V9.73538H12.4521H11.2089V10.4991V11.2629H11.9623H12.7158V12.1031V12.9432H11.9623H11.2089V13.707V14.4708H12.4521H13.6952V15.3109V16.151H12C10.1315 16.151 10.0411 16.1358 9.67191 15.6928L9.47603 15.4484V12.1336C9.47603 8.46752 9.46851 8.49807 9.95069 8.20783C10.1692 8.07035 10.3425 8.05508 11.9473 8.05508H13.6952V8.89521ZM16.5658 10.3769C16.8897 11.6295 17.1685 12.6912 17.176 12.7293C17.1911 12.7675 17.4699 11.7441 17.8014 10.461C18.1254 9.17017 18.4343 8.1009 18.4795 8.08563C18.5247 8.06271 18.9541 8.06271 19.4288 8.07035L20.3028 8.09327L19.376 11.6219C18.8713 13.5542 18.4117 15.2269 18.3664 15.3261C18.0123 16.0135 17.274 16.3343 16.7164 16.0441C16.4528 15.899 16.0911 15.4865 15.9705 15.1887C15.9254 15.0665 15.4884 13.4549 15.0062 11.6142C14.524 9.76593 14.1171 8.20783 14.0945 8.15437C14.0644 8.07035 14.2301 8.05508 15.0212 8.07035L15.9856 8.09327L16.5658 10.3769Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M5.93491 12.103V14.4707H6.27394C6.66574 14.4707 7.01983 14.3103 7.1404 14.0965C7.18559 14.0048 7.21575 13.2105 7.21575 12.0648V10.1783L6.99725 9.95683C6.80133 9.76591 6.71847 9.73535 6.35683 9.73535H5.93491V12.103Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a></footer></div></div></div><script>window.__NUXT__=function(e,n,t,a){return n.type_of="article",n.id=929095,n.title="Stop Using Branches for Deploying to Different GitOps Environments",n.description="In our big guide for GitOps problems, we briefly explained (see points 3 and 4) how the current crop...",n.readable_publish_date="Dec 17 '21",n.slug="stop-using-branches-for-deploying-to-different-gitops-environments-5bmj",n.path="/codefreshio/stop-using-branches-for-deploying-to-different-gitops-environments-5bmj",n.url="https://dev.to/codefreshio/stop-using-branches-for-deploying-to-different-gitops-environments-5bmj",n.comments_count=1,n.public_reactions_count=6,n.collection_id=e,n.published_timestamp=t,n.positive_reactions_count=6,n.cover_image="https://res.cloudinary.com/practicaldev/image/fetch/s--QMfb_6Wm--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/igyepwk51t9rtwgh8qtf.png",n.social_image="https://res.cloudinary.com/practicaldev/image/fetch/s--gbKFKKeG--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/igyepwk51t9rtwgh8qtf.png",n.canonical_url="https://codefresh.io/about-gitops/branches-gitops-environments/",n.created_at="2021-12-17T13:20:02Z",n.edited_at=e,n.crossposted_at=e,n.published_at=t,n.last_comment_at="2022-01-24T22:58:18Z",n.reading_time_minutes=9,n.tag_list="devops, gitops, kubernetes, cloud",n.tags=["devops","gitops","kubernetes","cloud"],n.body_html='<p>In our big guide <a href="https://codefresh.io/about-gitops/pains-gitops-1-0/">for GitOps problems</a>, we briefly explained (see points 3 and 4) how the current crop of GitOps tools don’t really cover the case of promotion between different environments or how even to model multi-cluster setups. </p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--RUD8aHf8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4hz1b2h79cvw9qk5ngpv.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--RUD8aHf8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4hz1b2h79cvw9qk5ngpv.png" alt="Image description" loading="lazy" width="851" height="218"></a></p>\n\n<p>The question of “How do I promote a release to the next environment?” <a href="https://github.com/argoproj/argocd-example-apps/issues/57">is becoming increasingly popular</a> among organizations that want to adopt GitOps. And even though there are several possible answers, in this particular article I want to focus on what you should NOT do.</p>\n\n<p>You should NOT use Git branches for modeling different environments. If the Git repository holding your configuration (manifests/templates in the case of Kubernetes) has branches named “staging”, “QA”, “Production” and so on, then you have fallen into a trap. </p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--TiC6mR9P--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4lq4pdn51s90e92evaq4.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--TiC6mR9P--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4lq4pdn51s90e92evaq4.png" alt="Branch for environment" loading="lazy" width="880" height="628"></a></p>\n\n<p>Let me repeat that. Using Git branches for modeling different environments is an anti-pattern. Don’t do it!</p>\n\n<p>We will explore the following points on why this practice is an anti-pattern:</p>\n\n<ol>\n<li>Using different Git branches for deployment environments is a relic of the past.</li>\n<li>Pull requests and merges between different branches is problematic.</li>\n<li>People are tempted to include environment specific code and create configuration drift.</li>\n<li>As soon as you have a large number of environments, maintenance of all environments gets quickly out of hand.</li>\n<li>The branch-per-environment model goes against the existing Kubernetes ecosystem.</li>\n</ol>\n\n<h2>\n  <a name="using-branches-for-different-environments-should-only-be-applied-to-legacy-applications" href="#using-branches-for-different-environments-should-only-be-applied-to-legacy-applications">\n  </a>\n  Using branches for different environments should only be applied to legacy applications.\n</h2>\n\n<p>When I ask people why they chose to use Git branches for modelling different environments, almost always the answer is a variation of “we’ve always done it that way,” “it feels natural,” “this is what our developers know,” and so on.</p>\n\n<p>And that is true. Most people are familiar with using branches for different environments. This practice was heavily popularized by the <a href="https://nvie.com/posts/a-successful-git-branching-model/">venerable Git-Flow model</a>. But since the introduction of this model, things have changed a lot. Even the original author has placed a huge warning at the top advising people <strong>against</strong> adopting this model without understanding the repercussions.</p>\n\n<p>The fact is that the Git-flow model:</p>\n\n<ul>\n<li>Is focused on application source code and not environment configuration (let alone Kubernetes manifests).</li>\n<li>Is best used when you need to support multiple versions of your application in production. This happens, but is not usually the case.</li>\n</ul>\n\n<p>I am not going to talk too much about Git-flow here and its disadvantages because the present article is about GitOps environments and not application source code, but in summary, you should follow <a href="https://trunkbaseddevelopment.com/">trunk-based development</a> and use <a href="https://trunkbaseddevelopment.com/feature-flags/">feature-flags</a> if you need to support different features for different environments.</p>\n\n<p>In the context of GitOps, the application source code and your configuration should also be in different Git repositories (one repository with just application code and one repository with Kubernetes manifests/templates). This means that your choice of branching for the application source code should not affect how branches are used in the environment repository that defines your environments.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--nafL65i8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/76yb7to3r790jvn7nl52.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--nafL65i8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/76yb7to3r790jvn7nl52.png" alt="Different Git repos" loading="lazy" width="880" height="496"></a></p>\n\n<p>When you adopt GitOps for your next project, you should start with a clean slate.  Application developers can choose whatever branching strategy they want for the application source code (and even use Git-flow), but the configuration Git repository (that has all the Kubernetes manifests/templates) should NOT follow the branch-per-environment model. </p>\n\n<h2>\n  <a name="promotion-is-never-a-simple-git-merge" href="#promotion-is-never-a-simple-git-merge">\n  </a>\n  Promotion is never a simple Git merge\n</h2>\n\n<p>Now that we know the history of using a branch-per-environment approach for deployments, we can talk about the actual disadvantages.</p>\n\n<p>The main advantage of this approach is the argument that “Promotion is a simple git merge.” In theory, if you want to promote a release from QA to staging, you simply merge your QA branch into the staging branch. And when you are ready for production, you again merge the staging branch into the production branch, and you can be certain that all changes from staging have reached production. </p>\n\n<p>Do you want to see what is different between production and staging? Just do a standard <a href="https://git-scm.com/docs/git-diff">git diff</a> between the two branches. Do you want to backport a configuration change from staging to QA? Again, a simple Git merge from the staging branch to qa will do the trick.</p>\n\n<p>And if you want to place extra restrictions on promotions, you can use Pull Requests. So even though anybody could merge from qa to staging, if you want to merge something in the production branch, you can use a Pull Request and demand manual approval from all critical stakeholders.</p>\n\n<p>This all sounds great in theory, and some trivial scenarios can actually work like this. But in practice, this is never the case. Promoting a release via a Git merge can suffer from merge conflicts, unwanted changes, and even the wrong order of changes.</p>\n\n<p>As a simple example, let’s take this Kubernetes deployment that is currently sitting in the staging branch:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight yaml"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">apps/v1</span>\n<span class="na">kind</span><span class="pi">:</span> <span class="s">Deployment</span>\n<span class="na">metadata</span><span class="pi">:</span>\n  <span class="na">name</span><span class="pi">:</span> <span class="s">example-deployment</span>\n<span class="na">spec</span><span class="pi">:</span>\n  <span class="na">replicas</span><span class="pi">:</span> <span class="m">15</span>\n  <span class="na">template</span><span class="pi">:</span>\n    <span class="na">metadata</span><span class="pi">:</span>\n      <span class="na">labels</span><span class="pi">:</span>\n        <span class="na">app</span><span class="pi">:</span> <span class="s">my-app</span>\n    <span class="na">spec</span><span class="pi">:</span>\n      <span class="na">containers</span><span class="pi">:</span>\n      <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">backend</span>\n        <span class="na">image</span><span class="pi">:</span> <span class="s">my-app:2.2</span>\n        <span class="na">ports</span><span class="pi">:</span>\n        <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>Your QA team has informed you that version 2.3 (which is in the QA branch) looks good, and it is ready to be moved to staging. You merge the QA branch to the staging branch, promoting the application and think that everything is good.</p>\n\n<p>What you didn’t know is that somebody also changed the number of replicas in the QA branch to 2 because of some resource limitations. With your Git merge, you not only deployed 2.3 to staging, but you also scaled the replicas to 2 (instead of 15), and that is probably something that you don’t want.</p>\n\n<p>You might argue that it would be easy to look at the replica count before merging, but remember that in a real scenario you have a large number of applications with a big number of manifests that are almost always templated (via Helm or Kustomize). So understanding what changes you want to bring and what to leave behind is not a trivial task.</p>\n\n<p>And even if you do find changes that should not be promoted, you need to manually choose the “good” parts using <a href="https://git-scm.com/docs/git-cherry-pick">git cherry-pick</a> or other non-standard methods which are a far cry from the original “simple” Git merge.</p>\n\n<p>But even if you are aware of all the changes that can be promoted, there are several cases where the order of promotion is not the same as the order of committing. As an example, the following 4 changes happen to the QA environment.</p>\n\n<ol>\n<li>The <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/">ingress of the application</a> is updated with an extra hostname.</li>\n<li>Release 2.5 is promoted to the QA branch and all QA people start testing.</li>\n<li>A problem is found with 2.5 and a Kubernetes configmap is fixed.</li>\n<li>\n<a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/">Resource limits</a> are fine-tuned and committed to QA.</li>\n</ol>\n\n<p>It is then decided that the ingress setting and the resource limits should move to the next environment (staging). But the QA team has not finished testing with the 2.5 release. </p>\n\n<p>If you blindly merge the QA branch to the staging branch, you will get all 4 changes at once, including the promotion of 2.5.</p>\n\n<p>To resolve this, again you need to use git cherry-pick or other manual methods.</p>\n\n<p>There are even more complicated cases where the commits have dependencies between them, so even cherry-pick will not work.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--89WJ0co7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mixt5bdlgy02wrrux4pk.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--89WJ0co7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mixt5bdlgy02wrrux4pk.png" alt="Git dependencies" loading="lazy" width="880" height="686"></a></p>\n\n<p>In the example above, release 1.24 must be promoted to production. The problem is that one of the commits (the hotfix) contains a multitude of changes where some of them depend on another commit (the ingress config change) which itself cannot be moved to production (as it only applies only to staging). So even with cherry-picks, it is impossible to bring only the required changes from staging to production.</p>\n\n<p>The end result is that promotion is never a simple Git merge. Most organizations will also have a large number of applications that go on a large number of clusters, composed by a large number of manifests. Manually choosing commits is a losing battle.</p>\n\n<h2>\n  <a name="configuration-drift-can-be-easily-created-by-environmentspecific-changes" href="#configuration-drift-can-be-easily-created-by-environmentspecific-changes">\n  </a>\n  Configuration drift can be easily created by environment-specific changes\n</h2>\n\n<p>In theory, configuration drift should not be an issue with Git merges. If you make a change in staging and then merge that branch to production, then all your changes should transfer to the new environment.</p>\n\n<p>In practice, however, things are different because most organizations only merge to one direction, and team members are easily tempted to change upstream environments and never back-port the changes to downstream environments.</p>\n\n<p>In the classic example with 3 environments for QA, Staging, and Production, the direction of Git merges only goes to one direction. People merge the qa branch to staging and the staging branch to production. This means that changes only flow upwards.</p>\n\n<p>QA -&gt; Staging -&gt; Production.</p>\n\n<p>The classic scenario is that a quick configuration change is needed in production (a hotfix), and somebody applies the fix there. In the case of Kubernetes, this hotfix can be anything such as a change in an existing manifest or even a brand new manifest.</p>\n\n<p>Now Production has a completely different configuration than staging. Next time a release is promoted from Staging to Production, Git will only notify you on what you will bring from Staging. The ad hoc change on production will never appear anywhere in the Pull Request.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--MOSfGR4A--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pnnywcgta49ahrbcwox8.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--MOSfGR4A--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pnnywcgta49ahrbcwox8.png" alt="One direction only" loading="lazy" width="880" height="647"></a></p>\n\n<p>This means that all subsequent deployments can fail, as production now has an undocumented change that will never be detected by any subsequent promotions.</p>\n\n<p>In theory, you could backport such changes and merge periodically all commits from production to staging (and staging to QA). In practice, this never happens due to the reasons outlined in the previous point.</p>\n\n<p>You can imagine that a large number of environments (and not just 3) further increases the problem. </p>\n\n<p>In summary, promoting releases by Git merges does not solve configuration drift and in fact makes it even more problematic as teams are tempted to make ad hoc changes that are never promoted in sequence.</p>\n\n<h2>\n  <a name="managing-different-git-branches-for-a-large-number-of-environments-is-a-losing-battle" href="#managing-different-git-branches-for-a-large-number-of-environments-is-a-losing-battle">\n  </a>\n  Managing different Git branches for a large number of environments is a losing battle\n</h2>\n\n<p>In all the previous examples, I only used 3 environments (qa-&gt; staging-&gt; production) to illustrate the disadvantages of branch-based environment promotion.</p>\n\n<p>Depending on the size of your organization, you will have many more environments. If you factor in other dimensions such as geographical location, the number of environments can quickly skyrocket.</p>\n\n<p>For example, let’s take a company that has 5 environments:</p>\n\n<ol>\n<li>Load Testing </li>\n<li>Integration testing </li>\n<li>QA</li>\n<li>Staging</li>\n<li>Production</li>\n</ol>\n\n<p>Then let’s assume that the last 3 environments are also deployed to EU, US, and Asia while the first 2 also have GPU and Non-GPU variations. This means that the company has a total of 13 environments. And this is for a single application.</p>\n\n<p>If you follow a branch-based approach for your environments:</p>\n\n<ul>\n<li>You need to have 13 long living Git branches at all times.</li>\n<li>You need 19 pull requests for promoting a single change across all environments.</li>\n<li>You have a two dimensional promotion matrix with 5 steps upwards and 2-3 steps outwards.</li>\n<li>The possibilities for wrong merges, configuration drift and ad-hoc changes is now non-trivial across all environment combinations.</li>\n</ul>\n\n<p>In the context of this example organization, all previous issues are now more prevalent. </p>\n\n<h2>\n  <a name="the-branchperenvironment-model-goes-against-helmkustomize" href="#the-branchperenvironment-model-goes-against-helmkustomize">\n  </a>\n  The branch-per-environment model goes against Helm/Kustomize\n</h2>\n\n<p>Two of the most popular Kubernetes tools for describing applications are Helm and Kustomize. Let’s see how these two tools recommend modeling different environments.</p>\n\n<p>For Helm, you need to create a generic chart that itself accepts parameters in the form of a values.yaml file. If you want to have different environments, <a href="https://codefresh.io/helm-tutorial/helm-deployment-environments/">you need multiple values files</a>.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Z_x087J3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3z0yl4gtd03ukjrghdxt.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Z_x087J3--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3z0yl4gtd03ukjrghdxt.png" alt="Helm environments" loading="lazy" width="397" height="344"></a></p>\n\n<p>For Kustomize, you need to create a “base” configuration, and then each environment is modeled as <a href="https://codefresh.io/about-gitops/applied-gitops-with-kustomize/">an overlay that has its own folder</a>:</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--n1nnEX00--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7xtgokjcisalztqsy7t3.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--n1nnEX00--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7xtgokjcisalztqsy7t3.png" alt="Kustomize Overlays" loading="lazy" width="616" height="630"></a></p>\n\n<p>In both cases, different environments are modeled with different folders/files. Helm and Kustomize know nothing about Git branches or Git merges or Pull Requests. They use just plain files.</p>\n\n<p>Let me repeat that again: Both Helm and Kustomize use plain files for different environments and not Git branches. This should be a good hint on how to model different Kubernetes configurations using either of these tools.</p>\n\n<p>If you introduce Git branches in the mix, you not only introduce extra complexity, but you also go against your own tooling.</p>\n\n<h2>\n  <a name="the-recommended-way-to-promote-releases-in-gitops-environments" href="#the-recommended-way-to-promote-releases-in-gitops-environments">\n  </a>\n  The recommended way to promote releases in GitOps environments\n</h2>\n\n<p>Modeling different Kubernetes environments and promoting a release between them is a very common issue for all teams that adopt GitOps. Even though a very popular method is to use Git branches for each environment and assume that a promotion is a “simple” Git merge, we have seen in this article that this is an anti-pattern.</p>\n\n<p>In the next article, we will see a better approach to model your different environments and promote releases between your Kubernetes cluster. The last point of the article (regarding Helm/Kustomize) should already give you a hint on how this approach works.</p>\n\n<p>Stay tuned!</p>\n\n',n.body_markdown="In our big guide [for GitOps problems](https://codefresh.io/about-gitops/pains-gitops-1-0/), we briefly explained (see points 3 and 4) how the current crop of GitOps tools don’t really cover the case of promotion between different environments or how even to model multi-cluster setups. \n\n\n![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4hz1b2h79cvw9qk5ngpv.png)\n\nThe question of “How do I promote a release to the next environment?” [is becoming increasingly popular](https://github.com/argoproj/argocd-example-apps/issues/57) among organizations that want to adopt GitOps. And even though there are several possible answers, in this particular article I want to focus on what you should NOT do.\n\nYou should NOT use Git branches for modeling different environments. If the Git repository holding your configuration (manifests/templates in the case of Kubernetes) has branches named “staging”, “QA”, “Production” and so on, then you have fallen into a trap. \n\n\n![Branch for environment](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4lq4pdn51s90e92evaq4.png)\n\nLet me repeat that. Using Git branches for modeling different environments is an anti-pattern. Don’t do it!\n\nWe will explore the following points on why this practice is an anti-pattern:\n\n1. Using different Git branches for deployment environments is a relic of the past.\n1. Pull requests and merges between different branches is problematic.\n1. People are tempted to include environment specific code and create configuration drift.\n1. As soon as you have a large number of environments, maintenance of all environments gets quickly out of hand.\n1. The branch-per-environment model goes against the existing Kubernetes ecosystem.\n\n## Using branches for different environments should only be applied to legacy applications.\n\nWhen I ask people why they chose to use Git branches for modelling different environments, almost always the answer is a variation of “we’ve always done it that way,” “it feels natural,” “this is what our developers know,” and so on.\n\nAnd that is true. Most people are familiar with using branches for different environments. This practice was heavily popularized by the [venerable Git-Flow model](https://nvie.com/posts/a-successful-git-branching-model/). But since the introduction of this model, things have changed a lot. Even the original author has placed a huge warning at the top advising people **against** adopting this model without understanding the repercussions.\n\nThe fact is that the Git-flow model:\n\n* Is focused on application source code and not environment configuration (let alone Kubernetes manifests).\n* Is best used when you need to support multiple versions of your application in production. This happens, but is not usually the case.\n\nI am not going to talk too much about Git-flow here and its disadvantages because the present article is about GitOps environments and not application source code, but in summary, you should follow [trunk-based development](https://trunkbaseddevelopment.com/) and use [feature-flags](https://trunkbaseddevelopment.com/feature-flags/) if you need to support different features for different environments.\n\nIn the context of GitOps, the application source code and your configuration should also be in different Git repositories (one repository with just application code and one repository with Kubernetes manifests/templates). This means that your choice of branching for the application source code should not affect how branches are used in the environment repository that defines your environments.\n\n\n![Different Git repos](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/76yb7to3r790jvn7nl52.png)\n\nWhen you adopt GitOps for your next project, you should start with a clean slate.  Application developers can choose whatever branching strategy they want for the application source code (and even use Git-flow), but the configuration Git repository (that has all the Kubernetes manifests/templates) should NOT follow the branch-per-environment model. \n\n## Promotion is never a simple Git merge\n\nNow that we know the history of using a branch-per-environment approach for deployments, we can talk about the actual disadvantages.\n\nThe main advantage of this approach is the argument that “Promotion is a simple git merge.” In theory, if you want to promote a release from QA to staging, you simply merge your QA branch into the staging branch. And when you are ready for production, you again merge the staging branch into the production branch, and you can be certain that all changes from staging have reached production. \n\nDo you want to see what is different between production and staging? Just do a standard [git diff](https://git-scm.com/docs/git-diff) between the two branches. Do you want to backport a configuration change from staging to QA? Again, a simple Git merge from the staging branch to qa will do the trick.\n\nAnd if you want to place extra restrictions on promotions, you can use Pull Requests. So even though anybody could merge from qa to staging, if you want to merge something in the production branch, you can use a Pull Request and demand manual approval from all critical stakeholders.\n\nThis all sounds great in theory, and some trivial scenarios can actually work like this. But in practice, this is never the case. Promoting a release via a Git merge can suffer from merge conflicts, unwanted changes, and even the wrong order of changes.\n\nAs a simple example, let’s take this Kubernetes deployment that is currently sitting in the staging branch:\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: example-deployment\nspec:\n  replicas: 15\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      containers:\n      - name: backend\n        image: my-app:2.2\n        ports:\n        - containerPort: 80\n```\n\nYour QA team has informed you that version 2.3 (which is in the QA branch) looks good, and it is ready to be moved to staging. You merge the QA branch to the staging branch, promoting the application and think that everything is good.\n\nWhat you didn’t know is that somebody also changed the number of replicas in the QA branch to 2 because of some resource limitations. With your Git merge, you not only deployed 2.3 to staging, but you also scaled the replicas to 2 (instead of 15), and that is probably something that you don’t want.\n\nYou might argue that it would be easy to look at the replica count before merging, but remember that in a real scenario you have a large number of applications with a big number of manifests that are almost always templated (via Helm or Kustomize). So understanding what changes you want to bring and what to leave behind is not a trivial task.\n\nAnd even if you do find changes that should not be promoted, you need to manually choose the “good” parts using [git cherry-pick](https://git-scm.com/docs/git-cherry-pick) or other non-standard methods which are a far cry from the original “simple” Git merge.\n\nBut even if you are aware of all the changes that can be promoted, there are several cases where the order of promotion is not the same as the order of committing. As an example, the following 4 changes happen to the QA environment.\n\n1. The [ingress of the application](https://kubernetes.io/docs/concepts/services-networking/ingress/) is updated with an extra hostname.\n1. Release 2.5 is promoted to the QA branch and all QA people start testing.\n1. A problem is found with 2.5 and a Kubernetes configmap is fixed.\n1. [Resource limits](https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/) are fine-tuned and committed to QA.\n\nIt is then decided that the ingress setting and the resource limits should move to the next environment (staging). But the QA team has not finished testing with the 2.5 release. \n\nIf you blindly merge the QA branch to the staging branch, you will get all 4 changes at once, including the promotion of 2.5.\n\nTo resolve this, again you need to use git cherry-pick or other manual methods.\n\nThere are even more complicated cases where the commits have dependencies between them, so even cherry-pick will not work.\n\n\n![Git dependencies](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/mixt5bdlgy02wrrux4pk.png)\n\nIn the example above, release 1.24 must be promoted to production. The problem is that one of the commits (the hotfix) contains a multitude of changes where some of them depend on another commit (the ingress config change) which itself cannot be moved to production (as it only applies only to staging). So even with cherry-picks, it is impossible to bring only the required changes from staging to production.\n\nThe end result is that promotion is never a simple Git merge. Most organizations will also have a large number of applications that go on a large number of clusters, composed by a large number of manifests. Manually choosing commits is a losing battle.\n\n## Configuration drift can be easily created by environment-specific changes\n\nIn theory, configuration drift should not be an issue with Git merges. If you make a change in staging and then merge that branch to production, then all your changes should transfer to the new environment.\n\nIn practice, however, things are different because most organizations only merge to one direction, and team members are easily tempted to change upstream environments and never back-port the changes to downstream environments.\n\nIn the classic example with 3 environments for QA, Staging, and Production, the direction of Git merges only goes to one direction. People merge the qa branch to staging and the staging branch to production. This means that changes only flow upwards.\n\nQA -> Staging -> Production.\n\nThe classic scenario is that a quick configuration change is needed in production (a hotfix), and somebody applies the fix there. In the case of Kubernetes, this hotfix can be anything such as a change in an existing manifest or even a brand new manifest.\n\nNow Production has a completely different configuration than staging. Next time a release is promoted from Staging to Production, Git will only notify you on what you will bring from Staging. The ad hoc change on production will never appear anywhere in the Pull Request.\n\n\n![One direction only](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/pnnywcgta49ahrbcwox8.png)\n\nThis means that all subsequent deployments can fail, as production now has an undocumented change that will never be detected by any subsequent promotions.\n\nIn theory, you could backport such changes and merge periodically all commits from production to staging (and staging to QA). In practice, this never happens due to the reasons outlined in the previous point.\n\nYou can imagine that a large number of environments (and not just 3) further increases the problem. \n\nIn summary, promoting releases by Git merges does not solve configuration drift and in fact makes it even more problematic as teams are tempted to make ad hoc changes that are never promoted in sequence.\n\n## Managing different Git branches for a large number of environments is a losing battle\n\nIn all the previous examples, I only used 3 environments (qa-> staging-> production) to illustrate the disadvantages of branch-based environment promotion.\n\nDepending on the size of your organization, you will have many more environments. If you factor in other dimensions such as geographical location, the number of environments can quickly skyrocket.\n\nFor example, let’s take a company that has 5 environments:\n\n1. Load Testing \n1. Integration testing \n1. QA\n1. Staging\n1. Production\n\nThen let’s assume that the last 3 environments are also deployed to EU, US, and Asia while the first 2 also have GPU and Non-GPU variations. This means that the company has a total of 13 environments. And this is for a single application.\n\nIf you follow a branch-based approach for your environments:\n\n* You need to have 13 long living Git branches at all times.\n* You need 19 pull requests for promoting a single change across all environments.\n* You have a two dimensional promotion matrix with 5 steps upwards and 2-3 steps outwards.\n* The possibilities for wrong merges, configuration drift and ad-hoc changes is now non-trivial across all environment combinations.\n\nIn the context of this example organization, all previous issues are now more prevalent. \n\n## The branch-per-environment model goes against Helm/Kustomize\n\nTwo of the most popular Kubernetes tools for describing applications are Helm and Kustomize. Let’s see how these two tools recommend modeling different environments.\n\nFor Helm, you need to create a generic chart that itself accepts parameters in the form of a values.yaml file. If you want to have different environments, [you need multiple values files](https://codefresh.io/helm-tutorial/helm-deployment-environments/).\n\n\n![Helm environments](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3z0yl4gtd03ukjrghdxt.png)\n\nFor Kustomize, you need to create a “base” configuration, and then each environment is modeled as [an overlay that has its own folder](https://codefresh.io/about-gitops/applied-gitops-with-kustomize/):\n\n\n![Kustomize Overlays](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/7xtgokjcisalztqsy7t3.png)\n\nIn both cases, different environments are modeled with different folders/files. Helm and Kustomize know nothing about Git branches or Git merges or Pull Requests. They use just plain files.\n\nLet me repeat that again: Both Helm and Kustomize use plain files for different environments and not Git branches. This should be a good hint on how to model different Kubernetes configurations using either of these tools.\n\nIf you introduce Git branches in the mix, you not only introduce extra complexity, but you also go against your own tooling.\n\n## The recommended way to promote releases in GitOps environments\n\nModeling different Kubernetes environments and promoting a release between them is a very common issue for all teams that adopt GitOps. Even though a very popular method is to use Git branches for each environment and assume that a promotion is a “simple” Git merge, we have seen in this article that this is an anti-pattern.\n\nIn the next article, we will see a better approach to model your different environments and promote releases between your Kubernetes cluster. The last point of the article (regarding Helm/Kustomize) should already give you a hint on how this approach works.\n\nStay tuned!\n\n\n\n\n\n\n\n\n\n\n",n.user={name:"Kostis Kapelonis",username:"kostiscodefresh",twitter_username:e,github_username:"kostis-codefresh",website_url:"https://codefresh.io/",profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s--NAvfio9P--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/437938/7b372728-0ca1-4d45-961a-b170001a220d.png",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--PeaKTpE1--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/437938/7b372728-0ca1-4d45-961a-b170001a220d.png"},n.organization={name:"Codefresh",username:a,slug:a,profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s--eVMCUH5x--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/3138/a894848c-dd79-44fd-b477-3af28338d874.jpg",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--iHuWL-6D--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/3138/a894848c-dd79-44fd-b477-3af28338d874.jpg"},{layout:"default",data:[{}],fetch:{"data-v-70afb46a:0":{article:n}},error:e,state:{currentArticle:n},serverRendered:!0,routePath:"/kostiscodefresh/929095",config:{_app:{basePath:"/nuxtstop/",assetsPath:"/nuxtstop/_nuxt/",cdnURL:e}}}}(null,{},"2021-12-17T13:20:56Z","codefreshio")</script><script src="/nuxtstop/_nuxt/f6e87fb.js" defer></script><script src="/nuxtstop/_nuxt/dc9ce94.js" defer></script><script src="/nuxtstop/_nuxt/6474719.js" defer></script><script src="/nuxtstop/_nuxt/9b75090.js" defer></script><script src="/nuxtstop/_nuxt/18df600.js" defer></script>
  </body>
</html>
