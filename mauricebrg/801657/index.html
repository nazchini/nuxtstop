<!doctype html>
<html data-n-head-ssr lang="en" data-n-head="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>One-to-Many relationships and the process of data modelling in DynamoDB</title><meta data-n-head="ssr" charset="utf-8"><meta data-n-head="ssr" name="viewport" content="width=device-width,initial-scale=1"><meta data-n-head="ssr" data-hid="description" name="description" content="Using Nuxt.js fetch() hook to build dev.to with a new look"><meta data-n-head="ssr" name="format-detection" content="telephone=no"><base href="/nuxtstop/"><link data-n-head="ssr" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="ssr" rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter:400,500,600&display=swap"><link rel="preload" href="/nuxtstop/_nuxt/f6e87fb.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/6474719.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/9b75090.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/18df600.js" as="script"><link rel="preload" href="/nuxtstop/_nuxt/dc9ce94.js" as="script"><style data-vue-ssr-id="c650fd98:0 af4684f0:0 a9c71758:0 dcafa518:0 4b9cec49:0 b093d766:0 9d98bcb4:0 6b6a11ea:0 0248ed80:0 ea8e4264:0">html{box-sizing:border-box;font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}*,:after,:before{box-sizing:inherit}html{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";line-height:1.5}*,:after,:before{border:0 solid #e0e0e0}blockquote,body,dd,dl,figure,h1,h2,h3,h4,h5,h6,p,pre{margin:0}button{background:0 0;padding:0}button:focus{outline:1px dotted;outline:5px auto -webkit-focus-ring-color}fieldset,ol,ul{margin:0;padding:0}ol,ul{list-style:none}hr{border-width:1px}img{border-style:solid}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:inherit;opacity:.5}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:inherit;opacity:.5}input::placeholder,textarea::placeholder{color:inherit;opacity:.5}[role=button],button{cursor:pointer}table{border-collapse:collapse}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit;font-family:sans-serif}a{color:inherit;text-decoration:inherit}button,input,optgroup,select,textarea{padding:0;line-height:inherit;color:inherit;font-family:inherit;font-size:100%}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;overflow:auto;word-break:break-word;white-space:normal}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}html{height:100%;font-size:18px;-ms-overflow-style:scrollbar;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none}@media(min-width:640px){html{font-size:20px}}body{height:100%;min-width:320px;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:400;line-height:1.5;color:#000;background-color:#eff4f7;-webkit-text-rendering:optimizeLegibility;text-rendering:optimizeLegibility;font-synthesis:none;font-kerning:normal;font-feature-settings:"normal","kern";-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-overflow-scrolling:touch;overflow-x:hidden;overflow-y:scroll}h1,h2,h3,h4,h5,h6{color:#000;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-weight:600;font-feature-settings:"normal";line-height:1.2}pre{background:#29292e;border-radius:2px;overflow:auto;padding:1rem;color:#eff1f9;line-height:1.42em;font-size:13px}@media screen and (min-width:380px){pre{font-size:15px}}pre code{background:#29292e;color:#eff0f9;white-space:pre}div.highlight pre.highlight code{font-size:inherit;padding:0}div.inner-comment div.body div.highlight pre.highlight{background:#29292e}div.inner-comment div.body div.highlight pre.highlight code{font-size:inherit;white-space:inherit;background:inherit;color:inherit}.highlight .hll{background-color:#49483e}.highlight{background:#29292e;color:#f8f8f2}.highlight .c{color:grey}.highlight .err{text-shadow:0 0 7px #f9690e}.highlight .k{color:#f39c12}.highlight .l{color:plum}.highlight .n{color:#f8f8f2}.highlight .o{color:#f9690e}.highlight .p{color:#f8f8f2}.highlight .c1,.highlight .ch,.highlight .cm,.highlight .cp,.highlight .cpf,.highlight .cs{color:grey}.highlight .gd{color:#f9690e}.highlight .ge{font-style:italic}.highlight .gi{color:#7ed07e}.highlight .gs{font-weight:700}.highlight .gu{color:grey}.highlight .kc,.highlight .kd{color:#f39c12}.highlight .kn{color:#f9690e}.highlight .kp,.highlight .kr,.highlight .kt{color:#f39c12}.highlight .ld{color:#f2ca27}.highlight .m{color:plum}.highlight .s{color:#f2ca27}.highlight .na{color:#7ed07e}.highlight .nb{color:#f8f8f2}.highlight .nc{color:#7ed07e}.highlight .no{color:#f39c12}.highlight .nd{color:#7ed07e}.highlight .ni{color:#f8f8f2}.highlight .ne,.highlight .nf{color:#7ed07e}.highlight .nl,.highlight .nn{color:#f8f8f2}.highlight .nx{color:#7ed07e}.highlight .py{color:#f8f8f2}.highlight .nt{color:#f9690e}.highlight .nv{color:#f8f8f2}.highlight .ow{color:#f9690e}.highlight .w{color:#f8f8f2}.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo{color:plum}.highlight .dl,.highlight .s2,.highlight .sa,.highlight .sb,.highlight .sc,.highlight .sd{color:#f2ca27}.highlight .se{color:plum}.highlight .s1,.highlight .sh,.highlight .si,.highlight .sr,.highlight .ss,.highlight .sx{color:#f2ca27}.highlight .bp{color:#f8f8f2}.highlight .fm{color:#7ed07e}.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#f8f8f2}.highlight .il{color:plum}.vue-content-placeholders-heading__img,.vue-content-placeholders-heading__subtitle,.vue-content-placeholders-heading__title,.vue-content-placeholders-img,.vue-content-placeholders-text__line{background:#bfcdec!important}.vue-content-placeholders-is-animated .vue-content-placeholders-heading__img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__subtitle:before,.vue-content-placeholders-is-animated .vue-content-placeholders-heading__title:before,.vue-content-placeholders-is-animated .vue-content-placeholders-img:before,.vue-content-placeholders-is-animated .vue-content-placeholders-text__line:before{background:linear-gradient(90deg,transparent 0,#d3ddf9 15%,transparent 30%)!important}header[data-v-27046cca]{max-width:1280px;margin:auto;padding:1rem;height:6rem;border-bottom:1px solid rgba(0,0,0,.2)}header .logo-wrapper[data-v-27046cca],header[data-v-27046cca]{display:flex;align-items:center;justify-content:space-between}header .logo-wrapper[data-v-27046cca]{margin:0 .5rem}header .logo-wrapper svg[data-v-27046cca]{width:3rem;height:100%}header .logo-wrapper .name-wrapper[data-v-27046cca]{margin-left:.6em}header .logo-wrapper .name-wrapper .subtitle[data-v-27046cca]{font-size:1rem}header .logo-wrapper .name-wrapper .app-name[data-v-27046cca]{font-weight:700;font-size:2.25rem;line-height:1.25}header nav[data-v-27046cca]{letter-spacing:-.025rem;font-weight:600;text-transform:uppercase}header nav ul[data-v-27046cca]{display:flex}header nav ul li[data-v-27046cca]{margin:0 .5rem}header nav ul li a[data-v-27046cca]{box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;padding:.25rem 1rem;border-radius:.5rem;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}header nav ul li a[data-v-27046cca]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header nav ul li a.nuxt-link-exact-active[data-v-27046cca]{cursor:default}header nav ul li a.nuxt-link-exact-active[data-v-27046cca],header nav ul li a[data-v-27046cca]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}.page-wrapper[data-v-10d06ee8]{max-width:1280px;margin:auto;padding:1rem}.article-content-wrapper[data-v-10d06ee8]{display:flex;flex-direction:column;align-items:center;margin:auto auto 2rem}@media(min-width:1024px){.article-content-wrapper[data-v-10d06ee8]{align-items:normal;flex-direction:row}}.article-content-wrapper .article-block[data-v-10d06ee8]{width:100%;max-width:880px}@media(min-width:1024px){.article-content-wrapper .article-block[data-v-10d06ee8]{margin-right:1rem;width:66.66666%;margin-bottom:2rem}}.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{max-width:880px;width:100%;position:relative}@media(min-width:1024px){.article-content-wrapper .aside-username-wrapper[data-v-10d06ee8]{display:block;width:33.33333%}}.article-content-wrapper .aside-username-wrapper .aside-username-block[data-v-10d06ee8]{position:-webkit-sticky;position:sticky;top:1rem}@media(min-width:1280px){.comments-block[data-v-10d06ee8]{margin:.5rem}}article[data-v-70afb46a]{padding:.5rem;border-radius:1rem}header h1[data-v-70afb46a],header[data-v-70afb46a]{margin-bottom:1rem}header h1[data-v-70afb46a]{font-size:2.25rem;letter-spacing:-.025rem}header .tags[data-v-70afb46a]{display:flex;flex-wrap:wrap;margin-bottom:1.5rem}header .tags .tag[data-v-70afb46a]{font-weight:500;line-height:1;padding:.5rem;margin:0 .5rem .5rem 0;border-radius:.25rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db}header .tags .tag[data-v-70afb46a]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}header .tags .tag[data-v-70afb46a]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}header .image-wrapper[data-v-70afb46a]{position:relative;padding-bottom:56.25%;background-color:#d4dfe8;margin-bottom:1.5rem;border-radius:.5rem;overflow:hidden}@media(min-width:834px){header .image-wrapper[data-v-70afb46a]{margin-bottom:1.5rem}}header .image-wrapper img[data-v-70afb46a]{position:absolute;top:0;left:0;width:100%;height:100%;-o-object-fit:cover;object-fit:cover}header .meta[data-v-70afb46a]{line-height:1;font-size:.875rem;text-transform:uppercase;font-weight:500;letter-spacing:-.025rem;display:flex;align-items:center;justify-content:space-between}header .meta .scl[data-v-70afb46a]{display:flex}header .meta .scl span[data-v-70afb46a]{display:flex;align-items:center;margin-right:1rem}header .meta .scl span svg[data-v-70afb46a]{margin-right:.25rem}header .meta .scl .comments[data-v-70afb46a]{cursor:pointer}[data-v-70afb46a] .content .ltag__user{display:none}[data-v-70afb46a] .content iframe{max-width:100%}[data-v-70afb46a] .content h1{font-size:1.875rem}[data-v-70afb46a] .content h1,[data-v-70afb46a] .content h2{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h2{font-size:1.5rem}[data-v-70afb46a] .content h3{font-size:1.25rem}[data-v-70afb46a] .content h3,[data-v-70afb46a] .content h4{margin-top:2rem;margin-bottom:1rem;letter-spacing:-.025rem}[data-v-70afb46a] .content h4{font-size:1rem}[data-v-70afb46a] .content a{color:#6e87d2}[data-v-70afb46a] .content p{margin-bottom:1rem;line-height:1.4}[data-v-70afb46a] .content p code{background-color:#d2f3e1;border-radius:.25rem;padding:.25rem}[data-v-70afb46a] .content img{width:100%;border-radius:.5rem}[data-v-70afb46a] .content .highlight{margin-bottom:1rem;border-radius:.5rem}[data-v-70afb46a] .content ul{list-style:numeral;margin-bottom:1rem}[data-v-70afb46a] .content ul li p{margin-bottom:0}[data-v-70afb46a] .content ol{margin-bottom:1rem}aside[data-v-37984f8c]{padding:1rem;background-color:#dfe8ef;border-radius:1rem}aside .username-heading[data-v-37984f8c]{display:flex;margin-bottom:1rem}aside .username-heading[data-v-37984f8c]:hover{color:#6e87d2}aside .username-heading img[data-v-37984f8c]{width:3rem;height:3rem;border-radius:50%;margin-right:1rem}aside .username-heading .text[data-v-37984f8c]{display:flex;flex-direction:column;justify-content:center}aside .username-heading .text a[data-v-37984f8c]{line-height:1}aside .username-heading .text a[data-v-37984f8c]:first-child{font-size:1.25rem;font-weight:500;letter-spacing:-.025rem;margin-bottom:.25rem}aside .username-heading .text a[data-v-37984f8c]:last-child{color:#999;font-size:.875rem}aside .username-heading.loading[data-v-37984f8c]{display:block}aside .f-button[data-v-37984f8c]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}aside .f-button[data-v-37984f8c]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}aside .f-button[data-v-37984f8c]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}aside .info>div[data-v-37984f8c]{margin-bottom:.5rem}aside .info .title[data-v-37984f8c]{font-size:.666666rem;letter-spacing:-.0125rem;font-weight:500;color:#999;text-transform:uppercase;margin-bottom:.1rem}aside .info .content[data-v-37984f8c]{font-size:.875rem;line-height:1.4}.add-comment[data-v-8c4375bc]{display:block;width:100%;padding:.5rem;border-radius:.5rem;box-shadow:-4px -4px 8px #f8fafe,4px 4px 8px #ced2db;text-transform:uppercase;text-align:center;font-weight:600;letter-spacing:-.025rem;margin-bottom:1rem}.add-comment[data-v-8c4375bc]:hover{background:linear-gradient(135deg,rgba(0,0,0,.09),hsla(0,0%,100%,0))}.add-comment[data-v-8c4375bc]:active{background:0 0;box-shadow:inset -4px -4px 8px #f0f3f9,inset 4px 4px 8px #ced2db,inset -1px -1px 4px #8e8e8e}footer[data-v-22cb8fd0]{padding:2rem;text-align:center;display:flex;align-items:center;justify-content:center}footer span[data-v-22cb8fd0]{display:inline-block;line-height:1;text-transform:uppercase;letter-spacing:-.025rem;font-size:.75rem;font-weight:500}footer a svg[data-v-22cb8fd0]{width:3rem;height:3rem;margin:0 .5rem}footer a .nuxt-icon[data-v-22cb8fd0]{width:2.5rem;height:2.5rem;margin:0 .25rem}</style>
  </head>
  <body>
    <div data-server-rendered="true" id="__nuxt"><div id="__layout"><div><header data-v-27046cca><a href="/nuxtstop/" class="logo-wrapper nuxt-link-active" data-v-27046cca><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-27046cca><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-27046cca></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-27046cca></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-27046cca></path></svg> <div class="name-wrapper" data-v-27046cca><span class="app-name" data-v-27046cca>Nuxtstop</span> <p class="subtitle" data-v-27046cca>For all things nuxt.js</p></div></a> <nav data-v-27046cca><ul data-v-27046cca><li data-v-27046cca><a href="/nuxtstop/" class="nuxt-link-active" data-v-27046cca>
          New
        </a></li><li data-v-27046cca><a href="/nuxtstop/top" data-v-27046cca>
          Top
        </a></li></ul></nav></header> <div class="page-wrapper" data-v-10d06ee8><div class="article-content-wrapper" data-v-10d06ee8><article data-fetch-key="data-v-70afb46a:0" class="article-block" data-v-70afb46a data-v-10d06ee8><header data-v-70afb46a><h1 data-v-70afb46a>One-to-Many relationships and the process of data modelling in DynamoDB</h1> <div class="tags" data-v-70afb46a><a href="/nuxtstop/t/aws" class="tag" data-v-70afb46a>
          #aws
        </a><a href="/nuxtstop/t/database" class="tag" data-v-70afb46a>
          #database
        </a><a href="/nuxtstop/t/cloud" class="tag" data-v-70afb46a>
          #cloud
        </a><a href="/nuxtstop/t/dynamodb" class="tag" data-v-70afb46a>
          #dynamodb
        </a></div> <div class="image-wrapper" data-v-70afb46a><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--ZeKUekZ9--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/y3dux1tkl194lwp5vyfy.png" alt="One-to-Many relationships and the process of data modelling in DynamoDB" data-v-70afb46a></div> <div class="meta" data-v-70afb46a><div class="scl" data-v-70afb46a><span data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M16.4444 3C14.6733 3 13.0333 3.94162 12 5.34C10.9667 3.94162 9.32667 3 7.55556 3C4.49222 3 2 5.52338 2 8.625C2 14.8024 11.0267 20.586 11.4122 20.829C11.5922 20.9426 11.7956 21 12 21C12.2044 21 12.4078 20.9426 12.5878 20.829C12.9733 20.586 22 14.8024 22 8.625C22 5.52338 19.5078 3 16.4444 3Z" fill="#FF0000" data-v-70afb46a data-v-70afb46a></path></svg>
            18
          </span> <span class="comments" data-v-70afb46a><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-70afb46a data-v-70afb46a><path d="M6.11765 22H4.94118L5.64706 21.05C6.11765 20.3969 6.41176 19.5656 6.58824 18.5563C3.64706 17.1906 2 14.6375 2 11.3125C2 6.20625 5.82353 3 12 3C18.1765 3 22 6.20625 22 11.3125C22 16.5375 18.2353 19.625 12 19.625H11.5882C10.6471 20.7531 9 22 6.11765 22ZM12 4.1875C6.47059 4.1875 3.17647 6.85937 3.17647 11.3125C3.17647 15.1125 5.47059 16.8938 7.41177 17.6656L7.82353 17.8437L7.76471 18.3187C7.64706 19.2687 7.47059 20.1 7.11765 20.8125C9.05882 20.575 10.1765 19.5656 10.8235 18.7344L11 18.4969H12C19.9412 18.4969 20.8235 13.5094 20.8235 11.3719C20.8235 6.85938 17.5294 4.1875 12 4.1875Z" fill="black" data-v-70afb46a data-v-70afb46a></path></svg>
            0
          </span></div> <time data-v-70afb46a>Aug 24 '21</time></div></header> <div class="content" data-v-70afb46a><p>Today we'll talk about a topic I've been interested in for a few months now: data modelling in NoSQL databases, especially DynamoDB. This article assumes basic knowledge of DynamoDB, which you can get from reading <a href="https://aws-blog.de/2021/03/dynamodb-in-15-minutes.html">DynamoDB in 15 minutes</a>. I was inspired to write this by a question that I answered on <a href="https://stackoverflow.com/q/65579206/6485881">stackoverflow</a> a while ago. This finally gave me an excuse to write about the topic.</p>

<p>I'm going to introduce you to a user story first, then we're going to discuss the process of data modelling in NoSQL environments. Afterwards we'll move on to building the data model for the user story. Sprinkled throughout this, I'll show you some code examples for your data access layer.</p>

<h2>
  <a name="user-story" href="#user-story">
  </a>
  User Story
</h2>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--5skaGpwg--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/toq1yf4t5mvuea1ictqx.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--5skaGpwg--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/toq1yf4t5mvuea1ictqx.png" alt="Fromatoz logo" loading="lazy"></a></p>

<p>Fromatoz is a fictional online retailer that offers a platform, where <strong>products</strong> from different <strong>brands</strong> across various <strong>product categories</strong> are being sold. Customers can browse products by brand and have the option to filter the products from the brand by categories. Another way customers can use the product catalog is that they look at a specific category and see the products all brands offer in that category. Since the products have varying kinds of properties, Fromatoz wants to use a NoSQL database because of its flexible schema.</p>

<p>The customer also wants to track the stockpile for each product. This means that the available stock should be decreased upon purchases made by customers and increased upon arrival of new shipments. The inventory team needs to be able to quickly retrieve the current stock level for a given product.</p>

<p>Let's talk about the process we can use to turn Fromatoz' requirements into reality.</p>

<h2>
  <a name="data-modelling-in-nosql-environments" href="#data-modelling-in-nosql-environments">
  </a>
  Data modelling in NoSQL environments
</h2>

<p>The process of data modelling in a non-relational world is somewhat different from traditional data modelling for relational databases. Fortunately there are some steps you can follow to create your data model.</p>

<p>Since I didn't come up with these steps myself, I'm going to quote from the DynamoDB book by AWS Data Hero <a href="https://alexdebrie.com">Alex DeBrie</a>.<br>
The steps are:</p>

<blockquote>
<ul>
<li>Understand your application</li>
<li>Create an entity-relationship diagram ("ERD")</li>
<li>Write out all of your access patterns</li>
<li>Model your primary key structure</li>
<li>Satisfy additional access patterns with secondary indexes and streams</li>
</ul>

<p>â€” <cite>Alex DeBrie, The DynamoDB Book - chapter 7.2</cite></p>
</blockquote>

<p>The first step should seem fairly obvious, we need to have an understanding of the domain we're working in. In our case I've outlined the required information above and since you've most likely used a webshop in the past, you should be good to go.</p>

<p>Creating an entity-relationship-diagram may not seem obvious at first, since we're talking about a non-relational database. Actually the term non-relational database is misleading, in my opinion, because data in it still has relationships. The way these relationships are handled and modelled is just different from relational databases. In order to have a common basis to discuss requirements, query patterns and all of these fancy constructs, an ERD is a good start.</p>

<p>Once we've gotten an understanding of which entities exist and how they're related, we have to find out and define how these are queried. This step is critical - our access patterns will determine how we store and index our data.</p>

<p>The next two steps are what makes or breaks our data model: we create the primary key structure to satisfy our primary access patterns and use local and global secondary indexes as well as DynamoDB streams to enable additional access patterns.</p>

<p>Now that we've talked about the process and introduced the use case along with the challenges it presents, let's move on to step two: the entity relationship diagram.</p>
<h2>
  <a name="entity-relationship-diagram" href="#entity-relationship-diagram">
  </a>
  Entity Relationship Diagram
</h2>

<p>Here's a simple ERD for our use case (I'm aware it's not up to UML standards, but it's good enough):</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--BK-YPY-R--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6qk4579rfpehecexgrfz.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--BK-YPY-R--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6qk4579rfpehecexgrfz.png" alt="Fromatoz Entity-Relationship-Diagram" loading="lazy"></a></p>

<p>The diagram is fairly simple and consists only of three entities, product, brand and category. Categories can have multiple products and brands can have multiple products. Each product belongs to one brand and one category. This means we're going to have to model two one-to-many relationships (I'll talk about many to many relationships in a future post).</p>

<p>That takes care of the entity relationship diagram, let's talk about access patterns.</p>
<h2>
  <a name="access-patterns" href="#access-patterns">
  </a>
  Access Patterns
</h2>

<p>In order to understand how we'll access the data in the product catalog, we need to take a closer look at the use case description again. From there we can come up with these access patterns:</p>

<ol>
<li>Get all brands</li>
<li>Get all categories</li>
<li>Get product by id (for the stock level query)</li>
<li>Decrease stock level for product</li>
<li>Increase stock level for product</li>
<li>Get products by brand</li>
<li>Get products by brand and category</li>
<li>Get products by category</li>
<li><em>(Get products by category and brand)</em></li>
</ol>

<p>Access pattern 9 is optional, because the result of a query would be identical to that of access pattern 7. From the perspective of a user interface the difference between 7 and 9 matters, but the data layer would return the same results. We will still model access pattern 9, because, depending on the distribution of the data, it may be advantageous to choose one over the other.</p>

<p>Now it's time to build a model for these access patterns.</p>
<h2>
  <a name="building-the-model" href="#building-the-model">
  </a>
  Building the model
</h2>

<p>First we take a closer look at the access patterns and structure them for ourselves. We identify the entities affected by each access pattern and the information that will be sent via the parameters to perform the read or write operations.</p>

<div class="table-wrapper-paragraph"><table>
<thead>
<tr>
<th>#</th>
<th>Entity</th>
<th>Description</th>
<th>Parameters</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Brand</td>
<td>Get all</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>Category</td>
<td>Get all</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>Product</td>
<td>Get by id</td>
<td>
<code>&lt;pid></code> (Product ID)</td>
</tr>
<tr>
<td>4</td>
<td>Product</td>
<td>Decrease stock</td>
<td>
<code>&lt;pid></code> + <code>&lt;stockDecrement></code>
</td>
</tr>
<tr>
<td>5</td>
<td>Product</td>
<td>Increase stock</td>
<td>
<code>&lt;pid></code> + <code>&lt;stockIncrement></code>
</td>
</tr>
<tr>
<td>6</td>
<td>Product</td>
<td>List by brand</td>
<td>
<code>&lt;bid></code> (Brand ID)</td>
</tr>
<tr>
<td>7</td>
<td>Product</td>
<td>List by brand and category</td>
<td>
<code>&lt;bid></code> + <code>&lt;cid></code> (Category ID)</td>
</tr>
<tr>
<td>8</td>
<td>Product</td>
<td>List by category</td>
<td><code>&lt;cid></code></td>
</tr>
<tr>
<td>9</td>
<td>Product</td>
<td>List by category and brand</td>
<td>
<code>&lt;cid></code> + <code>&lt;bid></code>
</td>
</tr>
</tbody>
</table></div>

<p>From this table we can see, that the majority of access patterns affect the product entity, which shouldn't come as a surprise, as this is a product catalog. Before we talk about the more complex entity, let's begin modelling with the brand and category entities, which account for the access patterns 1 and 2.</p>

<p>Both of them require a list of <strong>all</strong> entities of that type.<br>
If we recall the APIs available to us, we know that there are three ways to get <strong>multiple</strong> items out of DynamoDB:</p>

<ol>
<li>
<code>BatchGetItem</code>, which batches multiple <code>GetItem</code> calls together and requires us to know the partition and sort key for all items we want to select.</li>
<li>
<code>Query</code>, which allows us to work on collections of items (those that share the same partition key) and optionally do some filtering on the sort key in the partition.</li>
<li>
<code>Scan</code> is essentially a table scan and by far the slowest and most expensive operation.</li>
</ol>

<p>Since we don't know all primary keys for all brands or categories, we can rule out <code>BatchGetItem</code>. We want to avoid <code>Scan</code> at all costs. So let's see how we can do this using <code>Query</code>. With <code>Query</code> we can easily get a whole item collection by querying for a partition key and not filtering on the sort key. This is what we're going to use to enable the access patterns 1 and 2. I have started modelling the table below:</p>

<div class="table-wrapper-paragraph"><table>
<thead>
<tr>
<th>
<strong>PK</strong> (Partition Key)</th>
<th>
<strong>SK</strong> (Sort Key)</th>
<th><strong>type</strong></th>
<th>name</th>
<th>brandId</th>
<th>categoryId</th>
</tr>
</thead>
<tbody>
<tr>
<td>BRANDS</td>
<td>B#1</td>
<td>BRAND</td>
<td>Microsoft</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>BRANDS</td>
<td>B#2</td>
<td>BRAND</td>
<td>Google</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>BRANDS</td>
<td>B#3</td>
<td>BRAND</td>
<td>Tesla</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>CATEGORIES</td>
<td>C#1</td>
<td>CATEGORY</td>
<td>Cars</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td>CATEGORIES</td>
<td>C#2</td>
<td>CATEGORY</td>
<td>Boats</td>
<td></td>
<td>2</td>
</tr>
<tr>
<td>CATEGORIES</td>
<td>C#3</td>
<td>CATEGORY</td>
<td>Phones</td>
<td></td>
<td>3</td>
</tr>
</tbody>
</table></div>

<p>Our table has a composite primary key, that's made up of <code>PK</code> as the partition key and <code>SK</code> as the sort key. I have decided to prefix the sort key values with <code>B#</code> for brand ids and <code>C#</code> for category ids. You'll see me doing this throughout the post. This helps with namespacing items in <strong>the</strong> table, since we're putting all entities in a single table. Another thing you can observe is that the brand ids and category ids are both attributes as well as values for key-attributes. This duplication is introduced on purpose to help distinguish between key-attributes and what I like to call payload-attributes. It makes serialization and deserialization easier. The <code>type</code> attribute also helps with deserialization.</p>

<p>To get a list of brands, we can now do a simple query like this one in python, which would return the first three rows of the table - the code for the <code>CATEGORIES</code> collection would look very similar:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight python"><code><span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">boto3</span>
<span class="kn">import</span> <span class="nn">boto3.dynamodb.conditions</span> <span class="k">as</span> <span class="n">conditions</span>

<span class="k">def</span> <span class="nf">get_all_brands</span><span class="p">()</span> <span class="o">-></span> <span class="n">typing</span><span class="p">.</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">resource</span><span class="p">(</span><span class="s">"dynamodb"</span><span class="p">).</span><span class="n">Table</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">query</span><span class="p">(</span>
        <span class="n">KeyConditionExpression</span><span class="o">=</span><span class="n">conditions</span><span class="p">.</span><span class="n">Key</span><span class="p">(</span><span class="s">"PK"</span><span class="p">).</span><span class="n">eq</span><span class="p">(</span><span class="s">"BRANDS"</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span><span class="p">[</span><span class="s">"Items"</span><span class="p">]</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<blockquote>
<p><strong>Note:</strong> If there are lots of reads/writes to these partitions you can consider read/write sharding-techniques, but that's beyond the scope of this article. They help avoid hot partitions at the cost of data access layer complexity.</p>
</blockquote>

<p>Moving on to the <strong>product</strong> entity. We have seven access patterns to eventually deal with, but we'll tackle them in batches. First we'll model fetching of a product by its product id as well as incrementing and decrementing of stock values. Since a product id is unique, this is an ideal use case for a <code>GetItem</code> operation, because we only want to fetch one item and know the key information for it. We'll use the same table we already used for the other entities, this is called single-table-design. Because of space constraints the layout of the table is flipped here and only focuses on the product entity.</p>

<div class="table-wrapper-paragraph"><table>
<thead>
<tr>
<th>Attribute</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>PK</td>
<td>P#1</td>
</tr>
<tr>
<td>SK</td>
<td>METADATA</td>
</tr>
<tr>
<td>type</td>
<td>PRODUCT</td>
</tr>
<tr>
<td>name</td>
<td>Model 3</td>
</tr>
<tr>
<td>productId</td>
<td>1</td>
</tr>
<tr>
<td>stockLevel</td>
<td>70</td>
</tr>
<tr>
<td>categoryId</td>
<td>1</td>
</tr>
<tr>
<td>brandId</td>
<td>3</td>
</tr>
</tbody>
</table></div>

<p>By setting it up this way we can easily request a product by it's ID and also increment and decrement the stock level. Below you can see an example implementation in python for <code>get_product_by_id</code> and <code>increment_product_stock_level</code> - the decrement would look very similar.<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight python"><code><span class="kn">import</span> <span class="nn">boto3</span>

<span class="k">def</span> <span class="nf">get_product_by_id</span><span class="p">(</span><span class="n">product_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-></span> <span class="nb">dict</span><span class="p">:</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">resource</span><span class="p">(</span><span class="s">"dynamodb"</span><span class="p">).</span><span class="n">Table</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">get_item</span><span class="p">(</span>
        <span class="n">Key</span><span class="o">=</span><span class="p">{</span>
            <span class="s">"PK"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"P#</span><span class="si">{</span><span class="n">product_id</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>
            <span class="s">"SK"</span><span class="p">:</span> <span class="s">"METADATA"</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span><span class="p">[</span><span class="s">"Item"</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">increment_product_stock_level</span><span class="p">(</span><span class="n">product_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">stock_level_increment</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-></span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">resource</span><span class="p">(</span><span class="s">"dynamodb"</span><span class="p">).</span><span class="n">Table</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span>
    <span class="n">table</span><span class="p">.</span><span class="n">update_item</span><span class="p">(</span>
        <span class="n">Key</span><span class="o">=</span><span class="p">{</span>
            <span class="s">"PK"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"P#</span><span class="si">{</span><span class="n">product_id</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>
            <span class="s">"SK"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"METADATA"</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">UpdateExpression</span><span class="o">=</span><span class="s">"SET #stock_level = #stock_level + :increment"</span><span class="p">,</span>
        <span class="n">ExpressionAttributeNames</span><span class="o">=</span><span class="p">{</span>
            <span class="s">"#stock_level"</span><span class="p">:</span> <span class="s">"stockLevel"</span>
        <span class="p">},</span>
        <span class="n">ExpressionAttributeValues</span><span class="o">=</span><span class="p">{</span>
            <span class="s">":increment"</span><span class="p">:</span> <span class="n">stock_level_increment</span>
        <span class="p">}</span>
    <span class="p">)</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>Let's take a look at the table we've created so far. The diagram below doesn't contain exactly the same values as the tables above - it's designed to show our key patterns. I suggest that you go through the five query patterns we've implemented so far in your head and try to visualize how they're retrieved from the table.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Sn2kYCHQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vyrxxbofko0obqebm3h7.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Sn2kYCHQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vyrxxbofko0obqebm3h7.png" alt="Intermediary Table" loading="lazy"></a></p>


<hr>

<p>Now it's time to talk about the remaining four access patterns.</p>

<div class="table-wrapper-paragraph"><table>
<thead>
<tr>
<th>#</th>
<th>Entity</th>
<th>Description</th>
<th>Parameters</th>
</tr>
</thead>
<tbody>
<tr>
<td>6</td>
<td>Product</td>
<td>List by brand</td>
<td>
<code>&lt;bid></code> (Brand ID)</td>
</tr>
<tr>
<td>7</td>
<td>Product</td>
<td>List by brand and category</td>
<td>
<code>&lt;bid></code> + <code>&lt;cid></code> (Category ID)</td>
</tr>
<tr>
<td>8</td>
<td>Product</td>
<td>List by category</td>
<td><code>&lt;cid></code></td>
</tr>
<tr>
<td>9</td>
<td>Product</td>
<td>List by category and brand</td>
<td>
<code>&lt;cid></code> + <code>&lt;bid></code>
</td>
</tr>
</tbody>
</table></div>

<p>After taking a closer look at them, we can see that these four access patterns can be divided into two groups that are very similar. Patterns 6 and 7 both start with the brand id as a first filter and 7 adds the category as an additional filter to the result from 6. Patterns 8 and 9 are similar - 8 filters based on a category and 9 is an additional filter on the result from 8. That means if we solve either of the combinations, we have a pattern that we can re-use for the other.</p>

<p>I usually start at the top of the list and work my way downwards, but it doesn't really matter. So let's consider 6 and 7 first. Access pattern 6 essentially requires us to model the one-to-many relationship between a brand and its products. We've already seen a pattern that allows us to do this. Use the partition key for the parent and the sort key for the children, which allows us to query for them. We can use this here as well, but there is a problem. The primary index for our table and the product index is already being used to satisfy the access patterns 3 to 5.</p>

<p>Since our primary index is already in use, we should take a look at the secondary indexes. A local secondary index would require us to use the same partition key, but we could choose a different sort key. This doesn't help us here, because the product's partition key is its ID and we would need that to be the brand it belongs to. That leaves us with a global secondary index (GSI), which allows us to choose both a different partition and sort key.<br>
Let's add a GSI, which we're going to call <code>GSI1</code> with <code>GSI1PK</code> as its partition- and <code>GSI1SK</code> as its sort key. Generic names again, because we could use them to fulfill multiple access patterns.<br>
The simplified table looks like this.</p>

<div class="table-wrapper-paragraph"><table>
<thead>
<tr>
<th>PK</th>
<th>SK</th>
<th>type</th>
<th>GSI1PK</th>
<th>GSI1SK</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>P#&lt;pid></code></td>
<td><code>METADATA</code></td>
<td><code>PRODUCT</code></td>
<td><code>B#&lt;bid></code></td>
<td><code>P#&lt;pid></code></td>
</tr>
</tbody>
</table></div>

<p>This design allows us to deliver on access pattern 6. If we take a look at access pattern 7, we have already observed that it's essentially another filter on the result of 6. There are multiple ways to implement this, but there is a particular one that I prefer. When using <code>Query</code> to fetch items from a table, we can do some filtering on the sort key - among others there is a <code>begins_with</code> operator - which we can use to utilize <code>GSI1</code> for query pattern 7 as well. To achieve that, we slightly modify our key-schema from above to look like this:</p>

<div class="table-wrapper-paragraph"><table>
<thead>
<tr>
<th>PK</th>
<th>SK</th>
<th>type</th>
<th>GSI1PK</th>
<th>GSI1SK</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>P#&lt;pid></code></td>
<td><code>METADATA</code></td>
<td><code>PRODUCT</code></td>
<td><code>B#&lt;bid></code></td>
<td><code>C#&lt;cid>#P#&lt;pid></code></td>
</tr>
</tbody>
</table></div>

<p>We prepend the category ID to <code>GSI1SK</code>, which allows us to use <code>begins_with</code> on it, while at the same time retaining the ability to do the query for 6. The product ID still needs to be kept as part of the sort key, because we need each product to show up and that only happens, if the products are distinct in the GSI. An implementation in Python for these two might look something like this:<br>
</p>

<div class="highlight js-code-highlight">
<pre class="highlight python"><code><span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">import</span> <span class="nn">boto3</span>
<span class="kn">import</span> <span class="nn">boto3.dynamodb.conditions</span> <span class="k">as</span> <span class="n">conditions</span>

<span class="k">def</span> <span class="nf">get_products_by_brand</span><span class="p">(</span><span class="n">brand_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-></span> <span class="n">typing</span><span class="p">.</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>

    <span class="n">table</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">resource</span><span class="p">(</span><span class="s">"dynamodb"</span><span class="p">).</span><span class="n">Table</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span>

    <span class="n">response</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">query</span><span class="p">(</span>
        <span class="n">IndexName</span><span class="o">=</span><span class="s">"GSI1"</span><span class="p">,</span>
        <span class="n">KeyConditionExpression</span><span class="o">=</span><span class="n">conditions</span><span class="p">.</span><span class="n">Key</span><span class="p">(</span><span class="s">"GSI1PK"</span><span class="p">).</span><span class="n">eq</span><span class="p">(</span><span class="sa">f</span><span class="s">"B#</span><span class="si">{</span><span class="n">brand_id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">response</span><span class="p">[</span><span class="s">"Items"</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_products_by_brand_and_category</span><span class="p">(</span><span class="n">brand_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">category_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-></span> <span class="n">typing</span><span class="p">.</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>

    <span class="n">table</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">resource</span><span class="p">(</span><span class="s">"dynamodb"</span><span class="p">).</span><span class="n">Table</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span>

    <span class="n">response</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">query</span><span class="p">(</span>
        <span class="n">IndexName</span><span class="o">=</span><span class="s">"GSI1"</span><span class="p">,</span>
        <span class="n">KeyConditionExpression</span><span class="o">=</span><span class="n">conditions</span><span class="p">.</span><span class="n">Key</span><span class="p">(</span><span class="s">"GSI1PK"</span><span class="p">).</span><span class="n">eq</span><span class="p">(</span><span class="sa">f</span><span class="s">"B#</span><span class="si">{</span><span class="n">brand_id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> \
            <span class="o">&</span> <span class="n">conditions</span><span class="p">.</span><span class="n">Key</span><span class="p">(</span><span class="s">"GSI1SK"</span><span class="p">).</span><span class="n">begins_with</span><span class="p">(</span><span class="sa">f</span><span class="s">"C#</span><span class="si">{</span><span class="n">category_id</span><span class="si">}</span><span class="s">#"</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">response</span><span class="p">[</span><span class="s">"Items"</span><span class="p">]</span>
</code></pre>
<div class="highlight__panel js-actions-panel">
<div class="highlight__panel-action js-fullscreen-code-action">
    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>
    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>
</svg>

    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>
    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>
</svg>

</div>
</div>
</div>



<p>This takes care of access patterns 6 and 7. I have added a further optimization, which isn't visible in the code, because it relates to <code>GSI1</code>. When you define a GSI in DynamoDB you can select which attributes should be projected into that index. There are three possible configuration parameters:</p>

<ul>
<li>
<code>KEYS_ONLY</code> - only the keys for the GSI are projected into the GSI (least expensive)</li>
<li>
<code>INCLUDE</code> - you get to specify which attributes are projected into the GSI</li>
<li>
<code>ALL</code> - projects all attributes into the GSI (most expensive)</li>
</ul>

<p>Since we only really care about the <code>type</code>, <code>name</code>, <code>description</code>, <code>stockLevel</code> and <code>productId</code> when we query for products, I chose <code>INCLUDE</code> as the projection type and only projected these onto the index. This results in GSI1 looking like this:</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--gkUFGsCK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wl9ouw0ul2chqn86ktpq.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--gkUFGsCK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wl9ouw0ul2chqn86ktpq.png" alt="GSI1" loading="lazy"></a></p>


<hr>

<p>To implement the remaining two access patterns, we essentially do the same. We can't reuse <code>GSI1</code> here, because, in this case, our partition key will have to be the category id. That's why we set up <code>GSI2</code> with the partition and sort keys <code>GSI2PK</code> and <code>GSI2SK</code> with the same projection as <code>GSI1</code>. The data in <code>GSI2</code> looks very similar to <code>GSI1</code> as a result of that (except for the primary key).</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--RrWe1uRh--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hm0i36q4rbdubxiuhd08.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--RrWe1uRh--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hm0i36q4rbdubxiuhd08.png" alt="GSI2" loading="lazy"></a></p>

<p>Earlier I mentioned that access patterns 7 and 9 are essentially identical in the items they return, but that it's advantageous to use one over the other depending on the data distribution. For this we have to consider how data is layed out in DynamoDB internally. Item collections are assigned to a storage partition depending on their partition key, i.e. all items with the same partition key live on the same storage partition. To improve scalability we try to spread out the load across these partitions evenly. One way to do that is by querying the item collections with many distinct values. If we have many brands but few categories, that means we'll have many brand partitions and using <code>GSI1</code> for that spreads out the load more evenly. Should we have many more categories than brands, <code>GSI2</code> will be better suited for this. The data model allows us this flexibility at the cost of a few more bytes in storage space.</p>


<hr>

<p><strong>Now we've created a table structure that supports all of your nine access patterns!</strong> Let's check out the final table. First we start with our key structure. The table below shows the attributes each entity needs for the access patterns to work. By now you should be able to see how we can use each of them to fulfill the access patterns.</p>

<div class="table-wrapper-paragraph"><table>
<thead>
<tr>
<th>Entity</th>
<th>PK</th>
<th>SK</th>
<th>GSI1PK</th>
<th>GSI1SK</th>
<th>GSI2PK</th>
<th>GSI2SK</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Brand</strong></td>
<td><code>BRANDS</code></td>
<td><code>B#&lt;bid></code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Category</strong></td>
<td><code>CATEGORIES</code></td>
<td><code>C#&lt;cid></code></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Product</strong></td>
<td><code>P#&lt;pid></code></td>
<td><code>METADATA</code></td>
<td><code>B#&lt;bid></code></td>
<td><code>C#&lt;cid>#P#&lt;pid></code></td>
<td><code>C#&lt;cid></code></td>
<td><code>B#&lt;bid>#P#&lt;pid></code></td>
</tr>
</tbody>
</table></div>

<p>If we now look at the whole table, we can see that it's starting to get fairly complex. That's part of the reason, why browsing a DynamoDB table based on single-table-design from the console isn't that convenient. I prefer to build a CLI tool, that uses my data access layer, to browse through the table; but that's application specific and a topic for another day.</p>

<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--g4UTQon8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dk01fvh4brpm5kntklr0.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--g4UTQon8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dk01fvh4brpm5kntklr0.png" alt="Final table" loading="lazy"></a></p>

<h2>
  <a name="wrap-up" href="#wrap-up">
  </a>
  Wrap up
</h2>

<p>Let's wrap this up for today. In this post we have gone through the process of modelling a product catalog in DynamoDB. We started with the use case description, then built an entity relationship diagram, identified our access patterns and then designed our primary key structure as well as secondary indexes to implement the access patterns. We also looked at some code examples of how a data access layer could fetch the data and perform update operations.</p>

<p>This article has been focused on one-to-many relationships and the different ways they can be modelled as well as the process of turning a use case description into a data model. If you have feedback, questions or want to get in touch to discuss projects, feel free to reach out to me through the social media channels in my bio or leave a comment.</p>

<p>â€” Maurice</p>

<p>(This article has been first published in March 2021 on <a href="https://aws-blog.de/2021/03/modelling-a-product-catalog-in-dynamodb.html">our company blog</a>)</p>

</div></article> <div class="aside-username-wrapper" data-v-10d06ee8><aside class="aside-username-block" data-v-37984f8c data-v-10d06ee8><div class="username-heading loading" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-heading" data-v-37984f8c><div class="vue-content-placeholders-heading__img"></div> <div class="vue-content-placeholders-heading__content"><div class="vue-content-placeholders-heading__title"></div> <div class="vue-content-placeholders-heading__subtitle"></div></div></div></div></div> <div class="info" data-v-37984f8c><div class="vue-content-placeholders vue-content-placeholders-is-animated" data-v-37984f8c><div class="vue-content-placeholders-text" data-v-37984f8c><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div><div class="vue-content-placeholders-text__line"></div></div></div></div></aside></div></div> <div class="comments-block" data-v-8c4375bc data-v-10d06ee8><!----> <a href="https://dev.to/mauricebrg/modelling-a-product-catalog-in-dynamodb-2oak" target="_blank" rel="nofollow noopener noreferer" class="add-comment" data-v-8c4375bc>
    Add comment
  </a></div></div> <footer data-v-22cb8fd0><span data-v-22cb8fd0>Built with</span> <a href="https://nuxtjs.org" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="nuxt-icon" data-v-22cb8fd0 data-v-22cb8fd0><path d="M13.5599 8.54348L12.8055 9.87164L10.2257 5.3282L2.306 19.274H7.66815C7.66815 20.0075 8.25298 20.6021 8.97441 20.6021H2.306C1.83937 20.6021 1.40822 20.3489 1.17494 19.9379C0.941664 19.527 0.941687 19.0208 1.175 18.6099L9.09469 4.66412C9.32802 4.25316 9.75926 4 10.226 4C10.6926 4 11.1239 4.25316 11.3572 4.66412L13.5599 8.54348V8.54348Z" fill="#00C58E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M19.2769 18.6099L14.3143 9.87165L13.5599 8.54348L12.8055 9.87165L7.84343 18.6099C7.61011 19.0208 7.61009 19.527 7.84337 19.9379C8.07665 20.3489 8.50779 20.6021 8.97443 20.6021H18.1443C18.611 20.6021 19.0424 20.3491 19.2758 19.9382C19.5092 19.5272 19.5092 19.0209 19.2758 18.6099H19.2769ZM8.97443 19.274L13.5599 11.1998L18.1443 19.274H8.97443H8.97443Z" fill="#2F495E" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M22.825 19.938C22.5917 20.3489 22.1606 20.6021 21.694 20.6021H18.1443C18.8657 20.6021 19.4505 20.0075 19.4505 19.274H21.6913L15.3331 8.07696L14.3142 9.87164L13.5599 8.54348L14.2021 7.41287C14.4354 7.00192 14.8667 6.74875 15.3334 6.74875C15.8001 6.74875 16.2313 7.00192 16.4646 7.41287L22.825 18.6099C23.0583 19.0208 23.0583 19.5271 22.825 19.938V19.938Z" fill="#108775" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a> <span data-v-22cb8fd0>&</span> <a href="https://docs.dev.to/api" rel="nofollow noopener" target="_blank" data-v-22cb8fd0><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" data-v-22cb8fd0 data-v-22cb8fd0><path d="M1.5726 5.13748C1.42945 5.20622 1.2411 5.36661 1.15822 5.48117C1 5.69503 1 5.74849 1 11.8739C1 17.9993 1 18.0528 1.15822 18.2667C1.2411 18.3812 1.42945 18.5416 1.5726 18.6104C1.8137 18.7402 2.46164 18.7478 12 18.7478C21.5384 18.7478 22.1863 18.7402 22.4274 18.6104C22.5706 18.5416 22.7589 18.3812 22.8418 18.2667C23 18.0528 23 17.9993 23 11.8739C23 5.74849 23 5.69503 22.8418 5.48117C22.7589 5.36661 22.5706 5.20622 22.4274 5.13748C22.1863 5.00764 21.5384 5 12 5C2.46164 5 1.8137 5.00764 1.5726 5.13748ZM7.7055 8.2613C8.0822 8.45989 8.59454 9.0098 8.77536 9.40694C8.89589 9.66664 8.91095 9.94922 8.91095 12.0649C8.91095 14.3104 8.90344 14.4478 8.75275 14.7839C8.51919 15.288 8.16506 15.6546 7.68288 15.899C7.26096 16.1052 7.22328 16.1128 5.7315 16.1358L4.20206 16.1663V12.1031V8.04744L5.80684 8.07035C7.27602 8.09327 7.42672 8.10854 7.7055 8.2613ZM13.6952 8.89521V9.73538H12.4521H11.2089V10.4991V11.2629H11.9623H12.7158V12.1031V12.9432H11.9623H11.2089V13.707V14.4708H12.4521H13.6952V15.3109V16.151H12C10.1315 16.151 10.0411 16.1358 9.67191 15.6928L9.47603 15.4484V12.1336C9.47603 8.46752 9.46851 8.49807 9.95069 8.20783C10.1692 8.07035 10.3425 8.05508 11.9473 8.05508H13.6952V8.89521ZM16.5658 10.3769C16.8897 11.6295 17.1685 12.6912 17.176 12.7293C17.1911 12.7675 17.4699 11.7441 17.8014 10.461C18.1254 9.17017 18.4343 8.1009 18.4795 8.08563C18.5247 8.06271 18.9541 8.06271 19.4288 8.07035L20.3028 8.09327L19.376 11.6219C18.8713 13.5542 18.4117 15.2269 18.3664 15.3261C18.0123 16.0135 17.274 16.3343 16.7164 16.0441C16.4528 15.899 16.0911 15.4865 15.9705 15.1887C15.9254 15.0665 15.4884 13.4549 15.0062 11.6142C14.524 9.76593 14.1171 8.20783 14.0945 8.15437C14.0644 8.07035 14.2301 8.05508 15.0212 8.07035L15.9856 8.09327L16.5658 10.3769Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path><path d="M5.93491 12.103V14.4707H6.27394C6.66574 14.4707 7.01983 14.3103 7.1404 14.0965C7.18559 14.0048 7.21575 13.2105 7.21575 12.0648V10.1783L6.99725 9.95683C6.80133 9.76591 6.71847 9.73535 6.35683 9.73535H5.93491V12.103Z" fill="black" data-v-22cb8fd0 data-v-22cb8fd0></path></svg></a></footer></div></div></div><script>window.__NUXT__=function(e,t,a,s){return a.type_of="article",a.id=801657,a.title="One-to-Many relationships and the process of data modelling in DynamoDB",a.description="Today we'll talk about a topic I've been interested in for a few months now: data modelling in NoSQL...",a.readable_publish_date="Aug 24 '21",a.slug="modelling-a-product-catalog-in-dynamodb-2oak",a.path="/aws-builders/modelling-a-product-catalog-in-dynamodb-2oak",a.url="https://dev.to/aws-builders/modelling-a-product-catalog-in-dynamodb-2oak",a.comments_count=0,a.public_reactions_count=18,a.collection_id=e,a.published_timestamp=t,a.positive_reactions_count=18,a.cover_image="https://res.cloudinary.com/practicaldev/image/fetch/s--ZeKUekZ9--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/y3dux1tkl194lwp5vyfy.png",a.social_image="https://res.cloudinary.com/practicaldev/image/fetch/s--GtudbHic--/c_imagga_scale,f_auto,fl_progressive,h_500,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/y3dux1tkl194lwp5vyfy.png",a.canonical_url="https://aws-blog.de/2021/03/modelling-a-product-catalog-in-dynamodb.html",a.created_at="2021-08-24T06:42:06Z",a.edited_at="2021-08-25T06:51:35Z",a.crossposted_at=e,a.published_at=t,a.last_comment_at=t,a.reading_time_minutes=13,a.tag_list="aws, database, cloud, dynamodb",a.tags=["aws","database","cloud","dynamodb"],a.body_html='<p>Today we\'ll talk about a topic I\'ve been interested in for a few months now: data modelling in NoSQL databases, especially DynamoDB. This article assumes basic knowledge of DynamoDB, which you can get from reading <a href="https://aws-blog.de/2021/03/dynamodb-in-15-minutes.html">DynamoDB in 15 minutes</a>. I was inspired to write this by a question that I answered on <a href="https://stackoverflow.com/q/65579206/6485881">stackoverflow</a> a while ago. This finally gave me an excuse to write about the topic.</p>\n\n<p>I\'m going to introduce you to a user story first, then we\'re going to discuss the process of data modelling in NoSQL environments. Afterwards we\'ll move on to building the data model for the user story. Sprinkled throughout this, I\'ll show you some code examples for your data access layer.</p>\n\n<h2>\n  <a name="user-story" href="#user-story">\n  </a>\n  User Story\n</h2>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--5skaGpwg--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/toq1yf4t5mvuea1ictqx.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--5skaGpwg--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/toq1yf4t5mvuea1ictqx.png" alt="Fromatoz logo" loading="lazy"></a></p>\n\n<p>Fromatoz is a fictional online retailer that offers a platform, where <strong>products</strong> from different <strong>brands</strong> across various <strong>product categories</strong> are being sold. Customers can browse products by brand and have the option to filter the products from the brand by categories. Another way customers can use the product catalog is that they look at a specific category and see the products all brands offer in that category. Since the products have varying kinds of properties, Fromatoz wants to use a NoSQL database because of its flexible schema.</p>\n\n<p>The customer also wants to track the stockpile for each product. This means that the available stock should be decreased upon purchases made by customers and increased upon arrival of new shipments. The inventory team needs to be able to quickly retrieve the current stock level for a given product.</p>\n\n<p>Let\'s talk about the process we can use to turn Fromatoz\' requirements into reality.</p>\n\n<h2>\n  <a name="data-modelling-in-nosql-environments" href="#data-modelling-in-nosql-environments">\n  </a>\n  Data modelling in NoSQL environments\n</h2>\n\n<p>The process of data modelling in a non-relational world is somewhat different from traditional data modelling for relational databases. Fortunately there are some steps you can follow to create your data model.</p>\n\n<p>Since I didn\'t come up with these steps myself, I\'m going to quote from the DynamoDB book by AWS Data Hero <a href="https://alexdebrie.com">Alex DeBrie</a>.<br>\nThe steps are:</p>\n\n<blockquote>\n<ul>\n<li>Understand your application</li>\n<li>Create an entity-relationship diagram ("ERD")</li>\n<li>Write out all of your access patterns</li>\n<li>Model your primary key structure</li>\n<li>Satisfy additional access patterns with secondary indexes and streams</li>\n</ul>\n\n<p>â€” <cite>Alex DeBrie, The DynamoDB Book - chapter 7.2</cite></p>\n</blockquote>\n\n<p>The first step should seem fairly obvious, we need to have an understanding of the domain we\'re working in. In our case I\'ve outlined the required information above and since you\'ve most likely used a webshop in the past, you should be good to go.</p>\n\n<p>Creating an entity-relationship-diagram may not seem obvious at first, since we\'re talking about a non-relational database. Actually the term non-relational database is misleading, in my opinion, because data in it still has relationships. The way these relationships are handled and modelled is just different from relational databases. In order to have a common basis to discuss requirements, query patterns and all of these fancy constructs, an ERD is a good start.</p>\n\n<p>Once we\'ve gotten an understanding of which entities exist and how they\'re related, we have to find out and define how these are queried. This step is critical - our access patterns will determine how we store and index our data.</p>\n\n<p>The next two steps are what makes or breaks our data model: we create the primary key structure to satisfy our primary access patterns and use local and global secondary indexes as well as DynamoDB streams to enable additional access patterns.</p>\n\n<p>Now that we\'ve talked about the process and introduced the use case along with the challenges it presents, let\'s move on to step two: the entity relationship diagram.</p>\n<h2>\n  <a name="entity-relationship-diagram" href="#entity-relationship-diagram">\n  </a>\n  Entity Relationship Diagram\n</h2>\n\n<p>Here\'s a simple ERD for our use case (I\'m aware it\'s not up to UML standards, but it\'s good enough):</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--BK-YPY-R--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6qk4579rfpehecexgrfz.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--BK-YPY-R--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6qk4579rfpehecexgrfz.png" alt="Fromatoz Entity-Relationship-Diagram" loading="lazy"></a></p>\n\n<p>The diagram is fairly simple and consists only of three entities, product, brand and category. Categories can have multiple products and brands can have multiple products. Each product belongs to one brand and one category. This means we\'re going to have to model two one-to-many relationships (I\'ll talk about many to many relationships in a future post).</p>\n\n<p>That takes care of the entity relationship diagram, let\'s talk about access patterns.</p>\n<h2>\n  <a name="access-patterns" href="#access-patterns">\n  </a>\n  Access Patterns\n</h2>\n\n<p>In order to understand how we\'ll access the data in the product catalog, we need to take a closer look at the use case description again. From there we can come up with these access patterns:</p>\n\n<ol>\n<li>Get all brands</li>\n<li>Get all categories</li>\n<li>Get product by id (for the stock level query)</li>\n<li>Decrease stock level for product</li>\n<li>Increase stock level for product</li>\n<li>Get products by brand</li>\n<li>Get products by brand and category</li>\n<li>Get products by category</li>\n<li><em>(Get products by category and brand)</em></li>\n</ol>\n\n<p>Access pattern 9 is optional, because the result of a query would be identical to that of access pattern 7. From the perspective of a user interface the difference between 7 and 9 matters, but the data layer would return the same results. We will still model access pattern 9, because, depending on the distribution of the data, it may be advantageous to choose one over the other.</p>\n\n<p>Now it\'s time to build a model for these access patterns.</p>\n<h2>\n  <a name="building-the-model" href="#building-the-model">\n  </a>\n  Building the model\n</h2>\n\n<p>First we take a closer look at the access patterns and structure them for ourselves. We identify the entities affected by each access pattern and the information that will be sent via the parameters to perform the read or write operations.</p>\n\n<div class="table-wrapper-paragraph"><table>\n<thead>\n<tr>\n<th>#</th>\n<th>Entity</th>\n<th>Description</th>\n<th>Parameters</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Brand</td>\n<td>Get all</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Category</td>\n<td>Get all</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Product</td>\n<td>Get by id</td>\n<td>\n<code>&lt;pid&gt;</code> (Product ID)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>Product</td>\n<td>Decrease stock</td>\n<td>\n<code>&lt;pid&gt;</code> + <code>&lt;stockDecrement&gt;</code>\n</td>\n</tr>\n<tr>\n<td>5</td>\n<td>Product</td>\n<td>Increase stock</td>\n<td>\n<code>&lt;pid&gt;</code> + <code>&lt;stockIncrement&gt;</code>\n</td>\n</tr>\n<tr>\n<td>6</td>\n<td>Product</td>\n<td>List by brand</td>\n<td>\n<code>&lt;bid&gt;</code> (Brand ID)</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Product</td>\n<td>List by brand and category</td>\n<td>\n<code>&lt;bid&gt;</code> + <code>&lt;cid&gt;</code> (Category ID)</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Product</td>\n<td>List by category</td>\n<td><code>&lt;cid&gt;</code></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Product</td>\n<td>List by category and brand</td>\n<td>\n<code>&lt;cid&gt;</code> + <code>&lt;bid&gt;</code>\n</td>\n</tr>\n</tbody>\n</table></div>\n\n<p>From this table we can see, that the majority of access patterns affect the product entity, which shouldn\'t come as a surprise, as this is a product catalog. Before we talk about the more complex entity, let\'s begin modelling with the brand and category entities, which account for the access patterns 1 and 2.</p>\n\n<p>Both of them require a list of <strong>all</strong> entities of that type.<br>\nIf we recall the APIs available to us, we know that there are three ways to get <strong>multiple</strong> items out of DynamoDB:</p>\n\n<ol>\n<li>\n<code>BatchGetItem</code>, which batches multiple <code>GetItem</code> calls together and requires us to know the partition and sort key for all items we want to select.</li>\n<li>\n<code>Query</code>, which allows us to work on collections of items (those that share the same partition key) and optionally do some filtering on the sort key in the partition.</li>\n<li>\n<code>Scan</code> is essentially a table scan and by far the slowest and most expensive operation.</li>\n</ol>\n\n<p>Since we don\'t know all primary keys for all brands or categories, we can rule out <code>BatchGetItem</code>. We want to avoid <code>Scan</code> at all costs. So let\'s see how we can do this using <code>Query</code>. With <code>Query</code> we can easily get a whole item collection by querying for a partition key and not filtering on the sort key. This is what we\'re going to use to enable the access patterns 1 and 2. I have started modelling the table below:</p>\n\n<div class="table-wrapper-paragraph"><table>\n<thead>\n<tr>\n<th>\n<strong>PK</strong> (Partition Key)</th>\n<th>\n<strong>SK</strong> (Sort Key)</th>\n<th><strong>type</strong></th>\n<th>name</th>\n<th>brandId</th>\n<th>categoryId</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BRANDS</td>\n<td>B#1</td>\n<td>BRAND</td>\n<td>Microsoft</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>BRANDS</td>\n<td>B#2</td>\n<td>BRAND</td>\n<td>Google</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>BRANDS</td>\n<td>B#3</td>\n<td>BRAND</td>\n<td>Tesla</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>CATEGORIES</td>\n<td>C#1</td>\n<td>CATEGORY</td>\n<td>Cars</td>\n<td></td>\n<td>1</td>\n</tr>\n<tr>\n<td>CATEGORIES</td>\n<td>C#2</td>\n<td>CATEGORY</td>\n<td>Boats</td>\n<td></td>\n<td>2</td>\n</tr>\n<tr>\n<td>CATEGORIES</td>\n<td>C#3</td>\n<td>CATEGORY</td>\n<td>Phones</td>\n<td></td>\n<td>3</td>\n</tr>\n</tbody>\n</table></div>\n\n<p>Our table has a composite primary key, that\'s made up of <code>PK</code> as the partition key and <code>SK</code> as the sort key. I have decided to prefix the sort key values with <code>B#</code> for brand ids and <code>C#</code> for category ids. You\'ll see me doing this throughout the post. This helps with namespacing items in <strong>the</strong> table, since we\'re putting all entities in a single table. Another thing you can observe is that the brand ids and category ids are both attributes as well as values for key-attributes. This duplication is introduced on purpose to help distinguish between key-attributes and what I like to call payload-attributes. It makes serialization and deserialization easier. The <code>type</code> attribute also helps with deserialization.</p>\n\n<p>To get a list of brands, we can now do a simple query like this one in python, which would return the first three rows of the table - the code for the <code>CATEGORIES</code> collection would look very similar:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight python"><code><span class="kn">import</span> <span class="nn">typing</span>\n<span class="kn">import</span> <span class="nn">boto3</span>\n<span class="kn">import</span> <span class="nn">boto3.dynamodb.conditions</span> <span class="k">as</span> <span class="n">conditions</span>\n\n<span class="k">def</span> <span class="nf">get_all_brands</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="p">.</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>\n    <span class="n">table</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">resource</span><span class="p">(</span><span class="s">"dynamodb"</span><span class="p">).</span><span class="n">Table</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span>\n    <span class="n">response</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">query</span><span class="p">(</span>\n        <span class="n">KeyConditionExpression</span><span class="o">=</span><span class="n">conditions</span><span class="p">.</span><span class="n">Key</span><span class="p">(</span><span class="s">"PK"</span><span class="p">).</span><span class="n">eq</span><span class="p">(</span><span class="s">"BRANDS"</span><span class="p">)</span>\n    <span class="p">)</span>\n    <span class="k">return</span> <span class="n">response</span><span class="p">[</span><span class="s">"Items"</span><span class="p">]</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<blockquote>\n<p><strong>Note:</strong> If there are lots of reads/writes to these partitions you can consider read/write sharding-techniques, but that\'s beyond the scope of this article. They help avoid hot partitions at the cost of data access layer complexity.</p>\n</blockquote>\n\n<p>Moving on to the <strong>product</strong> entity. We have seven access patterns to eventually deal with, but we\'ll tackle them in batches. First we\'ll model fetching of a product by its product id as well as incrementing and decrementing of stock values. Since a product id is unique, this is an ideal use case for a <code>GetItem</code> operation, because we only want to fetch one item and know the key information for it. We\'ll use the same table we already used for the other entities, this is called single-table-design. Because of space constraints the layout of the table is flipped here and only focuses on the product entity.</p>\n\n<div class="table-wrapper-paragraph"><table>\n<thead>\n<tr>\n<th>Attribute</th>\n<th>value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PK</td>\n<td>P#1</td>\n</tr>\n<tr>\n<td>SK</td>\n<td>METADATA</td>\n</tr>\n<tr>\n<td>type</td>\n<td>PRODUCT</td>\n</tr>\n<tr>\n<td>name</td>\n<td>Model 3</td>\n</tr>\n<tr>\n<td>productId</td>\n<td>1</td>\n</tr>\n<tr>\n<td>stockLevel</td>\n<td>70</td>\n</tr>\n<tr>\n<td>categoryId</td>\n<td>1</td>\n</tr>\n<tr>\n<td>brandId</td>\n<td>3</td>\n</tr>\n</tbody>\n</table></div>\n\n<p>By setting it up this way we can easily request a product by it\'s ID and also increment and decrement the stock level. Below you can see an example implementation in python for <code>get_product_by_id</code> and <code>increment_product_stock_level</code> - the decrement would look very similar.<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight python"><code><span class="kn">import</span> <span class="nn">boto3</span>\n\n<span class="k">def</span> <span class="nf">get_product_by_id</span><span class="p">(</span><span class="n">product_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>\n    <span class="n">table</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">resource</span><span class="p">(</span><span class="s">"dynamodb"</span><span class="p">).</span><span class="n">Table</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span>\n    <span class="n">response</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">get_item</span><span class="p">(</span>\n        <span class="n">Key</span><span class="o">=</span><span class="p">{</span>\n            <span class="s">"PK"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"P#</span><span class="si">{</span><span class="n">product_id</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>\n            <span class="s">"SK"</span><span class="p">:</span> <span class="s">"METADATA"</span>\n        <span class="p">}</span>\n    <span class="p">)</span>\n    <span class="k">return</span> <span class="n">response</span><span class="p">[</span><span class="s">"Item"</span><span class="p">]</span>\n\n<span class="k">def</span> <span class="nf">increment_product_stock_level</span><span class="p">(</span><span class="n">product_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">stock_level_increment</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>\n    <span class="n">table</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">resource</span><span class="p">(</span><span class="s">"dynamodb"</span><span class="p">).</span><span class="n">Table</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span>\n    <span class="n">table</span><span class="p">.</span><span class="n">update_item</span><span class="p">(</span>\n        <span class="n">Key</span><span class="o">=</span><span class="p">{</span>\n            <span class="s">"PK"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"P#</span><span class="si">{</span><span class="n">product_id</span><span class="si">}</span><span class="s">"</span><span class="p">,</span>\n            <span class="s">"SK"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"METADATA"</span><span class="p">,</span>\n        <span class="p">},</span>\n        <span class="n">UpdateExpression</span><span class="o">=</span><span class="s">"SET #stock_level = #stock_level + :increment"</span><span class="p">,</span>\n        <span class="n">ExpressionAttributeNames</span><span class="o">=</span><span class="p">{</span>\n            <span class="s">"#stock_level"</span><span class="p">:</span> <span class="s">"stockLevel"</span>\n        <span class="p">},</span>\n        <span class="n">ExpressionAttributeValues</span><span class="o">=</span><span class="p">{</span>\n            <span class="s">":increment"</span><span class="p">:</span> <span class="n">stock_level_increment</span>\n        <span class="p">}</span>\n    <span class="p">)</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>Let\'s take a look at the table we\'ve created so far. The diagram below doesn\'t contain exactly the same values as the tables above - it\'s designed to show our key patterns. I suggest that you go through the five query patterns we\'ve implemented so far in your head and try to visualize how they\'re retrieved from the table.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--Sn2kYCHQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vyrxxbofko0obqebm3h7.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--Sn2kYCHQ--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vyrxxbofko0obqebm3h7.png" alt="Intermediary Table" loading="lazy"></a></p>\n\n\n<hr>\n\n<p>Now it\'s time to talk about the remaining four access patterns.</p>\n\n<div class="table-wrapper-paragraph"><table>\n<thead>\n<tr>\n<th>#</th>\n<th>Entity</th>\n<th>Description</th>\n<th>Parameters</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>6</td>\n<td>Product</td>\n<td>List by brand</td>\n<td>\n<code>&lt;bid&gt;</code> (Brand ID)</td>\n</tr>\n<tr>\n<td>7</td>\n<td>Product</td>\n<td>List by brand and category</td>\n<td>\n<code>&lt;bid&gt;</code> + <code>&lt;cid&gt;</code> (Category ID)</td>\n</tr>\n<tr>\n<td>8</td>\n<td>Product</td>\n<td>List by category</td>\n<td><code>&lt;cid&gt;</code></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Product</td>\n<td>List by category and brand</td>\n<td>\n<code>&lt;cid&gt;</code> + <code>&lt;bid&gt;</code>\n</td>\n</tr>\n</tbody>\n</table></div>\n\n<p>After taking a closer look at them, we can see that these four access patterns can be divided into two groups that are very similar. Patterns 6 and 7 both start with the brand id as a first filter and 7 adds the category as an additional filter to the result from 6. Patterns 8 and 9 are similar - 8 filters based on a category and 9 is an additional filter on the result from 8. That means if we solve either of the combinations, we have a pattern that we can re-use for the other.</p>\n\n<p>I usually start at the top of the list and work my way downwards, but it doesn\'t really matter. So let\'s consider 6 and 7 first. Access pattern 6 essentially requires us to model the one-to-many relationship between a brand and its products. We\'ve already seen a pattern that allows us to do this. Use the partition key for the parent and the sort key for the children, which allows us to query for them. We can use this here as well, but there is a problem. The primary index for our table and the product index is already being used to satisfy the access patterns 3 to 5.</p>\n\n<p>Since our primary index is already in use, we should take a look at the secondary indexes. A local secondary index would require us to use the same partition key, but we could choose a different sort key. This doesn\'t help us here, because the product\'s partition key is its ID and we would need that to be the brand it belongs to. That leaves us with a global secondary index (GSI), which allows us to choose both a different partition and sort key.<br>\nLet\'s add a GSI, which we\'re going to call <code>GSI1</code> with <code>GSI1PK</code> as its partition- and <code>GSI1SK</code> as its sort key. Generic names again, because we could use them to fulfill multiple access patterns.<br>\nThe simplified table looks like this.</p>\n\n<div class="table-wrapper-paragraph"><table>\n<thead>\n<tr>\n<th>PK</th>\n<th>SK</th>\n<th>type</th>\n<th>GSI1PK</th>\n<th>GSI1SK</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>P#&lt;pid&gt;</code></td>\n<td><code>METADATA</code></td>\n<td><code>PRODUCT</code></td>\n<td><code>B#&lt;bid&gt;</code></td>\n<td><code>P#&lt;pid&gt;</code></td>\n</tr>\n</tbody>\n</table></div>\n\n<p>This design allows us to deliver on access pattern 6. If we take a look at access pattern 7, we have already observed that it\'s essentially another filter on the result of 6. There are multiple ways to implement this, but there is a particular one that I prefer. When using <code>Query</code> to fetch items from a table, we can do some filtering on the sort key - among others there is a <code>begins_with</code> operator - which we can use to utilize <code>GSI1</code> for query pattern 7 as well. To achieve that, we slightly modify our key-schema from above to look like this:</p>\n\n<div class="table-wrapper-paragraph"><table>\n<thead>\n<tr>\n<th>PK</th>\n<th>SK</th>\n<th>type</th>\n<th>GSI1PK</th>\n<th>GSI1SK</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>P#&lt;pid&gt;</code></td>\n<td><code>METADATA</code></td>\n<td><code>PRODUCT</code></td>\n<td><code>B#&lt;bid&gt;</code></td>\n<td><code>C#&lt;cid&gt;#P#&lt;pid&gt;</code></td>\n</tr>\n</tbody>\n</table></div>\n\n<p>We prepend the category ID to <code>GSI1SK</code>, which allows us to use <code>begins_with</code> on it, while at the same time retaining the ability to do the query for 6. The product ID still needs to be kept as part of the sort key, because we need each product to show up and that only happens, if the products are distinct in the GSI. An implementation in Python for these two might look something like this:<br>\n</p>\n\n<div class="highlight js-code-highlight">\n<pre class="highlight python"><code><span class="kn">import</span> <span class="nn">typing</span>\n<span class="kn">import</span> <span class="nn">boto3</span>\n<span class="kn">import</span> <span class="nn">boto3.dynamodb.conditions</span> <span class="k">as</span> <span class="n">conditions</span>\n\n<span class="k">def</span> <span class="nf">get_products_by_brand</span><span class="p">(</span><span class="n">brand_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="p">.</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>\n\n    <span class="n">table</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">resource</span><span class="p">(</span><span class="s">"dynamodb"</span><span class="p">).</span><span class="n">Table</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span>\n\n    <span class="n">response</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">query</span><span class="p">(</span>\n        <span class="n">IndexName</span><span class="o">=</span><span class="s">"GSI1"</span><span class="p">,</span>\n        <span class="n">KeyConditionExpression</span><span class="o">=</span><span class="n">conditions</span><span class="p">.</span><span class="n">Key</span><span class="p">(</span><span class="s">"GSI1PK"</span><span class="p">).</span><span class="n">eq</span><span class="p">(</span><span class="sa">f</span><span class="s">"B#</span><span class="si">{</span><span class="n">brand_id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>\n    <span class="p">)</span>\n\n    <span class="k">return</span> <span class="n">response</span><span class="p">[</span><span class="s">"Items"</span><span class="p">]</span>\n\n<span class="k">def</span> <span class="nf">get_products_by_brand_and_category</span><span class="p">(</span><span class="n">brand_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">category_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">typing</span><span class="p">.</span><span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>\n\n    <span class="n">table</span> <span class="o">=</span> <span class="n">boto3</span><span class="p">.</span><span class="n">resource</span><span class="p">(</span><span class="s">"dynamodb"</span><span class="p">).</span><span class="n">Table</span><span class="p">(</span><span class="s">"data"</span><span class="p">)</span>\n\n    <span class="n">response</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">query</span><span class="p">(</span>\n        <span class="n">IndexName</span><span class="o">=</span><span class="s">"GSI1"</span><span class="p">,</span>\n        <span class="n">KeyConditionExpression</span><span class="o">=</span><span class="n">conditions</span><span class="p">.</span><span class="n">Key</span><span class="p">(</span><span class="s">"GSI1PK"</span><span class="p">).</span><span class="n">eq</span><span class="p">(</span><span class="sa">f</span><span class="s">"B#</span><span class="si">{</span><span class="n">brand_id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> \\\n            <span class="o">&amp;</span> <span class="n">conditions</span><span class="p">.</span><span class="n">Key</span><span class="p">(</span><span class="s">"GSI1SK"</span><span class="p">).</span><span class="n">begins_with</span><span class="p">(</span><span class="sa">f</span><span class="s">"C#</span><span class="si">{</span><span class="n">category_id</span><span class="si">}</span><span class="s">#"</span><span class="p">)</span>\n    <span class="p">)</span>\n\n    <span class="k">return</span> <span class="n">response</span><span class="p">[</span><span class="s">"Items"</span><span class="p">]</span>\n</code></pre>\n<div class="highlight__panel js-actions-panel">\n<div class="highlight__panel-action js-fullscreen-code-action">\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-on"><title>Enter fullscreen mode</title>\n    <path d="M16 3h6v6h-2V5h-4V3zM2 3h6v2H4v4H2V3zm18 16v-4h2v6h-6v-2h4zM4 19h4v2H2v-6h2v4z"></path>\n</svg>\n\n    <svg xmlns="http://www.w3.org/2000/svg" width="20px" height="20px" viewbox="0 0 24 24" class="highlight-action crayons-icon highlight-action--fullscreen-off"><title>Exit fullscreen mode</title>\n    <path d="M18 7h4v2h-6V3h2v4zM8 9H2V7h4V3h2v6zm10 8v4h-2v-6h6v2h-4zM8 15v6H6v-4H2v-2h6z"></path>\n</svg>\n\n</div>\n</div>\n</div>\n\n\n\n<p>This takes care of access patterns 6 and 7. I have added a further optimization, which isn\'t visible in the code, because it relates to <code>GSI1</code>. When you define a GSI in DynamoDB you can select which attributes should be projected into that index. There are three possible configuration parameters:</p>\n\n<ul>\n<li>\n<code>KEYS_ONLY</code> - only the keys for the GSI are projected into the GSI (least expensive)</li>\n<li>\n<code>INCLUDE</code> - you get to specify which attributes are projected into the GSI</li>\n<li>\n<code>ALL</code> - projects all attributes into the GSI (most expensive)</li>\n</ul>\n\n<p>Since we only really care about the <code>type</code>, <code>name</code>, <code>description</code>, <code>stockLevel</code> and <code>productId</code> when we query for products, I chose <code>INCLUDE</code> as the projection type and only projected these onto the index. This results in GSI1 looking like this:</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--gkUFGsCK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wl9ouw0ul2chqn86ktpq.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--gkUFGsCK--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wl9ouw0ul2chqn86ktpq.png" alt="GSI1" loading="lazy"></a></p>\n\n\n<hr>\n\n<p>To implement the remaining two access patterns, we essentially do the same. We can\'t reuse <code>GSI1</code> here, because, in this case, our partition key will have to be the category id. That\'s why we set up <code>GSI2</code> with the partition and sort keys <code>GSI2PK</code> and <code>GSI2SK</code> with the same projection as <code>GSI1</code>. The data in <code>GSI2</code> looks very similar to <code>GSI1</code> as a result of that (except for the primary key).</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--RrWe1uRh--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hm0i36q4rbdubxiuhd08.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--RrWe1uRh--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hm0i36q4rbdubxiuhd08.png" alt="GSI2" loading="lazy"></a></p>\n\n<p>Earlier I mentioned that access patterns 7 and 9 are essentially identical in the items they return, but that it\'s advantageous to use one over the other depending on the data distribution. For this we have to consider how data is layed out in DynamoDB internally. Item collections are assigned to a storage partition depending on their partition key, i.e. all items with the same partition key live on the same storage partition. To improve scalability we try to spread out the load across these partitions evenly. One way to do that is by querying the item collections with many distinct values. If we have many brands but few categories, that means we\'ll have many brand partitions and using <code>GSI1</code> for that spreads out the load more evenly. Should we have many more categories than brands, <code>GSI2</code> will be better suited for this. The data model allows us this flexibility at the cost of a few more bytes in storage space.</p>\n\n\n<hr>\n\n<p><strong>Now we\'ve created a table structure that supports all of your nine access patterns!</strong> Let\'s check out the final table. First we start with our key structure. The table below shows the attributes each entity needs for the access patterns to work. By now you should be able to see how we can use each of them to fulfill the access patterns.</p>\n\n<div class="table-wrapper-paragraph"><table>\n<thead>\n<tr>\n<th>Entity</th>\n<th>PK</th>\n<th>SK</th>\n<th>GSI1PK</th>\n<th>GSI1SK</th>\n<th>GSI2PK</th>\n<th>GSI2SK</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Brand</strong></td>\n<td><code>BRANDS</code></td>\n<td><code>B#&lt;bid&gt;</code></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>Category</strong></td>\n<td><code>CATEGORIES</code></td>\n<td><code>C#&lt;cid&gt;</code></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>Product</strong></td>\n<td><code>P#&lt;pid&gt;</code></td>\n<td><code>METADATA</code></td>\n<td><code>B#&lt;bid&gt;</code></td>\n<td><code>C#&lt;cid&gt;#P#&lt;pid&gt;</code></td>\n<td><code>C#&lt;cid&gt;</code></td>\n<td><code>B#&lt;bid&gt;#P#&lt;pid&gt;</code></td>\n</tr>\n</tbody>\n</table></div>\n\n<p>If we now look at the whole table, we can see that it\'s starting to get fairly complex. That\'s part of the reason, why browsing a DynamoDB table based on single-table-design from the console isn\'t that convenient. I prefer to build a CLI tool, that uses my data access layer, to browse through the table; but that\'s application specific and a topic for another day.</p>\n\n<p><a href="https://res.cloudinary.com/practicaldev/image/fetch/s--g4UTQon8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dk01fvh4brpm5kntklr0.png" class="article-body-image-wrapper"><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--g4UTQon8--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dk01fvh4brpm5kntklr0.png" alt="Final table" loading="lazy"></a></p>\n\n<h2>\n  <a name="wrap-up" href="#wrap-up">\n  </a>\n  Wrap up\n</h2>\n\n<p>Let\'s wrap this up for today. In this post we have gone through the process of modelling a product catalog in DynamoDB. We started with the use case description, then built an entity relationship diagram, identified our access patterns and then designed our primary key structure as well as secondary indexes to implement the access patterns. We also looked at some code examples of how a data access layer could fetch the data and perform update operations.</p>\n\n<p>This article has been focused on one-to-many relationships and the different ways they can be modelled as well as the process of turning a use case description into a data model. If you have feedback, questions or want to get in touch to discuss projects, feel free to reach out to me through the social media channels in my bio or leave a comment.</p>\n\n<p>â€” Maurice</p>\n\n<p>(This article has been first published in March 2021 on <a href="https://aws-blog.de/2021/03/modelling-a-product-catalog-in-dynamodb.html">our company blog</a>)</p>\n\n',a.body_markdown='Today we\'ll talk about a topic I\'ve been interested in for a few months now: data modelling in NoSQL databases, especially DynamoDB. This article assumes basic knowledge of DynamoDB, which you can get from reading [DynamoDB in 15 minutes](https://aws-blog.de/2021/03/dynamodb-in-15-minutes.html). I was inspired to write this by a question that I answered on [stackoverflow](https://stackoverflow.com/q/65579206/6485881) a while ago. This finally gave me an excuse to write about the topic.\n\nI\'m going to introduce you to a user story first, then we\'re going to discuss the process of data modelling in NoSQL environments. Afterwards we\'ll move on to building the data model for the user story. Sprinkled throughout this, I\'ll show you some code examples for your data access layer.\n\n## User Story\n\n![Fromatoz logo](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/toq1yf4t5mvuea1ictqx.png)\n\nFromatoz is a fictional online retailer that offers a platform, where **products** from different **brands** across various **product categories** are being sold. Customers can browse products by brand and have the option to filter the products from the brand by categories. Another way customers can use the product catalog is that they look at a specific category and see the products all brands offer in that category. Since the products have varying kinds of properties, Fromatoz wants to use a NoSQL database because of its flexible schema.\n\nThe customer also wants to track the stockpile for each product. This means that the available stock should be decreased upon purchases made by customers and increased upon arrival of new shipments. The inventory team needs to be able to quickly retrieve the current stock level for a given product.\n\nLet\'s talk about the process we can use to turn Fromatoz\' requirements into reality.\n\n## Data modelling in NoSQL environments\n\nThe process of data modelling in a non-relational world is somewhat different from traditional data modelling for relational databases. Fortunately there are some steps you can follow to create your data model.\n\nSince I didn\'t come up with these steps myself, I\'m going to quote from the DynamoDB book by AWS Data Hero [Alex DeBrie](https://alexdebrie.com).\nThe steps are:\n\n> - Understand your application\n> - Create an entity-relationship diagram ("ERD")\n> - Write out all of your access patterns\n> - Model your primary key structure\n> - Satisfy additional access patterns with secondary indexes and streams\n>\n> &mdash; <cite>Alex DeBrie, The DynamoDB Book - chapter 7.2</cite>\n\nThe first step should seem fairly obvious, we need to have an understanding of the domain we\'re working in. In our case I\'ve outlined the required information above and since you\'ve most likely used a webshop in the past, you should be good to go.\n\nCreating an entity-relationship-diagram may not seem obvious at first, since we\'re talking about a non-relational database. Actually the term non-relational database is misleading, in my opinion, because data in it still has relationships. The way these relationships are handled and modelled is just different from relational databases. In order to have a common basis to discuss requirements, query patterns and all of these fancy constructs, an ERD is a good start.\n\nOnce we\'ve gotten an understanding of which entities exist and how they\'re related, we have to find out and define how these are queried. This step is critical - our access patterns will determine how we store and index our data.\n\nThe next two steps are what makes or breaks our data model: we create the primary key structure to satisfy our primary access patterns and use local and global secondary indexes as well as DynamoDB streams to enable additional access patterns.\n\nNow that we\'ve talked about the process and introduced the use case along with the challenges it presents, let\'s move on to step two: the entity relationship diagram.\n\n## Entity Relationship Diagram\n\nHere\'s a simple ERD for our use case (I\'m aware it\'s not up to UML standards, but it\'s good enough):\n\n![Fromatoz Entity-Relationship-Diagram](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/6qk4579rfpehecexgrfz.png)\n\nThe diagram is fairly simple and consists only of three entities, product, brand and category. Categories can have multiple products and brands can have multiple products. Each product belongs to one brand and one category. This means we\'re going to have to model two one-to-many relationships (I\'ll talk about many to many relationships in a future post).\n\nThat takes care of the entity relationship diagram, let\'s talk about access patterns.\n\n## Access Patterns\n\nIn order to understand how we\'ll access the data in the product catalog, we need to take a closer look at the use case description again. From there we can come up with these access patterns:\n\n1. Get all brands\n2. Get all categories\n3. Get product by id (for the stock level query)\n4. Decrease stock level for product\n5. Increase stock level for product\n6. Get products by brand\n7. Get products by brand and category\n8. Get products by category\n9. _(Get products by category and brand)_\n\nAccess pattern 9 is optional, because the result of a query would be identical to that of access pattern 7. From the perspective of a user interface the difference between 7 and 9 matters, but the data layer would return the same results. We will still model access pattern 9, because, depending on the distribution of the data, it may be advantageous to choose one over the other.\n\nNow it\'s time to build a model for these access patterns.\n\n## Building the model\n\nFirst we take a closer look at the access patterns and structure them for ourselves. We identify the entities affected by each access pattern and the information that will be sent via the parameters to perform the read or write operations.\n\n| # | Entity | Description | Parameters |\n| --- | --- | --- | --- |\n| 1 | Brand | Get all | |\n| 2 | Category | Get all | |\n| 3 | Product | Get by id | `<pid>` (Product ID) |\n| 4 | Product | Decrease stock | `<pid>` + `<stockDecrement>`|\n| 5 | Product | Increase stock | `<pid>` + `<stockIncrement>` |\n| 6 | Product | List by brand | `<bid>` (Brand ID) |\n| 7 | Product | List by brand and category | `<bid>` + `<cid>` (Category ID) |\n| 8 | Product | List by category | `<cid>` |\n| 9 | Product | List by category and brand | `<cid>` + `<bid>`|\n\nFrom this table we can see, that the majority of access patterns affect the product entity, which shouldn\'t come as a surprise, as this is a product catalog. Before we talk about the more complex entity, let\'s begin modelling with the brand and category entities, which account for the access patterns 1 and 2.\n\nBoth of them require a list of **all** entities of that type.\nIf we recall the APIs available to us, we know that there are three ways to get **multiple** items out of DynamoDB:\n\n1. `BatchGetItem`, which batches multiple `GetItem` calls together and requires us to know the partition and sort key for all items we want to select.\n2. `Query`, which allows us to work on collections of items (those that share the same partition key) and optionally do some filtering on the sort key in the partition.\n3. `Scan` is essentially a table scan and by far the slowest and most expensive operation.\n\nSince we don\'t know all primary keys for all brands or categories, we can rule out `BatchGetItem`. We want to avoid `Scan` at all costs. So let\'s see how we can do this using `Query`. With `Query` we can easily get a whole item collection by querying for a partition key and not filtering on the sort key. This is what we\'re going to use to enable the access patterns 1 and 2. I have started modelling the table below:\n\n| **PK** (Partition Key) | **SK** (Sort Key) | **type** | name | brandId | categoryId |\n|---|---|---|---|---|---|\n| BRANDS | B#1 | BRAND | Microsoft | 1 | |\n| BRANDS | B#2 | BRAND | Google | 2 | |\n| BRANDS | B#3 | BRAND | Tesla |  3 | |\n| CATEGORIES | C#1 | CATEGORY | Cars | | 1 |\n| CATEGORIES | C#2 | CATEGORY | Boats | | 2 |\n| CATEGORIES | C#3 | CATEGORY | Phones | | 3 |\n\nOur table has a composite primary key, that\'s made up of `PK` as the partition key and `SK` as the sort key. I have decided to prefix the sort key values with `B#` for brand ids and `C#` for category ids. You\'ll see me doing this throughout the post. This helps with namespacing items in **the** table, since we\'re putting all entities in a single table. Another thing you can observe is that the brand ids and category ids are both attributes as well as values for key-attributes. This duplication is introduced on purpose to help distinguish between key-attributes and what I like to call payload-attributes. It makes serialization and deserialization easier. The `type` attribute also helps with deserialization.\n\nTo get a list of brands, we can now do a simple query like this one in python, which would return the first three rows of the table - the code for the `CATEGORIES` collection would look very similar:\n\n```python\nimport typing\nimport boto3\nimport boto3.dynamodb.conditions as conditions\n\ndef get_all_brands() -> typing.List[dict]:\n    table = boto3.resource("dynamodb").Table("data")\n    response = table.query(\n        KeyConditionExpression=conditions.Key("PK").eq("BRANDS")\n    )\n    return response["Items"]\n```\n\n> **Note:** If there are lots of reads/writes to these partitions you can consider read/write sharding-techniques, but that\'s beyond the scope of this article. They help avoid hot partitions at the cost of data access layer complexity.\n\nMoving on to the **product** entity. We have seven access patterns to eventually deal with, but we\'ll tackle them in batches. First we\'ll model fetching of a product by its product id as well as incrementing and decrementing of stock values. Since a product id is unique, this is an ideal use case for a `GetItem` operation, because we only want to fetch one item and know the key information for it. We\'ll use the same table we already used for the other entities, this is called single-table-design. Because of space constraints the layout of the table is flipped here and only focuses on the product entity.\n\n| Attribute | value |\n| --- | --- |\n| PK | P#1 |\n| SK | METADATA |\n| type | PRODUCT |\n| name | Model 3 |\n| productId | 1 |\n| stockLevel | 70 |\n| categoryId | 1 |\n| brandId | 3 |\n\nBy setting it up this way we can easily request a product by it\'s ID and also increment and decrement the stock level. Below you can see an example implementation in python for `get_product_by_id` and `increment_product_stock_level` - the decrement would look very similar.\n\n```python\nimport boto3\n\ndef get_product_by_id(product_id: str) -> dict:\n    table = boto3.resource("dynamodb").Table("data")\n    response = table.get_item(\n        Key={\n            "PK": f"P#{product_id}",\n            "SK": "METADATA"\n        }\n    )\n    return response["Item"]\n\ndef increment_product_stock_level(product_id: str, stock_level_increment: int) -> None:\n    table = boto3.resource("dynamodb").Table("data")\n    table.update_item(\n        Key={\n            "PK": f"P#{product_id}",\n            "SK": f"METADATA",\n        },\n        UpdateExpression="SET #stock_level = #stock_level + :increment",\n        ExpressionAttributeNames={\n            "#stock_level": "stockLevel"\n        },\n        ExpressionAttributeValues={\n            ":increment": stock_level_increment\n        }\n    )\n```\n\nLet\'s take a look at the table we\'ve created so far. The diagram below doesn\'t contain exactly the same values as the tables above - it\'s designed to show our key patterns. I suggest that you go through the five query patterns we\'ve implemented so far in your head and try to visualize how they\'re retrieved from the table.\n\n![Intermediary Table](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vyrxxbofko0obqebm3h7.png)\n\n---\n\nNow it\'s time to talk about the remaining four access patterns.\n\n| # | Entity | Description | Parameters |\n| --- | --- | --- | --- |\n| 6 | Product | List by brand | `<bid>` (Brand ID) |\n| 7 | Product | List by brand and category | `<bid>` + `<cid>` (Category ID) |\n| 8 | Product | List by category | `<cid>` |\n| 9 | Product | List by category and brand | `<cid>` + `<bid>`|\n\nAfter taking a closer look at them, we can see that these four access patterns can be divided into two groups that are very similar. Patterns 6 and 7 both start with the brand id as a first filter and 7 adds the category as an additional filter to the result from 6. Patterns 8 and 9 are similar - 8 filters based on a category and 9 is an additional filter on the result from 8. That means if we solve either of the combinations, we have a pattern that we can re-use for the other.\n\nI usually start at the top of the list and work my way downwards, but it doesn\'t really matter. So let\'s consider 6 and 7 first. Access pattern 6 essentially requires us to model the one-to-many relationship between a brand and its products. We\'ve already seen a pattern that allows us to do this. Use the partition key for the parent and the sort key for the children, which allows us to query for them. We can use this here as well, but there is a problem. The primary index for our table and the product index is already being used to satisfy the access patterns 3 to 5.\n\nSince our primary index is already in use, we should take a look at the secondary indexes. A local secondary index would require us to use the same partition key, but we could choose a different sort key. This doesn\'t help us here, because the product\'s partition key is its ID and we would need that to be the brand it belongs to. That leaves us with a global secondary index (GSI), which allows us to choose both a different partition and sort key.\nLet\'s add a GSI, which we\'re going to call `GSI1` with `GSI1PK` as its partition- and `GSI1SK` as its sort key. Generic names again, because we could use them to fulfill multiple access patterns.\nThe simplified table looks like this.\n\n| PK | SK | type | GSI1PK | GSI1SK |\n|---|---|---|---|---|\n| `P#<pid>` | `METADATA` | `PRODUCT` | `B#<bid>` | `P#<pid>` |\n\nThis design allows us to deliver on access pattern 6. If we take a look at access pattern 7, we have already observed that it\'s essentially another filter on the result of 6. There are multiple ways to implement this, but there is a particular one that I prefer. When using `Query` to fetch items from a table, we can do some filtering on the sort key - among others there is a `begins_with` operator - which we can use to utilize `GSI1` for query pattern 7 as well. To achieve that, we slightly modify our key-schema from above to look like this:\n\n| PK | SK | type | GSI1PK | GSI1SK |\n|---|---|---|---|---|\n| `P#<pid>` | `METADATA` | `PRODUCT` | `B#<bid>` | `C#<cid>#P#<pid>` |\n\nWe prepend the category ID to `GSI1SK`, which allows us to use `begins_with` on it, while at the same time retaining the ability to do the query for 6. The product ID still needs to be kept as part of the sort key, because we need each product to show up and that only happens, if the products are distinct in the GSI. An implementation in Python for these two might look something like this:\n\n```python\nimport typing\nimport boto3\nimport boto3.dynamodb.conditions as conditions\n\ndef get_products_by_brand(brand_id: str) -> typing.List[dict]:\n\n    table = boto3.resource("dynamodb").Table("data")\n\n    response = table.query(\n        IndexName="GSI1",\n        KeyConditionExpression=conditions.Key("GSI1PK").eq(f"B#{brand_id}")\n    )\n\n    return response["Items"]\n\ndef get_products_by_brand_and_category(brand_id: str, category_id: str) -> typing.List[dict]:\n\n    table = boto3.resource("dynamodb").Table("data")\n\n    response = table.query(\n        IndexName="GSI1",\n        KeyConditionExpression=conditions.Key("GSI1PK").eq(f"B#{brand_id}") \\\n            & conditions.Key("GSI1SK").begins_with(f"C#{category_id}#")\n    )\n\n    return response["Items"]\n```\n\nThis takes care of access patterns 6 and 7. I have added a further optimization, which isn\'t visible in the code, because it relates to `GSI1`. When you define a GSI in DynamoDB you can select which attributes should be projected into that index. There are three possible configuration parameters:\n\n- `KEYS_ONLY` - only the keys for the GSI are projected into the GSI (least expensive)\n- `INCLUDE` - you get to specify which attributes are projected into the GSI\n- `ALL` - projects all attributes into the GSI (most expensive)\n\nSince we only really care about the `type`, `name`, `description`, `stockLevel` and `productId` when we query for products, I chose `INCLUDE` as the projection type and only projected these onto the index. This results in GSI1 looking like this:\n\n![GSI1](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wl9ouw0ul2chqn86ktpq.png)\n\n---\n\nTo implement the remaining two access patterns, we essentially do the same. We can\'t reuse `GSI1` here, because, in this case, our partition key will have to be the category id. That\'s why we set up `GSI2` with the partition and sort keys `GSI2PK` and `GSI2SK` with the same projection as `GSI1`. The data in `GSI2` looks very similar to `GSI1` as a result of that (except for the primary key).\n\n![GSI2](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/hm0i36q4rbdubxiuhd08.png)\n\n\nEarlier I mentioned that access patterns 7 and 9 are essentially identical in the items they return, but that it\'s advantageous to use one over the other depending on the data distribution. For this we have to consider how data is layed out in DynamoDB internally. Item collections are assigned to a storage partition depending on their partition key, i.e. all items with the same partition key live on the same storage partition. To improve scalability we try to spread out the load across these partitions evenly. One way to do that is by querying the item collections with many distinct values. If we have many brands but few categories, that means we\'ll have many brand partitions and using `GSI1` for that spreads out the load more evenly. Should we have many more categories than brands, `GSI2` will be better suited for this. The data model allows us this flexibility at the cost of a few more bytes in storage space.\n\n---\n\n**Now we\'ve created a table structure that supports all of your nine access patterns!** Let\'s check out the final table. First we start with our key structure. The table below shows the attributes each entity needs for the access patterns to work. By now you should be able to see how we can use each of them to fulfill the access patterns.\n\n|Entity| PK | SK | GSI1PK | GSI1SK | GSI2PK | GSI2SK |\n|---|---|---|---|---|---|---|\n|**Brand**| `BRANDS` | `B#<bid>` |\n|**Category**| `CATEGORIES` | `C#<cid>` |\n|**Product**| `P#<pid>` | `METADATA` | `B#<bid>` | `C#<cid>#P#<pid>` |`C#<cid>` | `B#<bid>#P#<pid>` |\n\nIf we now look at the whole table, we can see that it\'s starting to get fairly complex. That\'s part of the reason, why browsing a DynamoDB table based on single-table-design from the console isn\'t that convenient. I prefer to build a CLI tool, that uses my data access layer, to browse through the table; but that\'s application specific and a topic for another day.\n\n![Final table](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/dk01fvh4brpm5kntklr0.png)\n\n## Wrap up\n\nLet\'s wrap this up for today. In this post we have gone through the process of modelling a product catalog in DynamoDB. We started with the use case description, then built an entity relationship diagram, identified our access patterns and then designed our primary key structure as well as secondary indexes to implement the access patterns. We also looked at some code examples of how a data access layer could fetch the data and perform update operations.\n\nThis article has been focused on one-to-many relationships and the different ways they can be modelled as well as the process of turning a use case description into a data model. If you have feedback, questions or want to get in touch to discuss projects, feel free to reach out to me through the social media channels in my bio or leave a comment.\n\n&mdash; Maurice\n\n(This article has been first published in March 2021 on [our company blog](https://aws-blog.de/2021/03/modelling-a-product-catalog-in-dynamodb.html))',a.user={name:"Maurice Borgmeier",username:"mauricebrg",twitter_username:"Maurice_Brg",github_username:"MauriceBrg",website_url:"https://mauricebrg.com",profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s---L_2a2KF--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/653123/2187dc80-18ee-48d9-ab57-ae0c2ab3761f.jpeg",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--Ff2f00GE--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/user/profile_image/653123/2187dc80-18ee-48d9-ab57-ae0c2ab3761f.jpeg"},a.organization={name:"AWS Community Builders ",username:s,slug:s,profile_image:"https://res.cloudinary.com/practicaldev/image/fetch/s--zmOZQNzv--/c_fill,f_auto,fl_progressive,h_640,q_auto,w_640/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/2794/88da75b6-aadd-4ea1-8083-ae2dfca8be94.png",profile_image_90:"https://res.cloudinary.com/practicaldev/image/fetch/s--vWmcJ-ty--/c_fill,f_auto,fl_progressive,h_90,q_auto,w_90/https://dev-to-uploads.s3.amazonaws.com/uploads/organization/profile_image/2794/88da75b6-aadd-4ea1-8083-ae2dfca8be94.png"},{layout:"default",data:[{}],fetch:{"data-v-70afb46a:0":{article:a}},error:e,state:{currentArticle:a},serverRendered:!0,routePath:"/mauricebrg/801657",config:{_app:{basePath:"/nuxtstop/",assetsPath:"/nuxtstop/_nuxt/",cdnURL:e}}}}(null,"2021-08-24T06:44:02Z",{},"aws-builders")</script><script src="/nuxtstop/_nuxt/f6e87fb.js" defer></script><script src="/nuxtstop/_nuxt/dc9ce94.js" defer></script><script src="/nuxtstop/_nuxt/6474719.js" defer></script><script src="/nuxtstop/_nuxt/9b75090.js" defer></script><script src="/nuxtstop/_nuxt/18df600.js" defer></script>
  </body>
</html>
